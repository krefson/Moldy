%MOLecular DYnamics simulation code, Moldy.
%Copyright (C) 1988, 1992, 1993 Keith Refson
% 
%This program is free software; you can redistribute it and/or modify it
%under the terms of the GNU General Public License as published by the
%Free Software Foundation; either version 2, or (at your option) any
%later version.
% 
%This program is distributed in the hope that it will be useful,
%but WITHOUT ANY WARRANTY; without even the implied warranty of
%MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%GNU General Public License for more details.
% 
%You should have received a copy of the GNU General Public License
%along with this program; if not, write to the Free Software
%Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
% 
%In other words, you are welcome to use, share and improve this program.
%You are forbidden to forbid anyone else to use, share and improve
%what you give them.   Help stamp out software-hoarding!  */
\documentclass[twoside]{report}
\oddsidemargin=0.125in
\evensidemargin=-0.25in
\textwidth=6.25in
\topmargin=0pt
\textheight=9in
{\def\$#1${#1}%                               %%% Special Kludge for RCS
\xdef\RCSrevision{\$Revision: 2.9 $}\xdef\manversA{$\$junk $ $}}
\title{{\Huge Moldy User's Manual}\\ \RCSrevision}
\author{Keith Refson\\Department of Earth Sciences\\Parks Road
\\Oxford OX1 3PR\\keith@earth.ox.ac.uk\\}

\hyphenation{const-ant con-stant}
\hyphenation{Gaussian Gaus-sian}

\newcommand{\moldy}{{\em Moldy}}
\newcommand{\etc}{{\em etc}}
\newcommand{\eg}{{\em e.g}.\ }
\newcommand{\ie}{{\em i.e}.\ }
\newcommand{\bm}[1]{\mbox{\boldmath \protect\(#1\protect\)}}

\newcommand{\erf}{\mbox{erf}}
\newcommand{\erfc}{\mbox{erfc}}
\newcommand{\insqrt}{\sqrt{\mathstrut}}
\makeatletter
\def\sideset#1#2#3{%
  \setbox\z@\hbox{$\displaystyle{\vphantom{#3}}#1{#3}\m@th$}%
  \setbox\tw@\hbox{$\displaystyle{#3}#2\m@th$}%
  \hskip\wd\z@\hskip-\wd\tw@\mathop{\hskip\wd\tw@\hskip-\wd\z@
  {\vphantom{#3}}#1{#3}#2}}
\makeatother
\begin{document}
\maketitle
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\moldy\ is a computer program for performing molecular dynamics
simulations of condensed matter.  It can handle any assembly of rigid
polyatomic molecules, atoms or ions and any mixture thereof. It uses
the `link cell' method to calculate short-range forces and the Ewald
sum technique to handle long-range electrostatic forces.  Simulations
may be performed either in the usual $NVE$ ensemble or in $NVT$,
$N\sigma H$ or $N\sigma T$ ensembles using Nos\'e-Hoover thermostat and
Parrinello and Rahman constant-stress methods. As the MD cell need not
be cubic, the program is equally suitable for simulations of solids
and liquids.

Most existing MD programs are limited in their capabilities, for
example to one kind of potential function, or molecular symmetry, or
to some restricted number of molecules.  \moldy\  is (as far as
possible) free from such arbitrary constraints.  The system is
specified at the beginning of each run and its size is only limited by
the amount of memory available to the program: if a system is too
large to handle, the solution is to buy some more memory.  The system
may contain a mixture of an arbitrary number of molecular species,
each with an arbitrary number of atoms and an arbitrary number of
molecules of each. Molecules or ions may be monatomic or polyatomic,
linear or three dimensional in any combination.  The potential
functions may be of the Lennard-Jones, Buckingham (including
Born-Meyer) or MCY types, and other potential types may be easily
added.  Such flexibility is possible because \moldy\  is written in the
`C' language which permits dynamic memory allocation.

\moldy\  is written to be highly portable and has been tested on a wide
range of computers and operating systems, including VAX/VMS,
MS-DOS and Unix\footnote{Goodness knows who will own the Unix
registered trademark by the time you read this.}  (both BSD and system V
varieties).  It should be straightforward to move it to any other
machine with a good `C' compiler.

To be of real use a simulation  program must run efficiently on modern
high-speed computers, which  are  increasingly of vector   or parallel
architectures.  \moldy\  is written so  as to be highly vectorizable and
has been  tested on a   range of  vector machines  from  manufacturers
including Cray, Convex, Stardent and  Alliant.  On the cray XMP-48 its
performance can exceed 100 MFlop/sec (on a suitably large  system).
\moldy\ is also able to run on a parallel computer of either shared or
distributed memory architectures, and has been tested on
multiprocessors from Stardent, Convex, Cray Research, SGI and IBM SP1
and Cray Research T3D massively parallel machines.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Algorithms and Equations}  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


This chapter  describes the implementation  of the  molecular dynamics
technique as used in \moldy.  It is not intended as an introduction to
MD  simulations, and  does assume some    familiarity  with the  basic
concepts of microscopic models  and simulations thereof.  The book  by
Allen and Tildesley\cite{allen:87}  is a  very good    introductory text,
covering   both the  theory  and  the  practicalities and  is   highly
recommended.  It   also  contains   comprehensive  references  to  the
scientific literature of microscopic computer simulation.

\moldy\  is designed to simulate a common class of models of atomic or
molecular systems. The assumptions are: that the system is an assembly
of  {\em rigid   molecules},  atoms   or  ions;  that  the  forces  of
interaction are derived   from {\em  continuous  potential  functions\/}
acting between (usually atomic) {\em sites\/} on each molecule; that the
dynamics are governed by the {\em classical\/} Newton-Euler equations of
motion.  A major aim of \moldy\ has been to allow the most  general of
models within that class and to impose as few restrictions as possible.
In particular arbitrary mixtures of different molecules are allowed
and several popular forms of potential functions are catered for.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Equations of Motion}  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If we denote the force exerted by atom $\alpha$ of molecule $i$ on
atom $\beta$ of molecule $j$ by $\bm{f}_{i\alpha j\beta}$\footnote{A
comment on notation is appropriate here.  In this chapter, site
quantities are denoted by {\em lowercase\/} letters, molecular
quantities by {\em uppercase}, sites are indexed by {\em greek\/}
letters and molecules by {\em roman}. A missing index denotes a sum
over the corresponding sites or molecules so that, for example
$\bm{r}_{i\alpha j\beta}$ is a site-site vector and $\bm{F}_{ij}$ the
molecule-molecule force}.  then the total force acting on molecule $i$
is
\begin{equation}
\label{eqn:comf}
\bm{F}_i = \sum_j \sum_\beta \sum_\alpha \bm{f}_{i\alpha j\beta}
\end{equation}
and the torque is given by
\begin{equation}
\label{eqn:comt}
\bm{N}_i = \sum_\alpha (\bm{r}_{i \alpha} - \bm{R}_{i}) 
\bm{\times f}_{i\alpha} 
\end{equation}
where $\bm{R}_{i} = 1/M_i \sum_\alpha
m_{i\alpha} \bm{r}_{i\alpha}$ is the centre of mass of molecule $i$.

The motion is governed by the Newton-Euler equations
\begin{equation}
M_i\ddot{\bm{R}_i} = \bm{F}_i \label{eqn:newton}
\end{equation}
\begin{equation}
\bm{I_i \cdot} \dot{\bm{\omega}}_i - \bm{\omega_i \times I_i \cdot
\omega_i} = \bm{N_i} \label{eqn:euler}
\end{equation}
where  $\bm{\omega}_i$ is the angular velocity of the molecule, 
$ \bm{I}_i = \sum_{\alpha} m_{i\alpha} 
( p_{i\alpha}^2 \bm{1} - \bm{p}_{i\alpha}\bm{p}_{i\alpha} ) $ 
is the inertia tensor and 
$\bm{p}_{i\alpha} = \bm{r}_{i\alpha} - \bm{R}_i $
is the atomic site co-ordinate relative to the molecular centre of mass.

% Quaternions
\label{sec:quaternions}
The orientations of the molecules are represented by {\em quaternions\/}
as  has now  become common  practice.   They are  preferred over Euler
angles for two reasons. Firstly they lead to equations of motion which
are  free  of singularities\cite{evans:77} which   means  that   no
special-case  code is required. This  leads to much improved numerical
stability      of  the  simulation\cite{evans:77b}.   Secondly,
molecular symmetry   operations   and  combinations of  rotations  are
elegantly expressed   in    terms  of     a     simple      quaternion
algebra\cite{evans:77b,pawley:85b}.

A quaternion  is an ordered number  quartet  which obeys  the  algebra
given  by   Pawley\cite{pawley:81}.  The multiplication   rule in that
reference may be restated as a matrix product treating each quaternion
as a  4-vector.  If  ${\bf p} \equiv (p_0,p_1,p_2,p_3)$ and  ${\bf q}
\equiv  (q_0,q_1,q_2,q_3)$  are quaternions then
\begin{equation}
{\bf pq} = 
\left(
\begin{array}{rrrr}
p_0 & -p_1 & -p_2 & -p_3 \\
p_1 &  p_0 & -p_3 &  p_2 \\
p_2 &  p_3 &  p_0 & -p_1 \\
p_3 & -p_2 &  p_1 &  p_0 
\end{array}
\right) \left(
\begin{array}{r}
q_0 \\ q_1 \\ q_2 \\ q_3
\end{array}
\right)
\end{equation}
The quaternion $ {\bf \tilde{q}} $ conjugate to ${\bf q}$ is defined
as ${\bf \tilde{q}} = (q_0,-q_1,-q_2,-q_3)$ so that
\begin{equation}
{\bf q\tilde{q}} = (q_0^2+q_1^2+q_2^2+q_3^2,0,0,0).
\label{eqn:qnorm}
\end{equation}
The {\em norm\/} is defined as $ |{\bf q}| \equiv
\sqrt{q_0^2+q_1^2+q_2^2+q_3^2} $ and {\bf q} is called a {\em unit\/}
quaternion if $ |{\bf q}| = 1 $.  

Any possible rotation can be represented by a unit quaternion. Du Val 
shows\cite{duval:64} that if $ {\bf q} \! = \! (\cos \frac{\alpha}{2}, \bm{l} \sin
\frac{\alpha}{2}) $ (where we have combined the last three components to form
a 3-vector) and ${\bf p} = (0,\bm{r})$ then the operation
\begin{equation}
{\bf p'} \equiv (0,\bm{r'}) = {\bf q p \tilde{q}}
\end{equation}
corresponds to a rotation of the vector $\bm{r}$ by an angle of
$\alpha$ about the axis $\bm{l}$.  The components may also be
expressed in terms of the Euler angles as\footnote{The definition of
quaternions used here differs from that used in Evans' paper\cite[equation 21]{evans:77} in the sign of $q_2$ or $\xi$.  This
error has been compounded by subsequent authors\cite{sonnenschein:85,smith:82,laakonsen:85} who also managed to 
permute the components which means that the parameters do not form an
ordered number quartet which obeys quaternion algebra. Like Allen and
Tildesley\cite[page 88]{allen:87} we follow the definition of of
Goldstein\cite[pages 143 and 155]{goldstein:80}.}
\begin{eqnarray}
q_0 & = & \cos \frac{\phi+\psi}{2} \cos \frac{\theta}{2} \nonumber \\
q_1 & = & \sin \frac{\phi-\psi}{2} \sin \frac{\theta}{2} \nonumber \\
q_2 & = & \cos \frac{\phi-\psi}{2} \sin \frac{\theta}{2} \nonumber \\
q_3 & = & \sin \frac{\phi+\psi}{2} \cos \frac{\theta}{2}.
\end{eqnarray}

The relationship between the time derivative of a quaternion and the
principal frame angular velocity was given by Evans\cite[Equation
27]{evans:77} and rewritten using quaternion algebra by 
Refson\cite{refson:87a} as
\begin{equation}
2 {\bf \dot{q}} = {\bf q}(0,\bm{\omega}^p)
\label{eqn:qomega}
\end{equation}
The second derivative is given by
\begin{eqnarray}
\nonumber
2{\bf \ddot{q}} & = & {\bf q}(- 1/2 (\omega^p)^2,\dot{\bm{\omega}^p}) \\
 & = & {\bf q}(-2 |{\bf \dot{q}}|^2,\dot{\bm{\omega}^p})
\label{eqn:qddot}
\end{eqnarray}
Equations~\ref{eqn:qddot} and~\ref{eqn:euler} allow the simulation to
be implemented using quaternions and their derivatives as the dynamic
variables for rotational motion, and this is the method employed in
\moldy.  This second order formulation was first used by Powles {\em et
al}.\cite{powles:79} and Sonnenschein showed\cite{sonnenschein:85}
that it gives substantially better stability than if angular
velocities and accelerations are used as dynamic variables.
 
Using equations~\ref{eqn:qddot} to describe the dynamics means that
they are integrated as if all four components were independent.
Therefore the normalization condition $\bf q \tilde{q} = 1$ may not be
exactly satisfied after performing an integration step.  \moldy\
adopts the usual practice of scaling all components of the quaternion
after each timestep to satisfy the normalization condition\cite{evans:77b}.

It is less widely realized that the second order equations
(\ref{eqn:qddot}) introduce a {\em second} ``unconstrained'' variable
into the procedure.  Differentiating equation~\ref{eqn:qnorm} gives a
constraint on the quaternion derivatives
\begin{equation}
q_0\dot{q_0} + q_1\dot{q_1} + q_2\dot{q_2} + q_3\dot{q_3} = 0
\label{eqn:qconst} 
\end{equation}
which is just the $q_0$ component of equation~\ref{eqn:qomega}.
Just as with the normalization condition, the integration algorithm
will not preserve this condition exactly unless explicit measures are
taken.  After each timestep the constraint may be re-established by
subtracting the discrepancy from the quaternion derivatives.  If
$\delta = q_0\dot{q_0} + q_1\dot{q_1} + q_2\dot{q_2} + q_3\dot{q_3}$
then the corrected quaternion derivatives are given by
\begin{equation}
{\bf \dot{q}^\prime } =  {\bf \dot{q}} - \delta {\bf q}.
\label{eqn:qconcorr}
\end{equation}
Experiments conducted while developing \moldy\ show that enforcing
this constraint significantly decreases the fluctuations in the total
energy. 

Linear molecules are a slightly special case as the moment of inertia
about the molecular axis is zero.  Though there are unique methods to
represent this situation\cite[page 90]{allen:87} \moldy\ uses a minor
modification of the quaternion algorithm.  All that is necessary is a
little special-case code to avoid dividing by the zero component of
inertia in the solution of equation~\ref{eqn:euler} and to hold the
components of angular velocity and acceleration about the molecular
axis to zero.  This has the considerable advantage of uniform
treatment of all kinds of molecules which is convenient when dealing
with heterogeneous mixtures.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Integration Algorithms}   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The dynamical equations~\ref{eqn:newton} and~\ref{eqn:euler} are
integrated using this author's modification\cite{refson:85} of the
Beeman algorithm\cite{beeman:76}.  For atomic systems the accuracy is
of the same order as the commonly used Verlet
algorithm\cite{verlet:67}.  

The accuracy of common integration algorithms was discussed by
Rodger\cite{rodger:89} who showed that the Beeman algorithm is the
most accurate of the supposedly ``Verlet-equivalent'' algorithms. The
Beeman algorithm is the only one accurate to $O(\delta t^4)$ in the
co-ordinates and $O(\delta t^3)$ in the velocities compared to the
Velocity Verlet algorithm which is only $O(\delta t)$ in the
velocities. This is insufficient for an accurate determination of the
kinetic energy, pressure and other dynamic quantities. More seriously,
it fails badly in the case of polyatomic molecules and for
constant-pressure and constant-temperature methods where the
(generalised) velocities enter the dynamical equations themselves.

Velocity-dependent forces occur in equations~\ref{eqn:euler}
and~\ref{eqn:qddot}, in the Parrinello-Rahman constant-pressure
equations (section~\ref{sec:const-stress}) and in the Nos\'e-Hoover
heat bath algorithms (section~\ref{sec:const-temp}). These usually
present a problem to non ``predictor-corrector'' algorithms which are
based on the assumption that the forces depend only on the
co-ordinates.  Fincham has devised a scheme to allow integration of
the rotational equations using Verlet-like
algorithms\cite{fincham:81}, which is widely used despite the
potential problems caused by the low accuracy of the velocities being
propagated into the dynamics.

These cases are easily and accurately handled by the modification to
Beeman's equations proposed by the author\cite{refson:85}.  These may
be summarized using the symbol $x$ to represent any dynamic variable
(centre-of-mass co-ordinate, quaternion or MD cell edge),
$\dot{x}^{(p)}$ and $\dot{x}^{(c)}$ to represent ``predicted'' and
``corrected'' velocities respectively.

\newlength{\myboxw}
\addtolength{\myboxw}{\textwidth}
\addtolength{\myboxw}{-15pt}
\begin{minipage}{\myboxw}
\begin{eqnarray}
& &
\begin{array}{llll}
\makebox[0.5in][l]{\em i} & x(t+\delta t) &=& x(t) + \delta t \, \dot{x}(t) + 
\frac{\delta t^2}{6} 
\left [ 4 \ddot{x}(t) - \ddot{x}(t-\delta t) \right ] \\
\makebox[0.5in][l]{\em ii}  & \dot{x}^{(p)}(t+\delta t) & = & \dot{x}(t) + 
\frac{\delta t}{2} \left [ 3 \ddot{x}(t)- \ddot{x}(t-\delta t) \right ]
\end{array} \nonumber \\
& &
\left .
\begin{array}{llll}
\makebox[0.5in][l]{\em iii}  & \ddot{x}(t+\delta t) & = & F(\{ x_i(t+\delta t),
\dot{x}_i^{(p)}(t+\delta t)\}, i =  1\ldots n) \\
\makebox[0.5in][l]{\em iv} & \dot{x}^{(c)}(t+\delta t) & = & \dot{x}(t) + \frac{\delta t}{6} 
\left [ 2 \ddot{x}(t+\delta t) + 5 \ddot{x}(t)- \ddot{x}(t-\delta t) \right ]\\
\makebox[0.5in][l]{\em v} & 
\lefteqn{\mbox{Replace } \dot{x}^{(p)} \mbox{with }
\dot{x}^{(c)} \mbox{and goto iii.  Iterate to convergence}}
\end{array} 
\right \}
\end{eqnarray}
\end{minipage}
\vspace{10pt}

The predictor-corrector cycle of steps {\em iii\/} to {\em v\/} are
iterated until the predicted and corrected velocities have converged
to a relative precision of better than 1 part in $10^{-7}$, which in
practice takes 2 or 3 cycles.  This iteration is not as inefficient as
it might at first appear as it does {\em not\/} include the expensive
part of the calculation --- the recalculation of the site forces.
Only the angular accelerations and quaternion second derivatives must
be evaluated at each iteration using equations~\ref{eqn:euler} 
and~\ref{eqn:qddot}, and this operation is relatively cheap.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Potentials and Short-Range Forces}%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The forces determining the dynamics of the system are derived from the
potential function denoted by $\phi_{i\alpha j\beta}(\bm{r} _{i\alpha
  j\beta})$.  The indices $i$ and $j$ run over all molecules in the
system and $\alpha$ and $\beta$ over sites on the respective molecule.
The total potential energy of the system is
\begin{equation}
\label{eqn:toten}
U = \sum_i \sum_{j > i} \sum_\alpha \sum_\beta \phi_{i\alpha j\beta}(
\bm{r}_{i\alpha j\beta}).
\end{equation}
where $\bm{f}_{i\alpha j\beta} = - \bm{\nabla} \phi_{i\alpha  j\beta}(
\bm{r}_{i\alpha j\beta})$ is the force acting on site $\beta$ of molecule
$j$ from site $\alpha$ of molecule $i$.

The total force and torque acting on any particular molecule are
calculated using equations~\ref{eqn:comf} and~\ref{eqn:comt}.  Since
$\bm{f}_{i\alpha j\beta}$ and therefore $\bm{F}_{ij}$ are short-ranged
forces (\ie  they decay faster than $r^{-3}$) one can define a {\em
cutoff\/} radius, $r_c$.  Interactions between sites whose separation
$r_{ij}$ is greater than $r_c$ are assumed to be negligible and need
not be evaluated.  In the case of a polyatomic molecular system it is
usual to apply the cutoff according to the {\em intermolecular\/}
separation $R_{ij}$.


\subsection{Pressure and Stress}
The internal stress of a system of interacting molecules is given by
Allen and Tildesley\cite[pp 46-49]{allen:87} in terms of the molecular
virial, but we may rewrite it more conveniently in terms of the atomic
site virial as

\begin{eqnarray}
\label{eqn:stress-sr}
V \bm{\pi}^{sr} & = & \left <  \sum_i M_i \bm{V}_i \bm{V}_i 
              + \sum_i \sum_{j>i} \bm{R}_{ij} \bm{F}_{ij} 
\right > \\ \nonumber
& = & \left < \sum_i M_i \bm{V}_i \bm{V}_i 
              + \sum_{i} \sum_{j>i} \sum_\alpha \sum_\beta 
                \bm{r}_{i\alpha j\beta}  \bm{f}_{i\alpha j\beta} 
              - \sum_i \sum_\alpha \bm{p}_{i\alpha} \bm{f}_{i\alpha}
\right >
\end{eqnarray}
The quantity $\bm{p}_{i\alpha} \equiv \bm{r}_{i\alpha} - \bm{R}_i$ is the
co-ordinate of each site relative to the molecular centre-of-mass.
The pressure is easily evaluated as one third of the trace of the
stress tensor. 

\subsection{Long Range Corrections}
The truncation of the interactions at the cut-off radius does
introduce some errors into the calculated potential energy and stress.
By neglecting density fluctuations on a scale longer than the cutoff
radius we may approximate the errors and calculate correction 
terms\cite[pp 64-65]{allen:87}.

\begin{eqnarray}
U_c & = & \frac{2\pi}{V} \sum_\alpha \sum_\beta N_\alpha N_\beta 
               \int_{r_c}^\infty r^2 \phi_{\alpha\beta}(r) \, dr \\
P_c V & = & \frac{2\pi}{3 V} \sum_\alpha \sum_\beta N_\alpha N_\beta 
               \int_{r_c}^\infty r^3 
               \frac{\mbox{d}\phi_{\alpha\beta}(r)}{\mbox{d}r}
                \, dr \nonumber \\ 
           & = & U_c + \frac{2\pi}{3 V} \sum_\alpha \sum_\beta
           N_\alpha N_\beta r_c^3 \phi_{\alpha\beta}(r_c) \\
\bm{\pi}_c & = & P_c \bm{\delta}
\end{eqnarray}
where the sums run over all the distinct kinds of sites,
$N_\alpha$ is the total number of sites of type $\alpha$ in the system
and $\bm{\delta}$ is the unit matrix.


\subsection{Potential Functions}
% LJ, Buckingham (Born-Meyer) & MCY
\moldy\ supports most common forms of potential function.  In
particular, 
\begin{list}{}{\labelwidth=1in \labelsep=0.25in \leftmargin=1.5in \parsep=0in
\renewcommand{\makelabel}[1]{\em #1 \hfil}}
\item[Lennard-Jones] $\phi(r) = \epsilon((\frac{\sigma}{r})^{12}) -
(\frac{\sigma}{r})^{6})$
\item[6-exp] $\phi(r) = -\frac{A}{r^{6}} +
B\exp(-Cr)$\\
This is the most general 6-exp form and
includes potential of the {\em Born-Meyer\/} and {\em Buckingham\/} forms.
\item[MCY] $\phi(r) = A \exp(-Br) - C \exp(-Dr)$
\item[generic]  $\phi(r) = A \exp(-Br) + C/r^{12} - D/r^4 -E/r^6 -F/r^8$\\
This is a composite which contains terms of almost any
type likely to be encountered, and is really for experimental use.
\end{list}

In addition to the short-range potential electric charges may be
specified for each atomic site which interact according to Coulomb's
Law.  See the following section for details.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Ewald Sum}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:ewald}
The long range Coulomb interactions are handled using the Ewald Sum
technique in three dimensions\cite[p.\ 156]{berthaut:52,allen:87}.
The electrostatic potential of a system of charges is expressed as a
sum of short-range and long-range contributions.  Each term is written
as a series,the first in real space and the second, obtained by
Fourier transformation using the periodicity of the MD cell, in
reciprocal space.  The expression for the Coulomb energy $U$ is
\begin{eqnarray}
\label{eqn:ewald}
U & = &  \underbrace{\frac{1}{4 \pi \epsilon_0}
\sideset{}{^\dag}\sum_{\bm{n}} \sum_{i=1}^{N} \sum_{j=i+1}^{N} q_iq_j
\frac{\erfc( \alpha | \bm{r}_{ij} +  \bm{n} |)}{| \bm{r}_{ij} +
\bm{n} | }}_{\mbox{Real-space term}} 
\nonumber \\
 & + & \underbrace{\frac{1}{2 \epsilon_0 V} \sum_{\bm{k} \ne 0} \frac{1}{k^2}
       e^{-\frac{k^2}{4 \alpha^2}} 
\left \lbrace 
\left | \sum_{i=1}^{N} q_i \cos(\bm{k.r}_i) \right |^2 + 
\left | \sum_{i=1}^{N} q_i \sin(\bm{k.r}_i) \right |^2 
\right \rbrace}_{\mbox{Reciprocal-space term}}\\
 & - & 
\underbrace{\frac{\alpha}{4 \pi^\frac{3}{2} \epsilon_0} 
\sum_{i=1}^{N} q_i^2}_{\mbox{Point self-energy}} 
 - \underbrace{\frac{1}{4 \pi \epsilon_0} \sum_{n=1}^M
\sum_{\kappa=1}^{N_m} \sum_{\lambda=\kappa+1}^{N_m} q_{n\kappa} q_{n\lambda}
\frac{\erf( \alpha | \bm{r}_{\kappa\lambda} |)}{|
\bm{r}_{\kappa\lambda}| }}_{\mbox{Intra-molecular self energy}}
\nonumber \\
& - & \underbrace{ \frac{1}{8 \epsilon_0 V \alpha^2}
                    \left | \sum_{i=1}^N q_i 
                    \right |^2}_{\mbox{charged system term}} +
\; \underbrace{\left [  \frac{1}{6 \epsilon_0 V} 
                    \left | \sum_{i=1}^N q_i \bm{r}_i 
                    \right |^2 \right ]}_{\mbox{surface dipole term}}
\nonumber
\end{eqnarray}
where the ``daggered'' summation indicates omission of site pairs $i,
j$ belonging to the same molecule if $\bm{n}=\bm{0}$.  The meaning of
the symbols is

\begin{tabbing}
\rule{2cm}{0cm} \= \rule{2cm}{0cm} \=\\
\> $\bm{n}$        \> Lattice vector of periodic array of MD cell images. \\
\> $\bm{k}$        \> Reciprocal lattice vector of periodic array of MD cell images.. \\
\> $k$             \> Modulus of $\bm{k}$. \\
\> $i,j$           \> absolute indices of all charged sites. \\
\> $n$             \> index of molecules. \\
\> $\kappa,\lambda$ \> indices of sites within a single molecule. \\
\> $N$             \> Total number of charged sites. \\
\> $M$             \> Total number of molecules. \\
\> $N_m$           \> Number of sites on molecule $m$. \\
\> $\bm{p}_i$      \> Co-ord of site $i$ relative to molecular 
centre-of-mass, $\bm{r}_i - \bm{R}_i$. \\
\> $q_i$           \> Charge on absolute site $i$. \\
\> $q_{m\kappa}$   \> Charge on site $\kappa$ of molecule $m$. \\
\> $\bm{r}_i$      \> Cartesian co-ordinate of site $i$. \\
\> $\bm{r}_{ij}$   \> $\bm{r}_j - \bm{r}_i$. \\
\> $\alpha$        \> Real/reciprocal space partition parameter. \\
\> $\pi_{lm}$      \> Instantaneous stress tensor. \\
\> $\delta_{lm}$   \> Kronecker delta symbol. \\
\> $l, m$          \> $xyz$ tensor indices. \\
\> $V$             \> Volume of MD cell.
\end{tabbing}


and the force on charge $i$ is given by
\begin{eqnarray}
\label{eqn:ewald-force}
\bm{f}_i &=& - \nabla_{\bm{r}_i} U \nonumber \\
& = &  \underbrace{\frac{1}{4 \pi \epsilon_0}
\sideset{}{^\dag}\sum_{\bm{n}} \sum_{j=1 \atop j \neq i}^{N} q_j \left \lbrace 
\frac{\erfc( \alpha | \bm{r}_{ij} +  \bm{n} |)}{| \bm{r}_{ij} +\bm{n} | } +
\frac{2 \alpha}{\sqrt{\pi}}e^{- \alpha^2 | \bm{r}_{ij} +  \bm{n} |^2}
\right \rbrace \frac{\bm{r}_{ij} + \bm{n}}{| \bm{r}_{ij} + \bm{n} |^2}
}_{\mbox{Real-space term}} \nonumber \\
 & + & \underbrace{\frac{1}{\epsilon_0 V} 
\sum_{\bm{k} \ne 0} q_i \frac{\bm{k}}{k^2} e^{-\frac{k^2}{4 \alpha^2}} 
\left \lbrace 
\sin(\bm{k.r}_i) \sum_{j=1}^{N} q_j \cos(\bm{k.r}_j)  + 
\cos(\bm{k.r}_i) \sum_{j=1}^{N} q_j \sin(\bm{k.r}_j) 
\right \rbrace}_{\mbox{Reciprocal-space term}}\\ 
& + & \underbrace{\left [  \frac{q_i}{6 \epsilon_0 V} 
                    \left ( \sum_{j=1}^N q_j \bm{r}_j
                    \right ) \right ]}_{\mbox{surface dipole term}}
\nonumber
\end{eqnarray}

The molecular forces and torques $\bm{F}$ and $\bm{N}$ are evaluated
from the site forces $\bm{f}_i$ using equations~\ref{eqn:comf} 
and~\ref{eqn:comt}.

Notice that the equation~\ref{eqn:ewald} for the energy contains a
correction for the intra-molecular self-energy, whose derivative is
absent from the equation for the forces
(equation~\ref{eqn:ewald-force}).  This term corrects for interactions
between charges on the {\em same\/} molecule which are implicitly
included in the reciprocal space sum, but are not required in the
rigid-molecule model.  Though the site forces $\bm{f}_i$ do therefore
include unwanted terms these sum to zero in the evaluation of the
molecular centre-of-mass forces and torques (equations~\ref{eqn:comf}
and~\ref{eqn:comt}) (by the conservation laws for linear and angular
momentum).

\subsection{Parameter Values}
\label{sec:ewald-auto}

Both the real- and reciprocal-space series (the sums over $\bm{n}$ and
$\bm{k}$) converge fairly rapidly so that only a few terms need be
evaluated.  We define the {\em cut-off\/} distances $r_c$ and $k_c$ so
that only terms with $| \bm{r}_{ij} +\bm{n} | < r_c$ and $|\bm{k}| < k_c$
are included.  The parameter $\alpha$ determines how rapidly the terms
decrease and the values of $r_c$ and $k_c$ needed to achieve a given
accuracy. 

For a fixed $\alpha$ and accuracy the number of terms in the
real-space sum is proportional to the total number of sites, $N$ but
the cost of the reciprocal-space sum increases as $N^2$. An overall
scaling of $N^\frac{3}{2}$ may be achieved if $\alpha$ varies with
$N$. This is discussed in detail in an excellent article by David
Fincham\cite{fincham:93}.  The optimal value of $\alpha$ is
%
\begin{equation}
\alpha = \sqrt{\pi} \left ( \frac{t_R}{t_F} \frac{N}{V^2}\right )
^\frac{1}{6} 
\label{eqn:ewald-alpha}
\end{equation}
%
where $t_R$ and $t_F$ are the execution times needed to evaluate a
single term in the real- and reciprocal-space sums respectively.
If we require that the sums converge to an accuracy of $ \epsilon =
\exp ( -p )$ the cutoffs are then given by

\begin{eqnarray}
r_c  = \frac{\sqrt{p}}{\alpha} \\
k_c = 2 \alpha \sqrt{p}
\label{eqn:ewald-cut}
\end{eqnarray}

A representative value of $t_R/t_F$ specific to \moldy\ has been
established as 5.5.  Though this will vary on different processors
and for different potentials its value is not critical since it
enters the equations as a sixth root.  

It must be emphasised that the $r_c$ is used as a cutoff for the
short-ranged potentials as well as for the electrostatic part.  The
value chosen above {\em does not}\/ take the nature of the
non-electrostatic part of the potential into account.  It is therefore
the responsibility of the user to ensure that $r_c$ is adequate for
this part too.

\subsection{Uniform Sheet Correction}
The 5th term in equation~\ref{eqn:ewald} is necessary only if the system
has a nonzero net electric charge, and is useful in special cases such
as framework systems.  

In a periodic system the electrostatic energy is finite only if the
total electric charge of the MD cell is zero.  The reciprocal space
sum in equation~\ref{eqn:ewald} for $\bm{k}=0$ takes the form
\[\frac{1}{k^2}e^{-\frac{k^2}{4 \alpha^2}} \left | \sum_{i=1}^{N} q_i
 \right |^2\] which is zero in the case of electroneutrality but
infinite otherwise.  Its omission from the sum in
equation~\ref{eqn:ewald} is physically equivalent to adding a uniform
jelly of charge which exactly neutralizes the unbalanced point
charges.  But though the form of the reciprocal space sum is
unaffected by the uniform charge jelly the real-space sum is not.  The
real-space part of the interaction of the jelly with each point charge
as well as the self-energy of the jelly itself must be included giving
the fifth term in equation~\ref{eqn:ewald}.

\subsection{Surface Dipole Term}
The optional final term in equations~\ref{eqn:ewald} 
and~\ref{eqn:ewald-force} if used performs the calculations under
different periodic boundary conditions.  It was suggested by De Leeuw,
Perram and Smith\cite{deleeuw:80} in order to accurately model
dipolar systems and is necessary in any calculation of a dielectric
constant. 

The distinction arises from considerations of how the imaginary set of
infinite replicas is constructed from a single copy of the MD 
box\cite[pp 156-159]{allen:87}.  Consider a near-spherical ``cluster''
of MD cells.  The ``infinite'' result for any property is the limit of
its ``cluster'' value as the size of the cluster tends to infinity.
However this value is non-unique and depends on the dielectric
constant, $\epsilon_s$ of the physical medium surrounding the cluster.
If this medium is conductive ($\epsilon_s=\infty$) the dipole
moment of the cluster is neutralised by image charges, whereas in a
vacuum ($\epsilon_s=1$) it remains.  It is trivial to show that
in that case the dipole moment per unit volume (or per MD cell) does
{\em not\/} decrease with the size of the cluster.

The final term in equation~\ref{eqn:ewald} is just the dipole energy,
and ought to be used in any calculation of the dielectric constant of
a dipolar molecular system.  It is switched on by \moldy's control
parameter \texttt{surface-dipole}.  Note that as it represents the
dipole at the surface of the cluster the system is no longer truly
periodic.

Conversely it {\em must not\/} be used if the simulated system contains
mobile ions.  Consider an ion crossing a periodic boundary and jumping
from one side of the MD cell to another.  In that case the dipole
moment of the MD cell changes discontinuously.   Because of the
surface dipole term the calculation would model a discontinuous
macroscopic change in the dipole moment of the whole system caused by
an infinite number of ions jumping an infinite distance.  This is
manifested in practice by a large and discontinuous change in the
energy of the system and on the force on each charge within it.

This situation is completely non-physical but is easily avoided.
However the problem may also arise more subtly even when there are no
mobile ions if a framework is being simulated
(section~\ref{sec:frameworks}).  The framework is treated as a set of
discrete, but fixed atoms rather than a molecular unit.  If the shape
of the unit cell is allowed to vary then ions constituting the
framework may indeed cross MD cell boundaries causing the
aforementioned problems.

\subsection{Stress}

The internal stress (and pressure) of an atomic system is given by the
volume-derivative of the internal energy.  The situation is slightly
more complicated for rigid molecules since molecules do not scale with
volume and only the inter-molecular distances vary.  The resulting
expression for the coulombic part of the ``instantaneous'' stress
$\pi_{ik}^e$ is\cite[Appendix A]{nose:83}

\begin{eqnarray}
\label{eqn:ewald-stress}
V\pi_{lm}^e & = & \underbrace{\frac{1}{4 \pi \epsilon_0}
\sideset{}{^\dag}\sum_{\bm{n}}\sum_{i=1}^{N} \sum_{j=i+1}^{N} q_iq_j 
\left \lbrace 
\frac{\erfc( \alpha | \bm{r}_{ij} +  \bm{n} |)}{| \bm{r}_{ij} +\bm{n} | } +
\frac{2 \alpha}{\sqrt{\pi}}e^{- \alpha^2 | \bm{r}_{ij} +  \bm{n} |^2}
\right \rbrace \frac{(\bm{r}_{ij} + \bm{n})_l(\bm{r}_{ij} +
\bm{n})_m}{| \bm{r}_{ij} + \bm{n} |^2}}_{\mbox{Real-space term}} \nonumber \\
 & + & \underbrace{\frac{1}{2 \epsilon_0 V} \sum_{\bm{k} \ne 0} \frac{1}{k^2}
       e^{-\frac{k^2}{4 \alpha^2}}
\left ( \delta_{lm}  \!- \! 2 \left [ \frac{1}{k^2} \! + \! \frac{1}{4 \alpha^2}
\right ] \bm{k}_l\bm{k}_m \right )\left \lbrace 
%
\left | \sum_{i=1}^{N} q_i \cos(\bm{k.r}_i) \right |^2 + 
\left | \sum_{i=1}^{N} q_i \sin(\bm{k.r}_i) \right |^2 
\right \rbrace}_{\mbox{Reciprocal-space term}} \nonumber \\
& - & \underbrace{\sum_{i=1}^{N}  \bm{(F_i)}_l \bm{(p_i)}_m}_{\mbox{Molecular
Virial Correction}} 
-  \underbrace{ \frac{\delta_{lm}}{8 \epsilon_0 V \alpha^2}
                    \left | \sum_{i=1}^N q_i 
                    \right |^2}_{\mbox{charged system term}}
\end{eqnarray}

The true internal stress is the ensemble average average, $\pi_{lm} =
\left < \pi_{lm}^e + \pi_{lm}^{s.r.} + \pi_{lm}^K \right >$, where
$\pi_{lm}^{s.r.}$ and $\pi_{lm}^K$ are the short-range force and
kinetic contributions respectively.  $\pi_{lm}^e$ enters into the
Parrinello-Rahman equations of motion (see
section~\ref{sec:const-stress}).

The term marked {\em Molecular Virial Correction\/} in
equation~\ref{eqn:ewald-stress} is the difference between the
site-site virial $\sum_i f_i.r_i$ and the molecular virial $\sum_i
F_i.R_i$ and is subtracted after all of the site forces and the
molecular forces have been calculated including the short-range
potential components which are not included in the equations above.
Though is is not apparent in reference\cite[Appendix A]{nose:83} this
term has exactly the same form for all parts of the stress --- the
short-range potential and the real- and reciprocal space coulombic
parts.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Periodic Boundaries --- the Link Cell Method}%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:link-cell}
The real space part of the Ewald (equation~\ref{eqn:ewald}) and
short-range potential energy is a sum of contributions over pairs of
sites.  In both cases the interaction decays rapidly with separation,
which means that only site pairs closer then some {\em cutoff\/} distance
$r_c$ need be considered.  Several methods are available to enumerate
site pairs and choose those within the cutoff.

Most simple MD codes simply loop over all pairs of particles in the MD
box and compute the separation $r$ for each.  If $r < r_c$ the
interaction is computed.  This method suffers from several
disadvantages.  Since for any given site, the interaction with any
other site is considered only once, only the {\em nearest\/} periodic
image of that site is included (the {\em minimum-image\/} convention).
However this restricts the cutoff radius to less than half the MD cell
dimension $r_c < 2L$.  More serious is the way the computational
time scales with the number of sites.  If there are $N$ sites, there
are $O(N^2)$ separations to compute and the overall time therefore scales
as $O(N^2)$.

The Verlet {\em Neighbour List\/} scheme\cite[pp 146-149]{allen:87} makes
use of the spatial locality of the interaction potential by
maintaining a list for each site of all the ``neighbouring'' sites
({\em i.e}. all those within the cutoff distance).  This can give
considerable gains for moderate numbers of sites, but it ultimately
requires $O(N^2)$ time (to build the lists) as well as $O(N)$ storage for
the lists.

\moldy\ uses an implementation of the Link-Cell method of Quentrec {\em
et al}.\cite{quentrec:75} described in Allen and Tildesley's 
book\cite[pp 149-152]{allen:87} which is a true $O(N)$ algorithm.  
The fundamental idea is that the MD cell is partitioned into a number
of smaller cells, known as {\em subcells}.  Every timestep a linked
list of all the particles contained in each subcell is constructed.
The selection of all pairs of {\em particles\/} within the cutoff is
achieved by looping over all pairs of {\em subcells\/} within the cutoff
and particles within the subcells.  Because of their regular
arrangement, the list of ``neighbouring'' subcells is fixed and may be
precomputed.  Its construction takes only $O(N)$ operations and only
$O(N)$ pair interactions need be calculated.

% Molecular nature of cutoffs.

When the system consists of polyatomic molecules it is important that
all sites belonging to a particular molecule are assigned to the same
cell.  Otherwise it is impossible to calculate the stress and pressure
(equation~\ref{eqn:ewald-stress}) correctly as MD cell vectors are
added to some intra-molecular distances.  Therefore all sites of any
molecule are assigned to a cell if the molecular centre-of-mass lies
inside it.

One drawback of the link-cell method has been the difficulty of
implementing it efficiently for vector processors.  The linked list of
``neighbour'' particles is not stored in the regular-stride array
which is required for vectorization.  Heyes and Smith\cite{heyes:87}
pointed out that {\em gather\/} operations might be used to assemble a
temporary array of neighbour particle co-ordinates from which the
interaction potential and forces could be evaluated in vector mode.  A
{\em scatter\/} operation is then used to add the resulting forces to
the total force array.  This is the technique used in \moldy.  Almost
all modern vector machines have scatter/gather hardware which means
these operations are fairly cheap.

\subsection{No minimum-image convention}
One notable feature of the implementation of the link-cell method in
\moldy\ is that it does {\em not\/} follow the {\em minimum image\/}
convention used in most MD codes.  Instead the list of neighbouring
cells, and hence interactions considered, includes {\em all\/} periodic
images of a particle which are within the cutoff.  This means that it
is quite safe to use a cutoff of more than half of the MD cell side in
any direction.  By default the arrays are sized to allow a cutoff of
up to unity times the MD cell side.  This may be increased by
increasing the constant \texttt{NSH} from 1 in \texttt{force.c}.


% quick 'n dirty vs strict.
\subsection{Cell or Strict cutoff}
There are two options for the way in which site-site interactions are
selected for inclusion in the total energy and forces.  These are
{\em cell-based\/} cutoff and {\em strict\/} cutoff and are selected
by the \texttt{strict-cutoff} control parameter.

In cell-based mode (\texttt{strict-cutoff=0}) the neighbour cell list is
built to include only those cells whose centre is within the cutoff
radius of the centre of the reference cell.  All interactions between
sites belonging to molecules in the neighbouring cell list are
computed.  This is a ``quick and dirty'' method as some interactions
between sites closer than the cutoff will inevitably be excluded
whereas some outside the cutoff range will be included.

In strict mode (\texttt{strict-cutoff=1}) all interactions between pairs
of {\em sites\/} within the cutoff are included.  The neighbouring cell
list contains all pairs of cells with any parts closer than the cutoff
plus twice the greatest molecular radius.  This ensures that all
appropriate interactions are included.  Furthermore, all interactions
between sites further apart than the cutoff are excluded (by the
expedient of setting their separation to a large value in the
potential calculation).  This means that large and asymmetric
molecules are handled correctly.  

For a given cutoff radius the cell-based mode is rather quicker than
the strict mode since the neighbouring cell list is much smaller and
fewer interactions are computed.  However to ensure that significant
interactions are not omitted, the cutoff ought to be set to a
greater value than strictly required.    This tends to offset the
potential speed gain.   On the other hand, if strict isotropy is
required in a liquid simulation for example then the strict cutoff
option ought to be used.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Temperature Initialisation and Control}%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
From the equipartition theorem, each degree of freedom in the
system, $f$ has the same kinetic energy, $\left < {\cal K} \right >_f~=~\frac{1}{2}k_BT$.  The
effective temperature of the system is therefore given by the ensemble
average of its kinetic energy.
\begin{equation}
\label{eqn:equipartition}
T = \left < {\cal T} \right > = \frac{2}{gk_B}
\left < \sum_{f=1}^{g} {\cal K}_f \right > 
= \frac{1}{3Nk_B}\left < \sum_{i=1}^N  m_i \bm{v}_i^2 
+ \bm{\omega_i.I. \omega_i} \right > 
\end{equation}
Here ${\cal K}_f$ is the instantaneous kinetic energy of degree of
freedom $f$, $g$ is the number of degrees of freedom, $N$ is the
number of molecules, $\cal T$ is an instantaneous ``temperature''.

It is almost always desirable that a simulation be conducted so that
the temperature is the supplied parameter rather than the kinetic
energy.  This requires some mechanism to fix the {\em average\/}
kinetic energy at thermal equilibrium.  The {\em initial\/} kinetic
energy may be set approximately by choosing random velocities which
sample the Maxwell-Boltzmann distribution at the desired temperature,
and this is indeed what \moldy\ does on starting a new run (see
section~\ref{sec:velinit}).  But because the initial configuration is
usually far from equilibrium it will have too much potential energy.
As the run progresses this will be converted into kinetic energy,
raising the temperature above the desired value. It is therefore
necessary to have some mechanism for removing excess kinetic energy as
the run progresses.

\moldy\ offers several mechanisms to control the temperature. The
common technique of {\em velocity scaling}\/ is suitable for use
during the equilibration period but does not generate meaningful
particle trajectories. The Nos\'e-Hoover method couples the system to
a heat bath using a fictional dynamical variable and the Gaussian
thermostat replaces the Newton-Euler equations by variants of which
the kinetic energy is a conserved quantity.

\subsection{Rescaling}
\label{sec:rescaling}

At periodic intervals linear and
angular velocities are multiplied by a factor of
\begin{equation}
\label{eqn:scaling}
s = \sqrt{\frac{gk_BT}{2\cal K}}
\end{equation}
where $T$ is the desired temperature.  By repeatedly setting the
``instantaneous'' temperature to the correct value while the system
approaches its equilibrium state, the kinetic energy is made to
approach its desired value.  {\em Scaling\/} may be performed every
timestep, or every few depending on the simulation conditions.

An MD run with scaling does not generate a valid statistical ensemble,
and it must therefore be switched off before any calculation of
thermodynamic averages is performed.

\moldy\ incorporates two refinements to the basic scaling algorithm
(which are selected by the control parameter \texttt{scale-options}).
Linear and angular velocities can be scaled independently, either for
the whole system or for each species individually.  In this way, one
does not rely on the interactions of these degrees of freedom for
convergence to equilibrium.  In many systems these degrees of freedom
are loosely coupled and the exchange of energy between them is slow.
In these cases individual scaling can speed up the approach to
equilibrium considerably.

The other refinement addresses the problem of setting the temperature
accurately.  At equilibrium the system's kinetic energy fluctuates
with mean-square amplitude\footnote{This formula actually applies to
the Canonical rather than the microcanonical ensemble, but it serves
for the purpose of this argument.} $\left < \delta {\cal K}^2\right > =
\frac{1}{2}g\left(k_BT\right)^2$, which corresponds to a
rms fluctuation in the instantaneous ``temperature'' 
$\sqrt{\left < \delta {\cal T}^2\right >} = 
\sqrt{2 /g} T$.   
The difficulty with applying equation~\ref{eqn:scaling}
is the instantaneous kinetic energy $\cal K$ in the denominator.
Strictly, scaling ought to use the {\em average\/} kinetic energy
$\left<\cal K \right>$ as in equation~\ref{eqn:equipartition}, but
this quantity is not known until after the run is completed.  Because
of this equation~\ref{eqn:scaling} can only set the temperature to an
accuracy of $\sqrt{1/g}$.  This is often inadequate for purposes of
comparison with experiment.

In order to allow the temperature to be set with greater accuracy,
\moldy\ allows the use of a partial average in the denominator,
\begin{equation}
\label{eqn:rav-scaling}
s = \sqrt{\frac{gk_BT}{2\left < {\cal  K}\right >^\prime}}
\end{equation}
where $\left < {\cal K}\right >^\prime$ is the ``rolling'' average of
$\cal K$ over some number of preceding timesteps.  That number is
determined by the control parameter \texttt{roll-interval}.   

This option should be used cautiously.  The change in $\left <{\cal
K}\right >$ upon scaling only has a significant effect on the average
after many timesteps. If the subsequent scaling is performed before
this change is reflected in the value of $\left < {\cal K}\right
>^\prime$ it will use an out-of-date value of the average kinetic
energy.  It is therefore recommended that the number of timesteps
between scalings be greater than or equal to the number used to
compute the rolling average.  Otherwise it is possible to produce wild
overshoots and oscillations in the temperature.

Finally, there is a method for tackling really difficult cases when
even individual scaling is unable to keep the temperature under
control.  This might be a far-from-equilibrium configuration where the
potentials are so strong that velocities rapidly become very large,
or when a single molecule acquires a very large velocity.  In that
case the velocities can all be re-initialised randomly from the
Maxwell-Boltzmann distribution periodically.  This provides a kind of
pseudo monte-carlo equilibration for difficult cases.

\subsection{Nos\'e-Hoover Thermostat}
\label{sec:const-temp}
A more sophisticated approach than rescaling is to couple the system
to a heat bath.  Nos\'e\cite{nose:84} proposed an extended-system
Hamiltonian to represent the degrees of freedom of the thermal
reservoir: \moldy\ uses the simpler but equivalent formulation by
Hoover\cite{hoover:85,allen:87}.  The equations of
motion (equations~\ref{eqn:newton} and~\ref{eqn:euler}) are modified thus

\begin{eqnarray}
\label{eqn:nhtherm}
\ddot{\bm{R}_i} = \frac{\bm{F}_i}{M_i} - \zeta \dot{\bm{R}_i}
\nonumber \\
\bm{I_i \cdot} \dot{\bm{\omega}}_i - \bm{\omega_i \times I_i \cdot
\omega_i} = \bm{N_i} - \zeta \bm{I_i \cdot \omega_i} \\
\dot{\zeta} = \frac{g}{Q}\left ( k_B {\cal T} - k_B T \right ) \nonumber 
\end{eqnarray}

\noindent
where most of the symbols have there previous meanings, $g$ is the
number of degrees of freedom in the system. $\zeta$ is a new ``heat
bath'' dynamic variable which is integrated in exactly the same manner
as the co-ordinates and $Q$ is the associated ``inertia'' parameter.
With a suitable choice of $Q$ (see Ref~\cite{nose:84}) these equations
generate trajectories which sample the canonical ensemble.  In other
words both averages and fluctuations calculated as time averages from
a simulation run tend to their canonical ensemble limits.  This does
not necessarily guarantee the correctness of {\em dynamical}\/
quantities.  The coupling to the heat bath introduces non-physical
oscillations of period $t_0 = 2 \pi \sqrt{Q / 2 g k_B T}$ which may be
easily detected in the total energy\cite{nose:91}.  $Q$ should
therefore be chosen to be suitably large in a simulation of dynamic
properties\cite{cho:92}. For example if time correlation functions are
required, $Q$ should be chosen so that $t_0$ is larger than the
characteristic decay time of the correlation function.  There has been
some discussion in the literature of the validity of representing a
heat bath by a single dynamical variable, which the more diligent
reader may wish to explore\cite{cho:93,nose:91}.

\subsection{Gaussian Thermostat}
An alternative approach is known as ``constrained dynamics'' whereby
the equations of motion are modified to generate trajectories which
exactly satisfy ${\cal T} = T$ at all times.  One such is the Gaussian
constraint (see Allen and Tildesley\cite{allen:87} pp 230-231). The
equations of motion are 

\begin{eqnarray}
\label{eqn:gtherm}
\itemsep=0.5em
\ddot{\bm{R}_i} = \frac{\bm{F}_i}{M_i} - \zeta_T \dot{\bm{R}_i} \nonumber \\
\zeta_T = \frac{\sum_j\bm{v}_j . \bm{F_j}}{\sum_j M_j\bm{v}_j^2} \\
\bm{I_i \cdot} \dot{\bm{\omega}}_i - \bm{\omega_i \times I_i \cdot
\omega_i} = \bm{N_i} - \zeta_R \bm{I_i \cdot \omega_i} \nonumber \\
\zeta_R = \frac{\sum_j\bm{\omega}_j . \bm{N_j}}{\sum_j \bm{\omega}_j
  \cdot I_j \cdot \bm{\omega}_j}\nonumber 
\end{eqnarray}

These bear a superficial resemblance to equations~\ref{eqn:nhtherm}
but now $\zeta$ is not itself a dynamical variable but a function of the
other dynamical variables.  Note
that $T$ does not enter explicitly into  equations~\ref{eqn:gtherm}
since ${\cal T}$ is now a conserved quantity equal to its initial
value at all subsequent times. Perhaps surprisingly these equations of
motion generate configurational {\em averages}\/ from the canonical
ensemble, but this does {\em not}\/ hold true for the momenta and
therefore dynamics nor for fluctuations. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Constant Stress}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:const-stress}
It is frequently desirable to conduct simulations under conditions of
constant pressure or stress, rather than constant volume.  For
example, this allows the simulation of a solid-state phase transition
with a change of symmetry or unit cell size.  \moldy\ incorporates the
constant pressure method of Parrinello and Rahman\cite{parrinello:81}.

In a constant-stress simulation the MD cell changes in size and shape
in response to the imbalance between the internal and externally
applied pressure.  For an exposition of the method the reader should
refer to Parrinello and Rahman's paper\cite{parrinello:81} and to
Nos\'{e} and Klein's extension to rigid molecular
systems\cite{nose:83}.  The equation of motion for the reduced
centre-of-mass co-ordinates $\bm{S}_i =
\bm{h}^{-1}\bm{R}_i$ is
\begin{equation}
\label{eqn:par}
M_i\ddot{\bm{S}}_i = \bm{h}^{-1} \bm{F}_i - M_i \bm{G}^{-1}\dot{\bm{G}}\dot{\bm{S}}_i
\end{equation}
replacing the straightforward Newton equation~\ref{eqn:newton}.
$\bm{h}$ denotes the $3 \times 3$ MD cell matrix whose columns are
the MD cell vectors $\bm{a}, \bm{b}$ and $\bm{c}$, $\bm{F}_i$ is the
centre-of-mass force and $\bm{G} =\bm{h^\prime h}$.
Equation~\ref{eqn:euler}, the Euler equation, governs the angular
motion exactly as in the constant-volume case.

The dynamics of the unit cell matrix $\bm{h}$ are governed by the
equation
\begin{equation}
\label{eqn:rahman}
W\ddot{\bm{h}} = \left ( \bm{\pi} - p \right ) \bm{\sigma}
\end{equation}
where $W$ is a fictitious mass parameter, $\bm{\sigma} = V
\bm{h}^{\prime-1}$ and $p$ is the external pressure.  The
instantaneous internal stress $\bm{\pi}$ is given by 
\begin{equation}
\bm{\pi} = \frac{1}{V}\sum_{i=1}^N m_i (\bm{h}_i\dot{\bm{s}}_i)^2 + \bm{\pi}^{s.r.} + \bm{\pi}^e
\end{equation}
with the short-ranged and electrostatic components given by
equations~\ref{eqn:stress-sr} and~\ref{eqn:ewald-stress} respectively.

Nos\'{e} and Klein\cite{nose:83} describe and address the problem of
the whole MD cell rotating during the course of the simulation.
Angular momentum is not conserved in a periodic system, and because
the $\bm{h}$ matrix has 9 degrees of freedom, three more than needed
to specify the position and orientation of the MD cell.  Their
solution is to constrain the $\bm{h}$ matrix to be symmetric, and
involves a modification of the Parrinello-Rahman equations.

\moldy\ incorporates a rather different constraint which is not only
simpler to implement (as it does not require modification of the
equations of motion) but which also has a more obvious physical
interpretation.  The lower three sub-diagonal elements of the $\bm{h}$
matrix are constrained to zero.  In other words the MD cell vector
$\bm{a}$ is constrained to lie along the $x$-axis and $\bm{b}$ is
constrained to lie in the $xy$-plane.  Physically this may be thought
of as implementing an MD box lying on a horizontal surface under the
influence of a weak gravitational field.  The implementation is
trivial; at each timestep the acceleration of those components,
$\ddot{\bm{h}}_{ij}$, is set to zero which is equivalent to adding a
fictitious opposing force.

This constraint technique is not restricted merely to eliminating
redundant degrees of freedom, but can also be used for other purposes.
For example it may be used to allow uniaxial expansion only.  The most
important use of $\bm{h}$ matrix constraints however is probably for
simulations of liquids.  Since a liquid can not support shear stress
there is no restoring force to keep the simulation cell nearly cubic,
and it will therefore drift to a parallelepiped shape.  To counter
this tendency $\bm{h}$ may be constrained so that only the diagonal
elements are non-zero and allowed to change.  This does not give a
completely isotropic MD cell expansion, but the time average should
tend towards a cubic cell.

MD cell constraints are selected using the control parameter
\texttt{strain-mask} (see section~\ref{sec:cp-constraints}).  A value of
238 will freeze the off-diagonal components of $\bm{h}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Radial Distribution Functions}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%`
\label{sec:rdf}
The {\em radial distribution function\/} or RDF is one of the most
important structural quantities characterizing a system, particularly
for liquids.  For a one-component system, the RDF is defined
as\cite[p445]{hansen:86}
\begin{eqnarray}
g(r) & = & \frac{1}{\rho^2} \left < \sum_i \sum_{j\neq i}
\delta(\bm{r} + \bm{r}_i - \bm{r}_j) \right > \\ \nonumber
 &  \approx  & V \left < \delta(\bm{r} + \bm{r}_1 - \bm{r}_2) \right >
\end{eqnarray}
where we use the angle brackets to denote a spherical average as well
as the usual configurational average.  Allen and
Tildesley\cite[pp184,185]{allen:87} describe how to evaluate $g(r)$
from a histogram of pair distances accumulated during a simulation
run. With the notation that $N$ is the total number of particles, $b$
is the number of the histogram bins, $\delta r$ is the bin width (so
that $r = b \delta r$), $n_{his}(b)$ is the accumulated number per
bin, $\tau$ is the number of steps when binning was carried out
\begin{equation}
\label{eqn:rdf-atom}
g(r + \delta r/2) = \frac{3 n_{his}(b)}{4 \pi \rho N \tau [(r + \delta r)^3 - r^3]}
\end{equation}
In the case of a molecular system, the partial RDF for atoms
$\alpha$ and $\beta$ is defined as\cite[p 445]{hansen:86}
\begin{equation}
g_{\alpha \beta}(r) = \frac{1}{\rho^2 V} \left < N(N-1)\delta(\bm{r} + \bm{r}_{1\alpha} - \bm{r}_{2\beta}) \right >
\end{equation}
which may be rewritten more usefully for an arbitrary multi-component
mixture by eliminating the molecular density $\rho$ and number $N$ as
\begin{equation}
g_{\alpha \beta}(r) = V \left < \delta(\bm{r} +  \bm{r}_{1\alpha} - \bm{r}_{2\beta}) \right >
\end{equation}
In the simulation this is evaluated by an expression very similar to
equation~\ref{eqn:rdf-atom}
\begin{equation}
\label{eqn:rdf-site}
g_{\alpha \beta}(r + \delta r/2) = \frac{3 N n_{his}(b)}{4 \pi
\rho N_\alpha N_\beta \tau [(r + \delta r)^3 - r^3]}
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Initial Configuration}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
One of the more trying aspects of initiating a molecular dynamics
simulation is getting it started in the first place.  It is not hard
to see the reason why.  An MD integration algorithm will only generate
a good approximation to the correct equations of motion if the forces
and velocities of the particles are less than some value.  The
timestep is chosen so that this criterion is satisfied for
near-equilibrium configurations.  But if the configuration is far from
equilibrium certain forces may be extremely large (due to atoms
approaching each other too closely).  And worse, the breakdown of the
integrator leads to breakdown of the conservation laws and the
system evolves to a state even further from equilibrium.

One way around this difficulty is to start the system from a
configuration known to be near-equilibrium, such as a known crystal
structure.   For a solid-state simulation this is the method of
choice, and \moldy\ allows any initial structure to be specified and
replicated to fill the MD cell.  In the case of a liquid, a
crystalline initial state is less desirable, and indeed, none may be
known.  Furthermore such a starting configuration restricts the
allowed number of molecules to a multiple of the number in the unit
cell and worse, may force the use of a non-cubic MD cell.

\moldy\ incorporates a novel method of generating an initial
configuration which, in the main, overcomes these problems.
\subsection{The Skew Start Method}
\label{sec:skewstart}
The essence of the {\em Skew Start\/} method is to generate a
configuration which, though not periodic in 3 dimensions, nevertheless
is sufficiently regular to guarantee a minimum separation between
molecular centres of mass.  Figure~\ref{fig:skewstart} demonstrates
the principle in 2 dimensions.

\begin{figure}
\caption{The Skew Start method.  $N$ molecules are placed at evenly-spaced
intervals, $a$ on a line joining a corner of the MD cell to its image $k$
cells away (5 in this illustration).  When mapped back into the
original cell this guarantees a minimum separation of $min(d,a)$.}
\label{fig:skewstart}
\vspace{0.1in}
\setlength{\unitlength}{0.012500in}%
\begin{picture}(493,252)(20,562)
\thicklines
\put(218,754){\circle*{8}}
\put(225,754){\circle*{8}}
\put( 64,722){\circle*{8}}
\put( 71,722){\circle*{8}}
\put(103,730){\circle*{8}}
\put(111,730){\circle*{8}}
\put(257,760){\circle*{8}}
\put(264,760){\circle*{8}}
\put(277,768){\circle*{8}}
\put(277,760){\circle*{8}}
\put(296,768){\circle*{8}}
\put(304,768){\circle*{8}}
\put(319,777){\circle*{8}}
\put(319,769){\circle*{8}}
\put(333,777){\circle*{8}}
\put(340,777){\circle*{8}}
\put(372,785){\circle*{8}}
\put(379,785){\circle*{8}}
\put(411,793){\circle*{8}}
\put(418,793){\circle*{8}}
\put(449,801){\circle*{8}}
\put(456,801){\circle*{8}}
\put( 24,713){\circle*{8}}
\put( 31,713){\circle*{8}}
\put( 47,721){\circle*{8}}
\put( 47,713){\circle*{8}}
\put( 85,728){\circle*{8}}
\put( 85,721){\circle*{8}}
\put(125,737){\circle*{8}}
\put(125,729){\circle*{8}}
\put(141,737){\circle*{8}}
\put(148,737){\circle*{8}}
\put(162,744){\circle*{8}}
\put(162,737){\circle*{8}}
\put(179,745){\circle*{8}}
\put(186,745){\circle*{8}}
\put(199,752){\circle*{8}}
\put(199,745){\circle*{8}}
\put(355,785){\circle*{8}}
\put(355,777){\circle*{8}}
\put(393,792){\circle*{8}}
\put(393,785){\circle*{8}}
\put(432,800){\circle*{8}}
\put(432,793){\circle*{8}}
\put(470,808){\circle*{8}}
\put(470,801){\circle*{8}}
\put(489,808){\circle*{8}}
\put(496,808){\circle*{8}}
\put(218,670){\circle*{8}}
\put(225,670){\circle*{8}}
\put(239,677){\circle*{8}}
\put(239,670){\circle*{8}}
\put(257,677){\circle*{8}}
\put(264,677){\circle*{8}}
\put(277,684){\circle*{8}}
\put(277,677){\circle*{8}}
\put(296,685){\circle*{8}}
\put(304,685){\circle*{8}}
\put(302,670){\circle*{8}}
\put(302,662){\circle*{8}}
\put(280,662){\circle*{8}}
\put(287,662){\circle*{8}}
\put(260,661){\circle*{8}}
\put(260,654){\circle*{8}}
\put(240,654){\circle*{8}}
\put(247,654){\circle*{8}}
\put(222,616){\circle*{8}}
\put(222,608){\circle*{8}}
\put(240,616){\circle*{8}}
\put(247,616){\circle*{8}}
\put(260,623){\circle*{8}}
\put(260,616){\circle*{8}}
\put(280,624){\circle*{8}}
\put(287,624){\circle*{8}}
\put(302,632){\circle*{8}}
\put(302,624){\circle*{8}}
\put(239,599){\circle*{8}}
\put(239,592){\circle*{8}}
\put(257,599){\circle*{8}}
\put(264,599){\circle*{8}}
\put(277,607){\circle*{8}}
\put(277,599){\circle*{8}}
\put(296,607){\circle*{8}}
\put(304,607){\circle*{8}}
\put(218,592){\circle*{8}}
\put(225,592){\circle*{8}}
\put(222,654){\circle*{8}}
\put(222,646){\circle*{8}}
\put(218,631){\circle*{8}}
\put(225,631){\circle*{8}}
\put(239,638){\circle*{8}}
\put(239,631){\circle*{8}}
\put(257,638){\circle*{8}}
\put(264,638){\circle*{8}}
\put(296,646){\circle*{8}}
\put(304,646){\circle*{8}}
\put(277,645){\circle*{8}}
\put(277,638){\circle*{8}}
\put(239,760){\circle*{8}}
\put(239,753){\circle*{8}}
\put(125,814){\line( 0,-1){101}}
\put(222,814){\line( 0,-1){101}}
\put(319,814){\line( 0,-1){101}}
\put(416,814){\line( 0,-1){101}}
\put(222,612){\makebox(0.4444,0.6667){.}}
\multiput(222,592)(4.41434,0.88287){23}{\makebox(0.4444,0.6667){.}}
\multiput(222,612)(4.40560,0.88112){23}{\makebox(0.4444,0.6667){.}}
\multiput(222,631)(4.40560,0.88112){23}{\makebox(0.4444,0.6667){.}}
\put(319,670){\line( 5, 1){33.077}}
\put(319,650){\line( 5, 1){37.115}}
\put(239,596){\line( 1,-6){5.649}}
\multiput(222,650)(4.41434,0.88287){23}{\makebox(0.4444,0.6667){.}}
\put( 28,713){\framebox(485,100){}}
\multiput( 28,713)(4.41608,0.91){111}{\makebox(0.4444,0.6667){.}}
\put(261,601){\line( 1,-6){5.649}}
\multiput(270,574)(-0.50000,0.30000){11}{\makebox(0.4444,0.6667){.}}
\multiput(265,577)(0.25000,0.50000){13}{\makebox(0.4444,0.6667){.}}
\multiput(236,577)(0.50000,-0.33333){13}{\makebox(0.4444,0.6667){.}}
\multiput(242,573)(-0.29622,-0.49370){15}{\makebox(0.4444,0.6667){.}}
\multiput(339,680)(-0.33333,-0.50000){13}{\makebox(0.4444,0.6667){.}}
\multiput(335,674)(-0.50000,0.30000){11}{\makebox(0.4444,0.6667){.}}
\multiput(334,648)(0.33333,0.50000){13}{\makebox(0.4444,0.6667){.}}
\multiput(338,654)(0.50000,-0.33333){13}{\makebox(0.4444,0.6667){.}}
\multiput(222,670)(4.40560,0.88112){23}{\makebox(0.4444,0.6667){.}}
\put(319,592){\line( 0, 1){97}}
\put(319,689){\line(-1, 0){97}}
\put(222,689){\line( 0,-1){97}}
\put(222,592){\line( 1, 0){97}}
\put(334,661){\makebox(0,0)[lb]{\smash{\it d}}}
\put(250,573){\makebox(0,0)[lb]{\smash{\it a}}}
\end{picture}
\end{figure}

The $N$ molecules are placed at some suitable interval $a$ on a line
drawn between one corner of the MD cell (of side $L$) and one of its
periodic images.  Clearly the index $(h,k)$ of the image cell corner
should be chosen so that the molecule spacing, $a$ is close to the
spacing of the line's images, $d$. For simplicity, choose $k=1$ which
leads to the condition:
\begin{eqnarray}
\nonumber
 &a = \frac{L \sqrt{h^2+1}}{N} \approx \frac{L}{\sqrt{h^2+1}} = d \\
& \Rightarrow h \approx \sqrt{N-1}
\end{eqnarray}
Therefore the optimum value of $h$ is the nearest integer to
$\sqrt{N-1}$.  

The formalism may be extended to three dimension, and yields the
results for the molecular and ``inter-line'' spacings $a$, $d_y$ and
$d_z$ respectively
\begin{eqnarray}
\label{eqn:skew-hkl}
\nonumber
a & = & \frac{L}{N}\sqrt{h^2+k^2+l^2}\\
d_y  & = & L \frac{\sqrt{k^2+l^2}}{\sqrt{h^2+k^2+l^2}} \\
d_z & \approx & L\frac{l}{k} \qquad\mbox{(assuming $h/k$ is an integer)}
\nonumber
\end{eqnarray}
The ``equal spacing'' requirements are satisfied approximately by
\begin{eqnarray}
  \nonumber
  h & \approx & N^{2/3} \\
  k & \approx & N^{1/3} \\
  \nonumber
  l & = & 1
\end{eqnarray}
which when substituted into equation~\ref{eqn:skew-hkl} yields
\begin{equation}
  a \approx d_y \approx d_z \approx LN^{-1/3}
\end{equation}

Using this method an arbitrary number of molecules may be packed into
a cubic cell with a guaranteed minimum centre-of-mass separation of
approximately $LN^{-1/3}$.  In contrast to other methods, such as
random placement with excluded volume, it will always yield a
configuration no matter how high the density.  It is also very simple
to implement.

It still remains to determine the initial orientations of the
molecules in the case of polyatomics.  In the current implementation
these are assigned randomly, which works well for small or
near-spherical molecules.  Further refinements which may help avoid
overlaps for elongated molecules are possible, such as a periodic
sequence of orientations along the line, but no investigation of this
possibility have yet been carried out.

In practice the method has proved to work well for water and aqueous
systems and always yields a configuration which may be evolved towards
equilibrium by the MD equations of motion.  Any feedback on its
performance in more difficult cases will be welcome.

\subsection{Initial Velocities}
\label{sec:velinit}
It remains to choose the initial velocities of the molecules to
complete the specification of the initial configuration.  The recipe
is the same irrespective of whether the molecules are started on a
lattice or from a skew start.  The initial centre-of-mass velocities
are chosen from the Maxwell-Boltzmann distribution at the temperature
specified for the simulation\cite[pp 170]{allen:87}.  That is, the
velocities are chosen from a set of random numbers with a Gaussian
distribution and normalized so that the probability density $p(v)$ of
the $xyz$ component of the velocity $v_{ik}$ of molecule $k$ is
\begin{equation}
p(v_{ik}) = \left ( \frac{m_k}{2 \pi k_B T}\right )^{1/2} 
\exp(-\frac{m_k v_{ik}^2}{2 k_B T})
\end{equation}
This is easily accomplished given a random number generator which
samples from a Gaussian distribution with unit variance.  Given a
random number $R_{ik}$, each component of velocity is set to
\begin{equation}
v_{ik} = \sqrt{\frac{k_B T}{m_k}} R_{ik}
\end{equation}
Each component of the angular velocity (expressed in the
principal frame) has a probability distribution
\begin{equation}
p(\omega^p_{ik}) = \left ( \frac{I_{ik}}{2 \pi k_B T}\right )^{1/2}
\exp(-\frac{I_{ik} (\omega^p_{ik})^2}{2 k_B T})
\end{equation}
which is ensured by assigning a random velocity
\begin{equation}
\label{eqn:omega-rand}
\omega^p_{ik} = \sqrt{\frac{k_B T}{I_{ik}}} R_{ik}
\end{equation}

Since the dynamical variables used by \moldy\ for the angular
co-ordinates are in fact the quaternions and their derivatives, we
must set the quaternion derivatives and accelerations to the corresponding
values. Using equations~\ref{eqn:qomega} and~\ref{eqn:qddot} we
have
\begin{equation}
{\bf \dot{q}} = {\bf q}(0,\bm{\omega}^p/2)
\end{equation}
and
\begin{equation}
{\bf \ddot{q}} = -\frac{1}{4}(\omega^p)^2 {\bf q}
\end{equation}

Finally, we note that if a molecule has less than three degrees of
freedom, that is $I_{ik}=0$ for some $i$ the corresponding angular
velocities \etc\ are simply set to zero.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Frameworks}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:frameworks}
In addition to the bulk properties of solids and liquids, much
attention has been devoted in recent years to using MD simulation to
model atoms or molecules interacting with surfaces or other structures
such as zeolites.  The distinctive feature of such a situation is the
2- or 3-dimensional surface or structure is larger than the
interacting molecules by many orders of magnitude.  In fact the
idealisation of this system makes the structure infinite in extent.
An atomistic model of this kind of a system necessitates choosing the
periodic boundary conditions of the MD cell to be commensurate with
the periodicity of the surface or structure.  This manual will refer
to an infinitely repeating crystalline surface or structure as a {\em
framework}.

There are two possible formulations of a system of this kind for use
in a MD simulation.  Firstly the framework may be modelled as a set of
independent atoms interacting via pair potentials.  This merely
requires specifying the correct initial structure and MD cell plus a
suitable set of pair potentials. The latter model both the internal
forces which determine the crystal structure of the framework and its
interaction with the atoms or molecules of the fluid.  Conceptually
there is no distinction between this situation and a regular solid or
liquid system, and the mechanics of initiating a simulation are
handled in exactly the usual manner.

However there are situations in which this ``atomic'' approach is
impractical.  Because the system being modelled is essentially
``two-phase'' the atoms of the framework find themselves under the
influences of two distinct kinds of force.  There are the strong
forces, usually covalent or ionic, which bind the atoms to form the
framework itself and the weaker, non-bonded forces of the interaction
with the fluid.  Ideally these could all be modelled by a single
consistent set of interatomic potentials which are sufficiently
transferable to yield an accurate crystal structure for the framework
as well as the molecular structure of the fluid and its interaction
with the surface.  Regrettably such potentials are hard to find.

Furthermore the characteristic vibrational frequencies of the solid
framework will probably be much higher than those of the fluid.
Consequently the timestep must be chosen sufficiently small to
accurately model the crystalline vibrations.  This will usually be far
smaller than the value required for the fluid, necessitating very
lengthy MD runs to model both regimes properly.  This is of course
exactly the argument used to justify rigid-molecule models. 

\moldy\ implements a variation on the rigid-molecule model to simulate
rigid a framework structure periodically extended throughout space.
There are a few subtleties which must be correctly handled to achieve
a consistent implementation, which are described hereafter.  

\subsection{Implementation}
The framework is in many respects exactly like an ordinary molecule.
It should be defined to exactly fill the MD cell so that the
periodic repeat of the cell generates the periodicity of its
crystal structure.  The distinctive features of a framework molecule are:
\begin{itemize}
\item The framework is fixed in space and is not allowed to rotate. 
Any rotation would of course destroy the 3D structure.  For most
purposes it is convenient to regard the framework as being at rest, hence
translational motion is forbidden also.
\item No interactions between sites on a framework molecule and on itself
or any of its periodic images are evaluated.  That is,
framework-framework interactions, both potentials and forces, are
systematically excluded from the real-space and reciprocal-space parts
of the ewald sum, including the point and intra-molecular self terms
of equation~\ref{eqn:ewald}. (The exact modifications to
equations~\ref{eqn:ewald},\ref{eqn:ewald-force} \etc\ are left as an
exercise for the reader.)
\item In the real-space force calculation, sites are treated as being
independent atoms rather than belonging to a molecule.  In particular
the cutoff is applied on the basis of the (framework) site to (fluid)
molecule distance.  By virtue of the ``all-image'' convention, all the
requisite molecule-framework interactions are correctly
included.  When assigning sites to sub-cells, each site is therefore
placed in the sub-cell which contains its co-ordinate.  (By contrast
sites belonging to an ordinary molecule are placed in the cell which
contains the molecular centre of mass.)
\end{itemize}

With these modifications, \moldy\ is able to successfully model a fluid
in contact with a 3D rigid framework. 2-dimensional systems such as a
fluid at a surface or between two surfaces may be represented as a 3D
system by adding an artificial periodicity in the third dimension. To
reduce the errors so introduced, the framework can be made ``large
with space inside'' to fill a MD cell with a large $c$-axis.  

In the case of a 3D framework it is clearly not sensible to allow the
MD cell to change shape or size, since this would destroy the internal
structure of the framework.  However if the framework represents a 2D
layer or surface, then the layer spacing may be allowed to vary using
the constant-stress equations (section~\ref{sec:const-stress}) and
applying constraints to allow only the $c$-axis to fluctuate.  In that
case, bear in mind that the dynamics are governed by the
Parrinello-Rahman equations of motion for the cell, rather than the
Newtonian equations for the layer.  In particular the mass is given by
the parameter $W$ rather than the mass of the framework molecule.
(These may, of course be set equal if required.)  Note also that no
layer-layer interactions are calculated, and any force is the result
of the externally applied pressure\footnote{This is a restriction of
the current implementation and may be lifted in future versions.}.

Finally there are two subtle complications which arise from the
framework concept.

\subsection{Stress and Pressure Undefined}
There is no unique definition of the internal stress or pressure of a
framework system.    The pressure of a system in a space with periodic
boundary conditions  is defined in terms of the molecular virial
\begin{equation}
\label{eqn:virial}
{\cal W} = \frac{1}{3} \sum_{i=1}^N \sum_{j \neq i}^N \bm{R}_{ij}.\bm{F}_{ij}
\end{equation}
But the framework has no centre-of-mass, and so the quantity
$\bm{R}_{ij}$ can not be defined.  The site-virial formulation of
equation~\ref{eqn:stress-sr} is of no assistance as the definition of the
``internal'' co-ordinate $\bm{p}_{i\alpha}$ involves the centre of
mass co-ordinate $\bm{R}_i$.  Neither can one simply choose a
convenient reference $\bm{R}_i$.  Since the force exerted by the fluid
acting on the framework is in general non-zero, the term
\begin{equation}
\sum_i \sum_\alpha \bm{p}_{i\alpha} \bm{f}_{i\alpha}
= \sum_i \sum_\alpha \bm{r}_{i\alpha} \bm{f}_{i\alpha}
- \sum_i \bm{R}_i \bm{F}_i
\end{equation}
clearly depends on $\bm{R}_i$.  The situation may also be viewed
physically.  The definition of pressure of a system is the derivative
of the free energy with respect to volume.  But with an infinite rigid
framework the volume derivative can not be defined.

The useful quantity in this case is the partial pressure of the
fluid.  Though not currently implemented, this may be rectified in a
future version of \moldy.

Finally we note that in the case of a 2D layer structure, which is
{\em not\/} rigid in the third dimension the perpendicular component if
the stress tensor {\em does\/} have a physical meaning and is correctly
calculated. 
 
\subsection{Charged Frameworks}
A minor complication arises when using a framework which is has a
non-zero net electric charge.  Although the system as a whole may be
electrically neutral, the omission of  framework-framework
interactions from the calculation also means that the
$\bm{k}=0$ term does not vanish.  To see this examine
equation~\ref{eqn:ewald}.  In the non-framework case the indices $i$
and $j$ in the terms
\begin{displaymath}
\left | \sum_{i=1}^{N} q_i \cos(\bm{k.r}_i) \right |^2 
=
\sum_{i=1}^{N} \sum_{j=1}^{N} q_i q_j \cos(\bm{k.r}_i)\cos(\bm{k.r}_j)
\end{displaymath}
run over all site pairs.  If $\bm{k}=0$
the squared sum is 
\begin{displaymath}
\left | \sum_{i=1}^{N} q_i \right |^2 = 0
\end{displaymath}
If a framework is present the formulation becomes
\begin{displaymath}
\left | \sum_{i=1}^{N} q_i \cos(\bm{k.r}_i) \right |^2 
-
\left | \sum_{i=M\!+\!1}^{N} q_i \cos(\bm{k.r}_i) \right |^2 
\end{displaymath}
assuming sites $M+1 \ldots N$ are the framework sites.  On setting
$\bm{k}=0$ this reduces to
\begin{displaymath}
\left | \sum_{i=1}^N q_i \right |^2 - \left | \sum_{i=M\!+\!1}^N q_i \right |^2
\end{displaymath}
It is therefore necessary to modify the charged-system term of
equation~\ref{eqn:ewald} to
\begin{equation}
U_z = - \frac{1}{8 \epsilon_0 V \alpha^2}
\left \lbrace
\left | \sum_{i=1}^N q_i \right |^2 - \left | \sum_{i=M\!+\!1}^N q_i \right |^2
\right \rbrace
\end{equation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Running Moldy}  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The way \moldy\ is invoked depends to some extent on the operating
system, but usually by issuing the command \texttt{moldy}\footnote{On
VMS, {\tt moldy} may be defined as a foreign command by {\tt \$ moldy
:== \$mydisk:[mydir]moldy}} For Unix(tm) and MS-DOS the executable file
{\tt moldy} or {\tt MOLDY.EXE} should be placed in the shell search
path (\eg in the current directory). There
are two optional arguments - the name of the control file (see
section~\ref{sec:control}) and the output file (see
section~\ref{sec:output}).  If either is omitted, control input is
read from the ``standard input'' which may be a terminal or a job
command file depending on the operating system and circumstances, and
the output is written to ``standard output'' which may be a terminal
or batch job logfile\footnote{Some operating systems (Unix and MS-DOS)
allow {\em file redirection\/} whereby the standard input is
associated with some file.  This may also be used to supply the
control file, provided that no command line parameter is given.}.
Here are examples for VAX/VMS and Unix (tm), which assume that in 
each case the command has been set up to invoke \moldy. 
Under VMS the commands
\begin{verbatim}
        $ moldy control.dat output.lis
        $ moldy control.dat
\end{verbatim}
will start \moldy\  which will read its input from \texttt{control.dat}.
The output will be directed to the file \texttt{output.lis} in the first
case and written to the terminal or batch log in the second.  Under
UNIX any of
\begin{verbatim}
        % moldy < control > output.lis
        % moldy control output.lis
        % moldy control
\end{verbatim}
will cause moldy to read from the file called \texttt{control} and in
the first two examples to write its output to \texttt{output.lis}.  The
command-line interface for MS-DOS is very similar. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Control File}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:control}

The information needed to initiate and control a run of \moldy\  is
specified in a file known as the {\em control file}. This contains the
parameters governing the run \eg the number of timesteps to be
executed or the frequency of output, and the names of files to be used
\eg for reading a restart configuration from or for writing the
output to. Parameters in the control file are specified by entries of the form
\texttt{keyword = value}
which appear one to a line, terminated by the special keyword
\texttt{end}.  Spaces and blank lines are ignored as are comments ({\em
i.e}. the remainder of a line following a \texttt{\#}~symbol) and
keywords may be entered in upper or lower case. For example
\begin{verbatim}
   title= Moldy example      # This is a comment

   # The above blank line is ignored
   nsteps = 1000
   step=0.0005
   restart-file = RESTART.DAT
   end                       # The control file ends here
\end{verbatim}
sets the title of the simulation to ``Moldy example'', the number of
steps to execute to 1000, the timestep to 0.0005ps and supplies the
name of a restart file to read from.

It is not necessary to specify all of the parameters on each run.
Unless it is explicitly assigned a value in the control file, each
parameter has a default value.  This is either the value listed in
table~\ref{tab:parameters} or, in the case where the simulation is
continuing from a restart file, the value it had on the previous run
(see section~\ref{sec:restarting}). Parameters are read in sequence
from the control file anf one appears more than once only the final
instance is used.

The two most important parameters are \texttt{step} which sets the size
of the simulation timestep (in ps), and \texttt{nsteps} which specifies
the number of steps to perform.  Together these control the length of
time to be simulated.  It is also possible to specify that a run
should be terminated after a certain amount of computer time has been
used - given by parameter \texttt{cpu-limit}.  This will be particularly
useful in batch mode systems, where the run is killed after some
specified CPU time has elapsed.  Setting \texttt{cpu-limit} to the
maximum time allowed will cause \moldy\  to terminate the run {\em
before\/} the limit is reached and write out a backup file (see
section~\ref{sec:backup}).

There are several kinds of parameters:
\begin{description}

\item[character strings] Apart from \texttt{title} these are just file
names \eg \texttt{sys-spec-file}.  No checks
are performed on the validity of the name (because \moldy\  has to work
on many different computer systems), so if you make a mistake you are
likely to get an error message to the effect that \moldy\  couldn't find
the file you asked for.  To remove a default value, just specify a
null string {\em e.g}. \texttt{save-file = }.

\item[booleans] These are just switches which turn a feature off or
on. `0' means off or false and `1' means on or true. The parameters
\texttt{text-mode-save}, \texttt{new-sys-spec}, 
\texttt{surface-dipole} and \texttt{lattice-start} are booleans.

\item[real parameters] Several parameters are real numbers \eg
\texttt{step} which specifies the timestep.  They may be entered in the
usual floating point or scientific notation \eg \mbox{\texttt{step = 0.0005}}
or \mbox{\texttt{step = .5e-3}}, and are taken to be in the units given in
table~\ref{tab:parameters}.

\item[integer parameters] Parameters such as \texttt{dump-level} take a
numeric value, which should be an integer.

\item[timestep-related parameters] Several parameters govern when some
calculation begins and ends and how frequently it is performed in
between. These are known as ``begin'', ``end'' and ``interval''
parameters, but are really a special case of integer parameters.  For
example \texttt{begin-average}, \texttt{dump-interval} and
\texttt{scale-end}.  The calculation begins {\em on\/} the timestep
specified on the \texttt{begin} parameter, occurs every \texttt{interval}
timesteps thereafter and ends {\em after\/} the timestep specified by
the \texttt{end} parameter.  Setting the \texttt{interval} parameter to
zero is the usual method of turning that calculation off.

The \texttt{begin} and \texttt{end} parameters behave in a special fashion
when the simulation is continued from a restart file; they are
interpreted {\em relative\/} to the current timestep.  Notice especially
that \texttt{nsteps}, the number of timesteps is treated in this way.

\end{description}

A complete list of the parameters,
their meanings and default values appears in
table~\ref{tab:parameters}. 

\begin{table}
\begin{minipage}{\textwidth}
\caption{Control Parameters}
\label{tab:parameters}
\setlength{\rightskip}{0pt plus 2cm}
\begin{tabular}{|l|l|l|p{2.9in}|}
\hline
{\bf name} & {\bf type}\footnote{See section~\ref{sec:control}} &
{\bf default} & {\bf function} \\ \hline \hline
\texttt{title} &                  character  & {\small Test Simulation} &
A title to be printed on all output. \\
\texttt{nsteps} &                 integer &                       0 &
Number of MD steps to execute. \\
\texttt{cpu-limit} &              real &                  1e20 &
Terminate run if excessive CPU time used. \\
\texttt{step} &                   real &                  0.005 &
Size of timestep \\ \hline
\texttt{sys-spec-file} &          character  &    null &
Name of system specification file.  Appended to control file if null. \\
\texttt{lattice-start} &          boolean &               false  &
Switch for crystalline initial configuration. \\
\texttt{save-file} &              character  &    null &
File to save restart configuration in. \\
\texttt{restart-file} &           character  &    null &
File to read restart configuration from. \\
\texttt{new-sys-spec} &           boolean &               false  &
Read restart configuration with changed system specification. \\
\texttt{text-mode-save} &         boolean &               false &
Write a portable ``restart'' file consisting of control, system
specification and lattice start files. \\ \hline
\texttt{density} &                real &                  1.0 &
Initial density in g\,cm$^{-3}$.  Used by {\em skew start\/} only to
determine initial MD cell dimensions. \\ \hline
\texttt{scale-interval} &         integer &               10 &
Number of steps between velocity scalings. \\
\texttt{scale-end} &              integer &               1000000 &
When to stop scaling. \\
\texttt{const-temp} &             integer &               0 &
1 for Nos\'e-Hoover, 2 for Gaussian thermostat. \\
\texttt{rtmass} &                 real &                  100 &
Translational inertia parameter for Nos\'e-Hoover thermostat 
(kJ\,mol$^{-1}$\,ps$^2$).\\
\texttt{rtmass} &                 real &                  100 &
Rotational inertia parameter for Nos\'e-Hoover thermostat 
(kJ\,mol$^{-1}$\,ps$^2$).\\
\texttt{scale-options} &           integer &              0  &
Select variations on scaling or thermostat. \\
\texttt{temperature} &            real &                  0 &
Temperature of initial configuration for scaling and thermostat (K). \\ \hline
\texttt{const-pressure} &         boolean &               false  &
Whether to use Parrinello and Rahman constant stress. \\
\texttt{w} &                      real &                  100.0 &
Value of P \& R mass parameter (amu). \\
\texttt{pressure} &               real &                  0 &
External applied pressure (MPa). \\
\texttt{strain-mask} &            integer &               200 &
bitmask controlling $\bm{h}$ matrix constraint. \\ \hline
\texttt{alpha} &                  real &                  {\em auto} &
$\alpha$ parameter for Ewald sum. \\
\texttt{k-cutoff} &               real &                  {\em auto} &
Reciprocal space cut off distance in \AA$^{-1}$. \\
\texttt{cutoff} &                 real &                  {\em auto} &
Direct space cutoff distance in \AA. \\
\texttt{strict-cutoff} &          boolean &               false &
Flag to select rigorous or cheap but approximate cutoff algorithm. \\
\texttt{surface-dipole} & boolean &               false  &
Include De Leeuw \& Perram term in Ewald sum. \\ \hline
\texttt{roll-interval} &          integer &               10 &
Period over which to calculate rolling averages. \\
\texttt{print-interval} &         integer &               10 &
How frequently to print normal output. \\ \hline
\end{tabular}
\end{minipage}
\end{table}
\begin{table}
\begin{minipage}{\textwidth}
\caption{Control Parameters (continued)}
\setlength{\rightskip}{0pt plus 2cm}
\begin{tabular}{|l|l|l|p{2.9in}|}
\hline
{\bf name} & {\bf type}\footnote{See section~\ref{sec:control}} &
{\bf default} & {\bf function} \\ \hline \hline
\texttt{begin-average} &          integer &               1001 &
When to start accumulating the thermodynamic averages. \\
\texttt{average-interval} &       integer &               5000 &
How frequently to calculate and print averages. \\
\texttt{reset-averages} &         boolean &               false  &
Discard accumulated averages in restart file. \\ \hline
\texttt{begin-rdf} &              integer &               1000000 &
When to start accumulating radial distribution function information. \\
\texttt{rdf-interval} &           integer &               20 &
How frequently binning calculation is performed. \\
\texttt{rdf-out} &                integer &               5000 &
How frequently to calculate and print RDFs. \\
\texttt{rdf-limit} &              real &                  10 &
Calculate RDFs up to what distance? (\AA) \\
\texttt{nbins} &                  integer &               100 &
Number of binning intervals between 0 and rdf-limit. \\ \hline
\texttt{xdr} &                    boolean &               false &
Write restart,  backup and dump files in portable
binary format using Sun XDR. \\ \hline
\texttt{dump-file} &              character  &    null &
Template of file names used for data dumps. \\
\texttt{begin-dump} &             integer &               1 &
Timestep to begin dumping at. \\
\texttt{dump-interval} &          integer &               20 &
How frequently to perform dumps. \\
\texttt{dump-level} &             integer &               0 &
Amount of information to include in dump. \\
\texttt{ndumps} &         integer &               250 &
Number of dump records in each dump file. \\ \hline
\texttt{backup-interval} &        integer &               500 &
Frequency to write backup file. \\
\texttt{backup-file} &            character  &    MDBACKUP &
Name of backup file. \\ \hline
\texttt{temp-file} &              character  &    MDTEMPX &
Name of temporary file used for writing restart configurations. \\ \hline
\texttt{subcell} &                real &                  0 &
Size of sub cell (in \AA) to divide MD cell into for link-cell force
calculation. \\ \hline
\texttt{seed} &                   integer &               1234567 &
Seed for random number generator. \\ \hline
\texttt{page-width} &             integer &               132 & 
Number of columns on output paper. \\
\texttt{page-length} &    integer &               44 &
Number of lines on a page of output. \\ \hline
\texttt{mass-unit} &              real &                  1.6605402e-27 &
Unit of mass for system specification file. \\
\texttt{length-unit} &            real &                  1e-10 &
Unit of length for system specification file. \\
\texttt{time-unit} &              real &                  1e-13 &
Unit of time for system specification file. \\
\texttt{charge-unit} &            real &                  1.60217733e-19 &
Unit of charge for system specification file. \\ \hline
\end{tabular}
\end{minipage}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Setting up the System}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{System Specification}
\label{sec:sys-spec}

The information which describes to \moldy\  the system to be simulated
and the interaction potentials is contained in a file known as the
{\em system specification file}.  This may be presented to \moldy\  in
either of two ways: If the control file parameter \texttt{sys-spec-file}
is null or absent, it is assumed to be appended to the end of the
control file.  Otherwise it is read from the file whose name is
the value of \texttt{sys-spec-file}.

This file is divided into two sections.  First is the description of
the molecules, atoms or ions, which is followed by the potential
functions.  As for the control file, the input is case independent and
free format, but line structured. Blank lines, spacing and comments
are ignored.

The physical description consists of a series of entries, one for each
molecular species, terminated by the keyword \texttt{end}. The entry
for species $i$ should have the form
\begin{displaymath}
\begin{array}{lllllll}
\multicolumn{7}{l}{\mbox{{\it species-name}}_{i} \; N_{i}}  \\
id_{1} & x_{1} & y_{1} & z_{1}&  m_{1} & q_{1} & name_{1} \\
id_{2} & x_{2} & y_{2} & z_{2}&  m_{2} & q_{2} & name_{2} \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
id_{n_{i}} & x_{n_{i}} & y_{n_{i}} & z_{n_{i}}& 
m_{n_{i}} & q_{n_{i}} & name_{n_{i}} \\
\end{array}
\end{displaymath}
where {\it species-name}$_{i}$ is the name of the molecule and $N_{i}$
is the number of molecules of that type in the system. Each molecule
has $n_{i}$ atoms, one for each line in that group and each kind of
atom is identified by a number $id_{i}$ (the site id) which will be
used to specify the appropriate potential parameters. Its co-ordinates
are $(x_{i},y_{i},z_{i})$, its mass is $m_{i}$, its charge is $q_{i}$
and its name is $name_{i}$.  See Appendix~\ref{sec:examples} for some
sample system specification files.

If there is more than one atom of any type (in the system - not just
the same molecule) it is sufficient to identify it by its $id$ (and
the site co-ordinates!).  If $m_{i}$, $q_{i}$ or $name_{i}$ {\em are\/}
given they must agree exactly with the previous values or an error
will be signalled.

Site ids, masses and charges are all checked for `reasonableness'
and impossible values cause an error. The set of site ids does not
have to start at 1 or be contiguous, but since this may indicate a
mistake, a warning is issued.

Following the physical specification is the specification of the
potential functions. This takes the form
\begin{displaymath}
\begin{array}{llllll}
\multicolumn{4}{l}{\mbox{{\it potential-type}}} \\
i & j & p^{1}_{ij} & p^{2}_{ij} & \ldots & p^{r}_{ij}  \\
k & l & p^{1}_{kl} & p^{2}_{kl} & \ldots & p^{r}_{kl}  \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
m & n & p^{1}_{mn} & p^{2}_{mn} & \ldots & p^{r}_{mn}  \\
\mbox{\texttt{end}} \\
\end{array}
\end{displaymath}
where {\it potential-type\/} is one of the keywords
\texttt{Lennard-Jones}, \texttt{Buckingham} or \texttt{MCY} to identify the kind of
potentials to be used,  $i, j, k, l, m, n$ are site ids and
$p^{\alpha}_{ij}$ is the $\alpha^{th}$ potential parameter between
sites $i$ and $j$.  There should be one line for each distinct pair of
site ids.  If any pair is omitted a warning is issued and the
parameter values are set to zero.

The meaning of the parameters for the currently defined potentials is
as follows:
\begin{description}
\item[Lennard-Jones] The potential is 
\[\phi(r_{ij}) = \epsilon((\sigma/r_{ij})^{12}) -
(\sigma/r_{ij})^{6}),\] and has two parameters, $\epsilon ( \equiv p^{1}_{ij})$
and $\sigma ( \equiv p^{2}_{ij})$, which occur on each line in that
order.  Note that the definition of $\epsilon$ {\em includes}\/ the
factor of 4 more usually separated out.  The control parameter
\texttt{time-unit} may be divided by four to read potentials
specified in the standard form.

\item[Buckingham] This includes potentials of the Born-Meyer type and
has formula \[\phi(r_{ij}) = -A_{ij}/r^{6}_{ij} + B_{ij}\exp(-C_{ij}r_{ij}).\]
The three parameters appear on each line in the order $A, B, C$.
\item[MCY] This type supports potentials of the same form as the water
model of Matsuoka, Clementi and Yoshimine\cite{matsuoka:75}, 
\[\phi(r_{ij}) = A_{ij}\exp(-B_{ij}r_{ij}) - C_{ij}\exp(-D_{ij}r_{ij}),\]
and the four parameters appear on the line in the order $A, B, C, D$.
\end{description}
Other types of potential types may be easily added: see
appendix~\ref{sec:newpot}.

It is possible to specify the units in which these quantities are given
by means of the control file parameters \texttt{mass-unit},
\texttt{length-unit}, \texttt{time-unit} and \texttt{charge-unit} 
(which are themselves specified in SI units). All quantities read from
the system specification file (dimensions as well as potentials) are
taken to be in those units. Their default values are amu, \AA, 0.1ps
and $q_{e}$, which means that the unit of energy is kJ mol$^{-1}$.  So
to read in \AA, amu and kcal mol$^{-1}$, specify
\texttt{time-unit=4.8888213e-14}.

Once the system specification has been read in, all quantities are
converted to `internal' units: a.m.u., \AA, ps, and $\insqrt (
\mbox{a.m.u. \AA}^{3} \mbox{ps}^{-2}/(4 \pi \epsilon_{0}) )$.
The prototype molecule for each species is then shifted so that its
zero of coordinates lies on its centre of mass, and rotated into the
principal frame (polyatomics only).

\subsection{The Initial Configuration}

\moldy\  provides two methods of setting up an initial configuration.
By default the {\em skew start\/} method of section~\ref{sec:skewstart}
is used to place the molecular centres of mass in a regular
arrangement which ensures molecular separation.  If there is more than
one species present, molecules of each are chosen randomly for each
site.  Molecular orientations are chosen randomly from a uniform
distribution.  This method has been found to work well for reasonably
small or fairly isotropic molecules and it is anticipated that it will
be the usual method of starting a simulation of the liquid state.   On
the other hand, if the constituent molecules are sufficiently large
and irregular, or if it is intended to simulate the solid state then
the {\em lattice start\/} method will be more appropriate.

This method is activated by setting the control parameter
\texttt{lattice-start} to 1, and creates the initial configuration by
periodic replication of some crystalline unit cell.  In that case
\moldy\  expects to find, following the \texttt{end} which terminates the
system specification, an initial configuration specification of the
following form:
\begin{displaymath}
\begin{array}{llllllll}
\multicolumn{8}{l}{a\;b\;c\;\alpha\;\beta\;\gamma\;n_{x}\;n_{y}\;n_{z}} \\
\mbox{{\it species-name}}_{1} &
X_{1} & Y_{1} & Z_{1} &  q_{10} & q_{11} & q_{12} & q_{13} \\
\vdots &  \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
\mbox{{\it species-name}}_{i} & X_{i} & Y_{i} & Z_{i} \\
\vdots &  \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
\mbox{{\it species-name}}_{n} &
X_{n} & Y_{n} & Z_{n} &  q_{n0} & q_{n1} & q_{n2} & q_{n3}  \\
\mbox{\texttt{end}}. \\
\end{array}
\end{displaymath}
Here $a, b, c$ and $\alpha, \beta, \gamma$ are the crystal unit cell
parameters, and $n_{x}, n_{y}, n_{z}$ are the number of unit cells in
each direction which comprise the MD cell.  The next $n$ lines
describe the $n$ molecules of the basis which will be replicated to
form the full configuration.  Molecules may appear in any order, but
of course the total number of each, multiplied by the number of unit
cells $n_{x} n_{y} n_{z}$ must agree with that given in the system
specification file.

Each molecule is identified by its name, as given in the system
specification file.  $X, Y$ and $Z$ are {\em fractional\/} co-ordinates,
between 0 and 1 giving the location of the molecular centres of mass in
the crystal unit cell. The orientation is given by the four
quaternions $q_{0}, q_{1}, q_{2}, q_{3}$ which specify a rotation {\em
relative to the orientation of the prototype molecule in the system
specification file}.  (Notice the slight inconsistency with the
positions, which are of the centres of mass, {\em not\/} the zeroes of
co-ordinates in the system specification file. This may be fixed in
future releases.)  Quaternions need only be included for
polyatomic species, that is molecules $1$ and $n$ above, and omitted
for the monatomic species $i$.

After the molecular positions and orientations have been set up, their
velocities (and angular velocities if appropriate) are initialised.
Their values are sampled at random from the
Maxwell-Boltzmann distribution for the temperature $T$, as given by
the control parameter \texttt{temperature}.  This is done for both
starting methods.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Restarting from a Previous Run}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:restarting}

At the end of a simulation run, it is often desirable to store the
configuration of the system in a file.  This {\em restart file\/} may be
used at a later date to continue the simulation from that point rather
than from scratch.  To instruct \moldy\  to write a restart file, simply
set the control parameter \texttt{save-file} to a suitable filename; to
start from a restart file, set \texttt{restart-file} to be the name of
that file.

Each restart file is a binary file which contains enough information
to reconstruct the exact state of the system and of the program.  It
includes a copy of all the control parameters in force, the current
timestep number, a complete system specification, all the simulation
dynamic variables and the intermediate data used in the calculation of
averages and radial distribution functions.  Thus a run continued from
a restart file will proceed just as if there had been no interruption
and will generate identical results (provided the control parameters
are not changed).

When continuing a simulation, it is only necessary to explicitly
specify control parameters which are to be changed.  Their previous
values are read from the restart file and are used as defaults when
reading the control file. Consequently control files for restarting
tend to be rather short. {\bf Caution}: always include a new (possibly
null) value for \texttt{save-file}. Otherwise when the new run
terminates, the new restart file may overwrite the old
one\footnote{Whether the old file is lost depends on the operating
system. Under systems such as VMS which have version numbers a
new version is created and the old one remains. Under Unix, the old
file is renamed by the addition of a ``\%'' character and thus is
saved. On other systems it will be lost.}.

Neither is it necessary to repeat the system specification since that
too is stored in the restart file.  However there are occasions
when it is desirable to do just that, for example if the value of one
of the potential parameters is to be modified.  In that case, set the
switch \texttt{new-sys-spec} to 1 (true) and provide a system
specification as per a new simulation.  This is checked for
consistency with the existing one and if correct replaces it.  The
following checks are applied, which only verify that it is sensible to
assign the old dynamic variables to the new system. {\em 1}. The
number of species must be the same. {\em 2}. Each species must have
the same number of rotational degrees of freedom as its predecessor.
It is not possible to replace a polyatomic by a monatomic or
linear molecule, for example.  {\em 3}. The number of molecules of
each species must not change.  This means that the order in the
specification file must be identical too.  It is however possible to
change the number of sites on a molecule, subject to {\em 2}.

\subsection{Periodic Backup}
\label{sec:backup}
Closely related to restarting is the backup mechanism.  This is
provided to guard against the complete loss of a simulation due to
computer failure. Periodically during a run, \moldy\  writes its state
to a {\em backup file\/} -- which is in fact just a restart file.  In
the event of a crash, the simulation can be restarted from the point
the last backup was written rather than from the beginning. The
related control parameters are \texttt{backup-file} which specifies the
file name and \texttt{backup-interval} which gives the frequency of
backups.  It should not normally be necessary to change the name, but
the optimum interval will depend on the size of the simulated system
and the speed of the computer. By default it is 500.  At the
successful end of a run the backup file is deleted so that only if
there is an abnormal termination does one remain\footnote{A backup
file is also written if the run is terminated for exceeding its cpu
limit.}.

The restart from a backup is entirely automatic. If a backup file
exists when a run is started, it is read in and the run continues from
it.  In contrast to a normal restart all of the control parameters are
taken from the backup file and the control file (and a restart file if
one is specified) is ignored\footnote{This is not quite true. \moldy\
does read the control file and any restart file but only to determine
the name of the backup file. Thus even if the backup has a
non-standard name it can still be found.}.  In consequence, if a run
is aborted or stops abnormally for some reason, the backup file must
be removed ``by hand'' otherwise next time a run starts, the unwanted
simulation will continue instead.

If a run terminates abnormally there may also be a {\em lock file\/}
called \texttt{MDBACKUP.lck} which ought to be removed.  \moldy\
attempts to prevent two runs from overwriting each other's backup
files by creating a lock file whose name is formed from the backup
name by appending \texttt{.lck}.  A second run which attempts to use the
same backup file will test for the presence of the lock file and abort
the run if it finds it.

A restart or backup file is created by first writing the data to a
temporary file which is then renamed to the final name.  This ensures
that there is no possibility of a file being left incomplete or
corrupt if the computer crashes part-way through the write.  If the
file already exists either it is replaced (on systems which only keep
one version of a file) or a new version is created (on systems such as
VMS which retain multiple versions).  In the unlikely event of
it being necessary to change where the temporary file is
kept\footnote{This may be necessary if the restart file is located on
a different device or disk partition from the current directory. To
rename the temporary file successfully, it must reside in the same
partition or device as the restart file}, it may be specified with the
control parameter
\texttt{temp-file}.

\subsection{Portable Restart Files}
\label{sec:xdr}
\moldy\ is able\footnote{From version 2.1 onwards} to read and write
restart and dump files in a portable binary format which is
transportable between computers of different architectures.  So a
restart file written on, for example, a Sun may be used to initiate a
new run on a Cray, and the dump files generated on the Cray may be
analyzed on the Sun.  This feature will also be of considerable use in
modern heterogeneous networks where diverse machines frequently share
a common file space.

The format is based on Sun Microsystems XDR protocol\cite{sunxdr}.
The XDR routines are available on almost every modern Unix machine,
and are simple enough to implement on any other
system\footnote{Because the XDR calls are not part of ANSI standard C,
however, the XDR code is conditionally compiled into \moldy\ only if
the \texttt{USE\_XDR} preprocessor symbol is defined during
compilation.}.  If the control parameter \texttt{xdr} is set to 1 then
all files will be written using this format. \moldy\ automatically
determines whether a restart file was written using XDR (by examining
the file header) and reads it in the appropriate fashion irrespective
of the value of \texttt{xdr}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Setting the Temperature}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\moldy\ implements three different methods to control the temperature
of the simulated system. These are the velocity rescaling technique
described in section~\ref{sec:rescaling}, the Nos\'e-Hoover thermostat
and constrained equations of motion (section~\ref{sec:const-temp}).
Scaling is selected by the parameters \texttt{scale-interval} \etc.
Every \texttt{scale-interval} timesteps until \texttt{scale-end}, the
velocities are adjusted so that the kinetic energy corresponds exactly
to the desired temperature (the value of control parameter
\texttt{temperature}).  The Nos\'e-Hoover and constrained thermostat
are selected by setting \texttt{const-temp} equal to \texttt{1} or
\texttt{2} respectively.

The control parameter \texttt{scale-options} selects refinements to
the basic scaling or thermostat algorithms. This is an integer
parameter interpreted as a set of bit flags with the following meanings.
\begin{description}
\item[bit 0]    perform scaling or thermostatting for each molecular species individually.
\item[bit 1]    scale/thermostat the rotational and translational components of
the kinetic energy separately.
\item[bit 2]    use the rolling averages of kinetic energy to
calculate the scale factor rather than the instantaneous values.
\item[bit 3]    discard all existing velocities and accelerations and
re-initialize from the Maxwell-Boltzmann distribution.
\end{description}
The bits may be set in any combination so, for example
\texttt{scale-options=6} sets bits 1 and 2 ($ 6 = 2^1 + 2^2$) and scales
separately for rotation/translation using the rolling averages.  If
bit 3 is set the others are ignored.  Only bits 0 and 1 have any
meaning in the case of a thermostat, and signify that each species, or
the translational and rotational degrees of freedom are isolated from
each other and coupled to their own, individual heat baths.

The options for scaling separately rotation and translation, and per
species may be useful for achieving equilibration in ``difficult''
systems where mode-coupling is ineffective.  In those situations it is
otherwise possible for all the energy to be transferred into the
rotational modes of a particular species, halting any progress to
equilibrium for other degrees of freedom.   These options ensure that
all degrees of freedom have some thermal energy.

The option controlled by bit 3, to discard all existing information
and start from a random set of velocities may be of use when starting
from far-from-equilibrium situations.  In such cases the forces
are frequently so large that the velocities and accelerations exceed
the limits of the integration algorithm and timestep, which results in
\moldy\ stopping with a {\em quaternion normalization\/} or {\em
quaternion constraint\/} error.  Judicious use of this option every few
timesteps (using \texttt{scale-interval}) ought to allow the system to
relax to a state sufficiently close to equilibrium for normal scaling
to take over.

Bit 2 is intended to deal with the problem of setting the temperature
accurately using scaling.  The {\em ensemble average\/} kinetic energy
which characterizes the temperature of the system and the
instantaneous value fluctuates about this value.  However in the
traditional implementation of scaling, velocities are multiplied by a
factor of $\sqrt{\mbox{\it desired KE} / \mbox{\it instantaneous
    KE}}$.  Thus the scaling factor is ``wrong'' by the ratio of the
instantaneous to average KE's which means that the temperature can not
be set more accurately than the relative size of the fluctuations in
the KE\@.  The option selected by bit 2 goes some way towards the
ideal scaling factor by using the rolling average KE instead of the
instantaneous value.  The fluctuations in this short-term average
should be much lower than in the instantaneous value, allowing more
accurate temperature control.  However it will almost always be easier
to use a true thermostat to achieve this goal.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Output}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:output}
At the beginning of each run \moldy\  writes a {\em banner page\/}
containing a summary of the system being simulated and details of the
important control parameters. The bulk of the output file is the {\em
periodic output\/} which contains the instantaneous values of various
thermodynamic variables, their rolling averages and associated
standard deviations. The {\em rolling average\/} is just the mean over
the preceding $n$ timesteps where $n$ is set by the control parameter
\texttt{roll-interval}.   An annotated example is given in
figure~\ref{fig:output}.  The frequency of periodic output may be
altered by setting the control parameter \texttt{print-interval} to the
interval required.  (This may be necessary to constrain the size of
the output file which can grow to be very large indeed with the
default interval of only 10.)

\begin{figure}
\caption[Sample \moldy\  output.]{Sample \moldy\  output from a simulation 
of a two component mixture.  The first component is a polyatomic
molecule and the second is atomic.  There are three {\em frames}, for
the instantaneous values, the rolling averages and their associated
standard deviations.  Within a frame, each row has the following
meaning: for translational and rotational kinetic energies and
temperatures it is the per-species value; for the potential energy it
is the direct and reciprocal space components, and the MD cell matrix,
{\tt h} and the stress are laid out as $3\times 3$ matrices.}
\label{fig:output}
\tiny
%
\begin{tabular}{rrrrrrrr
@{\hspace{1em}}r@{\hspace{1em}}rr@{\hspace{1em}}r@{\hspace{1em}}r}
\multicolumn{6}{r}{\hfill Nov 17 15:13:06 1989 \hfill Water\_test
\hfill Page 4} & & & & & & &\\
Trans KE & Rot KE & Pot Energy & Tot Energy & TTemp & RTemp & Temp &
h(1,*) & h(2,*) & h(3,*) & Stress & Stress & Stress \\
\multicolumn{13}{l}{======== Timestep 10      Current values
======================================================== } \\
243.88 & 453.88  & -187.35  & 533.5  & 305.5  & 568.6  & 424.4  &
12.53  & 0.00  & 0.00  & 589  & 46.4  & 120 \\
22.053  & 0  & 1.0401 & & 221.0  & 0.0 & & 0.00  & 12.53  & 0.00  & 46.4
& 373  & 90.1 \\
 &  &  &  &  & & &  0.00  & 0.00  & 12.53 & 120  & 90.1  & -207 \\
\multicolumn{13}{l}{-------- Rolling averages over last 10 timesteps
--------------------------------------------------------------------------
------------------------------------------------
} \\
240.27 & 319.31 & -82.472 & 533.39 & 301.0 & 400.0 & 342.9 & 12.53 &
0.00 & 0.00 & 1.2e+03 & 296 & 127 \\
22.077 & 0 & 34.205  & & 221.3 & 0.0 & & 0.00 & 12.53 & 0.00 & 296 &
589 & 133 \\
& & & & & & & 0.00 & 0.00 & 12.53 & 127 & 133 & -132 \\
\multicolumn{13}{l}{-------- Standard deviations
---------------------------------------------------------------------------------------------------------------------------------------------------
} \\
1.8214 & 71.893 & 56.441 &.19942 & 2.3 & 90.1 & 43.4 & 0.00 & 0.00 &
0.00 & 1.32e+03 & 750 & 51 \\
0.013 & 0 & 17.173 & & 0.1 & 0.0 & & 0.00 & 0.00 & 0.00 & 750 & 119 & 55.2 \\
 & & &  &  &  &  & 0.00  & 0.00 & 0.00 & 51 & 55.2 & 49 \\
\end{tabular}
\end{figure}

As well as the ``short term'' rolling averages, long term averages are
calculated and printed out at regular but usually infrequent
intervals.  Accumulation starts on the timestep given by the control
parameter \texttt{begin-average} and every \texttt{average-interval}
timesteps thereafter, the means and standard deviations are calculated
and printed.  This output is interspersed with the periodic output and
is formatted with one variable to a line in the form {\em mean +/-
  s.d}.. Where a variable has more than one component (such as
multiple species for the translational temperature or Cartesian
components for the mean square forces) the components are printed
across the page\footnote{Remember that the standard deviation is a
  measure of the {\em fluctuations\/} about the mean, {\bf not} the
  {\em uncertainty\/} in the mean. For that the standard error in the
  mean is required, which is more difficult to evaluate.
  Theoretically it is the {\em s.d.\/} divided by $\sqrt N$ where $N$
  is the number of independent observations.  But successive timesteps
  are highly correlated and do not count as independent.  See
  ref~\cite{allen:87} section 6.4, page 191 onwards for a full
  discussion.}.  In addition to those variables printed as part of the
periodic output, the pressure, the virial, mean square forces, mean
square torques and total dipole moments are calculated.

\subsection{Output units}
All of the various forms of output use the same units, though for
brevity they are not explicitly mentioned on the periodic output.
Lengths are measured in \AA, energies are all expressed in kJ
mol$^{-1}$, temperatures in Kelvin, pressure and stress in MPa, mean
square forces and torques in N$^2$ mol$^{-1}$ and Nm$^2$
mol$^{-1}$, charge in electron charges and dipole moments in Debye.
Because energy is an extensive quantity the printed values refer to
the {\em whole system}.  (There is no practical way of expressing
energies per mole of any particular constituent in a program capable
of simulating arbitrary mixtures.)

If these units do not suit, they can be changed in the configuration
file \texttt{defs.h}, where the conversion from internal to output units
is parameterized.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Radial Distribution Functions}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Radial distribution functions are calculated by binning site pair
distances periodically throughout the simulation (see
section~\ref{sec:rdf}.  As this process is expensive in computer time
the binning subroutine is invoked only every few timesteps, as set by
the control parameter \texttt{rdf-interval} (20 by default).  Since
the pair distances only change a little on each timestep, very little
statistical information is lost.  Collection of binning data may also
be turned off during an equilibration period: specify when binning is
to start by means of the parameter \texttt{begin-rdf}.  The parameters
\texttt{rdf-limit} and \texttt{nbins} control the details of binning,
giving respectively the largest distance counted and the number of
bins that interval is divided into. The calculation of the interatomic
distances is done separately from that used in the evaluation of the
forces, using the same link-cell scheme.  This ensures that all site
pairs separated by less than \texttt{rdf-limit} are included.  This
parameter may be varied independently of the interaction
cutoff, thereby allowing RDFs to be evaluated out to large distances
without incurring the time penalty of increasing the cutoff
\footnote{In previous versions of \moldy\ the calculation of the
interatomic distances was done on  the basis of the ``minimum image''
convention.  Consequently the calculated value of $g_{\alpha\beta}(r)$
tailed off for $r_c > L/2$.  This restriction is now lifted}.

Every \texttt{rdf-out} timesteps (by default 5000) the RDFs are
calculated from the binned distances and printed out, and the counters
are reset to zero to begin accumulation again.  Distances are binned
and RDFs $g_{\alpha \beta}(r)$ calculated separately for each distinct
type of atom-atom (or site-site) pair.  An explanation of the output
format is given in figure~\ref{fig:rdf-output}.  Note that each number
should be considered as the value at the {\em centre\/} of its bin, so
that entry $i$ in each list is the value of
$g_{\alpha\beta}((i+1/2)b)$ where $b$ is the bin width.

\begin{figure}
\caption[Example output of radial distribution functions.]{Example
output of radial distribution functions. After the header line
consisting of underscores there is an indication of the bin width $b$
(that is the distance between points at which the RDF is tabulated).
Then for each site type pair $\alpha\beta$ there is a line listing
which pair (\eg {\tt O-O RDF}) followed by {\tt nbins}.  values of
$g_{\alpha\beta}((i+1/2)b)$.  }
\label{fig:rdf-output}
\begin{tiny}
\hrulefill
\begin{verbatim}
        Radial Distribution Functions   Bin width=0.1
        O-O RDF
 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000481 0.035710 0.183334 0.442186 0.613992 1.024402
 1.046396 0.964906 0.830174 0.660035 0.693341 0.615902 0.593192 0.510595 0.530697 0.532030 0.535959 0.524457 0.523221 0.466219
 0.496028 0.438487 0.456500 0.410547 0.443861 0.457956 0.446822 0.452202 0.419768 0.439333 0.465509 0.486887 0.461970 0.475745
 0.478883 0.480854 0.509090 0.533728 0.552747 0.552555 0.575402 0.547278 0.544836 0.493597 0.488168 0.520727 0.508073 0.479948
 0.501159 0.484000 0.485378 0.489160 0.464448 0.466791 0.476508 0.446576 0.470948 0.474468 0.449340 0.462169 0.501220 0.519107
 0.513338 0.510192 0.499766 0.525963 0.504663 0.517673 0.498359 0.512156 0.507061 0.466390 0.464342 0.445886 0.417555 0.407778
 0.387220 0.374041
        O-H RDF
 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 26.976688 0.000000 0.000000 0.000000 0.000000
 0.000000 0.016214 0.061257 0.304082 0.647342 0.847404 0.757188 0.601222 0.478273 0.462682 0.449614 0.450424 0.518998 0.572242
 0.689704 0.914269 1.184674 1.441772 1.570390 1.609068 1.600392 1.430457 1.322722 1.183606 1.103701 1.061788 0.980018 0.960570
 0.924390 0.908883 0.877591 0.857668 0.890761 0.852463 0.815447 0.824963 0.841255 0.890416 0.929030 0.960589 0.984145 1.020650
 1.028199 1.047496 1.064600 1.099812 1.095715 1.073793 1.078131 1.049212 1.052160 1.052001 1.020737 1.010782 0.979748 0.983158
 0.988946 0.967620 0.955655 0.944384 0.952145 0.948509 0.946692 0.960097 0.959299 0.964074 0.969219 0.972704 0.998504 1.027791
 1.041576 1.037637 1.039961 1.016804 1.004726 1.026805 1.030903 1.006268 0.972421 0.948140 0.908959 0.877089 0.849855 0.817964
 0.776986 0.721485

\end{verbatim}
\end{tiny}
\end{figure}

There are a couple of tricks which may be played with the system
specification if the atomic pair RDFs do not give exactly the
functions required.  Firstly, it is possible to calculate rdfs about a
particular site, distinguishing it from otherwise identical atoms by
assigning it a new and unique site id in the system specification
file.  (This is the MD equivalent of the isotopic substitution method
used in neutron diffraction). Secondly, if the {\em molecular\/} pair
correlation is required, this is identical to the RDF of an atom
located at the molecular centre-of-mass.  A ``ghost'' site without
charge, mass or potentials may be added if necessary.
\pagebreak[3]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dumping}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:dumping}
The dump facility is provided in order to allow the calculation of
dynamic properties, such as time correlation functions and additional
static averages not normally calculated by \moldy.  During a run, dump
files are produced which contain a record of the simulation dynamic
variables (positions, quaternions \etc) at varying degrees of
detail.  Any property of interest, dynamic or static, may then be
evaluated using the data in the dump.

A dump consists of a sequence of files since the amount of data
generated in a run can be very large indeed and it is usually more
convenient to manipulate a series of smaller files rather than one
large and unwieldy one. \moldy\  takes considerable pains to ensure that
a contiguous sequence of dump files is maintained and also ensures
that dumps from different runs are not accidentally intermixed.  There
is no requirement that a dump file be produced by a single run of
\moldy\ , which extends an existing file or starts a new one as appropriate.
A simulation may stop and be restarted many times without
disturbing the dump file sequence.  The  sequence
should (in most cases) even survive a system crash and a restart from
a backup file (see section~\ref{sec:backup}).

Each dump file in a sequence is a binary file consisting of a {\em
dump header}, which contains information about the contents of the
file followed by a number of {\em dump records\/} which contain the
actual data.  

Several control parameters govern dumping. It starts at the timestep
specified by \texttt{begin-dump}, and a dump record is written every
\texttt{dump-interval} timesteps thereafter.  After \texttt{ndumps} dump
records have been written to a file, it is closed and another is
begun. Filenames are generated from a prototype (given by the
parameter \texttt{dump-file}) by appending a number, so that if the
prototype is {\em MDDUMP\/} then successive files will be named
{\em MDDUMP0}, {\em MDDUMP1}, {\em MDDUMP2} \etc\
If it is not convenient for the sequence number to appear at the end
of the file, include the characters ``\%d'' at an appropriate
point\footnote{This is actually the code ``sprintf()'', the C library
function uses to signify converting an integer to a decimal character
string. This function is used to create the actual file name from the
prototype and the integer dump sequence number. (See any C library
manual for details.)}.  For example under VMS, specifying
\texttt{dump-file=mddump\%d.dat} will name the files {\em mddump0.dat},
{\em mddump1.dat\/} \etc.

Each dump record is a sequence of single-precision floating point
binary numbers.  These are written either in native (\ie\ the
machine's own) format or XDR format (see section~\ref{sec:xdr})
depending on the value of the control parameter \texttt{xdr}.  The
record's exact contents are determined by the control parameter
\texttt{dump-level} which is a bit flag {\em i.e}. a value of $2^{n}$
means that bit $n$ is set.  Four bits are used and any combination may
be specified but the cumulative values 1, 3, 7 and 15 are most
useful.  A value of 0 disables dumping. The data dumped for each bit
is as follows:
\begin{description}
\item[bit 0]    centre of mass co-ordinates, quaternions, unit cell matrix 
and potential energy.         
\item[bit 1]    centre of mass velocities, quaternion and unit cell
matrix derivatives.
\item[bit 2]    centre of mass accelerations, quaternion and unit cell
matrix second derivatives.
\item[bit 3]    forces, torques and stress tensor.
\end{description}
Items selected are written in the order laid out above.  Within each
set of variables, values are ordered primarily by species in the order
they appeared in the system specification.  Within a species ordering
vis by molecule (or atom) and at the finest level by $x$, $y$ or $z$
component ($q_{0}, \ldots q_{3}$ for quaternions). Therefore if $n$ is
the total number of molecules and $n_{r}$ is the number with
rotational freedom the size of each record is
\begin{displaymath}
\begin{array}{cll}
   & 3n + 4n_{r} + 9 + 1 & \mbox{(if bit 0 is set)} \\
 + & 3n + 4n_{r} + 9 & \mbox{(if bit 1 is set)} \\
 + & 3n + 4n_{r} + 9 & \mbox{(if bit 2 is set)} \\
 + & 3n + 3n_{r} + 9 & \mbox{(if bit 3 is set)} \\
\end{array}
\end{displaymath}
single precision floating point numbers.

The header is a copy of a \texttt{struct dump\_t} (see
appendix~\ref{sec:structs} for the format). It contains the simulation
title and version number, the timestep at the beginning of the file,
the control parameters \texttt{dump-interval} and \texttt{dump-level}, the
maximum and actual number of dump records in the file, a unique marker
(actually a timestamp), common to all the files in a dump run, and the
timestamp\footnote{A timestamp is simply the number of seconds elapsed
since midnight on January 1, 1970.} of any restart file used to start
the run.

It is not possible to dump directly to magnetic tape. \moldy\ must
rewind to the beginning of a file to keep the header up to date with
the number of dumps in the file, as well as extend existing files.
Neither operation is allowed on a tape drive.  Large disk stores are
now very cheap so this should not be a problem in practice.  If disk
store {\em is\/} limited then the simulation may be divided into
multiple \moldy\ runs interspersed with copying of dump files to
tape.

Notice that \moldy\  must sometimes read an existing but complete dump
file to propagate the unique marker to all of the files in a sequence.
Therefore when continuing a simulation and a dump run, at least
the immediately preceding dump file must still be accessible.  This
should be borne in mind when copying dumps to tape!

\moldy\  is careful to ensure that existing files are not
overwritten - especially necessary since dump records are added to
the end of an existing dump file.  Whenever \moldy\  prepares to start a
new dump file it checks to see if one of that name is already present.
If so, a new name is chosen by ``mutating'' the old one, and a warning
message to that effect is written to the output file. On the other
hand, if the {\em first\/} file of a new dump run (including one
initiated because of some error in continuing an old one) already
exists, the {\em prototype\/} file name is mutated as above and the
whole dump run is written to files based on the mutated name.

When a run is restarted checks are made to ensure that the values of
the dump control parameters have not been altered.  If they
have, it is not possible to continue an existing dump sequence and a
new one will be started.  (If existing dump files are present the new
sequence will have mutated file names.)  This also happens if an
existing file does not appear to be a \moldy\  dump.  Existing dump
files are also tested to ensure that there is no corruption (due, for
example to a system crash) and that they contain the correct number of
records.  If the dump sequence can not be continued in these
circumstances, \moldy\  terminates with a fatal error rather than waste
computer time.

%To ensure that the header always records the correct number of dump
%records in a file, it is updated {\em after\/} the actual record has
%been written.  It is possible that following s crash there may be one
%more record than recorded.  \moldy\  ignores it and recalculates and
%dumps the data.

Two utility programs included in the distribution are {\em
dumpanal\/} which identifies dump files by printing out the headers
and {\em dumpext\/} which extracts atomic or molecular
trajectories.  The latter should be useful as a prototype for writing
programs to analyse dump data.

It is frequently convenient to perform analysis of dump data, and
perhaps graphical output on a different computer to that which
generated the data.  In the past it has not usually been possible to
sensibly transfer binary data between computers of different
architectures.  However \moldy\ is able to write dump files in a
portable format using XDR (see section~\ref{sec:xdr}) which may be
read by {\em dumpext\/} on any machine.  The control parameter
\texttt{xdr} enables XDR mode for dumps as well as restart files.
As yet, XDR is not available on every machine.  Therefore a program
called {\em dumpconv\/} is provided which converts dump files to a
portable text file format (which may be easily moved between machines)
and back again. It is described in appendix~\ref{sec:dumpconv}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Constant Stress Simulation}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Setting  the control parameter   \texttt{const-pressure} switches from a
constant-volume  simulation to a con\-stant-stress  simulation using the
method     of    Parrinello     and    Rahman\cite{parrinello:81}   (see
section~\ref{sec:const-stress}).   The value of  the  ``MD cell'' mass
parameter,  $W$  is given by the control  parameter \texttt{w}  and  the
external pressure by \texttt{pressure}. At present it is not possible to
specify an anisotropic external stress, though this  capability may be
added in future versions of the program.

\label{sec:cp-constraints}
The $\bm{h}$ matrix may be constrained so as to disable motion of any
or all of its components using the parameter \texttt{strain-mask}. 
\texttt{Strain-mask} is a bitmap: each ``bit'' of the integer
freezes one of the components of $\bm{h}$;
bit $i$ freezes $ \bm{h}_{kl}$ with 
$ i = 3 (k\!-\!1)\! +\! l\! -\!1$.
The bitmask is the sum of $2^i$ over the $i$'s to be set, so the
\texttt{strain-mask} values

\begin{displaymath}
\left (
\begin{array}{rrr}
1 & 2 & 4 \\ 8 & 16 & 32 \\ 64 & 128 & 256
\end{array}
\right )
\mbox{constrain the corresponding components of }
h, 
\left (
\begin{array}{rrr}
h_{11} & h_{12} & h_{13} \\ h_{21} & h_{22} & h_{23} \\ h_{31} & h_{32} & h_{33}
\end{array}
\right ).
\end{displaymath}

Thus the default constraint of $\bm{h}_{?1} = \bm{a} = (a_x,0,0),
\bm{h}_{?2} = \bm{b} = (b_x,b_y,0)$ is given by \texttt{strain-mask=200}
(8+64+128).  Another useful value is 238 which freezes all the
off-diagonal components.  This is needed for a liquid simulation since
there are no shear restoring forces acting on those components.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cutoffs and Adjustable Parameters}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

There are four parameters related to the Ewald sum method of force
evaluation (see section~\ref{sec:ewald}), $\alpha$, $r_c$, $k_c$, and
\texttt{subcell}.  In addition the two options \texttt{strict-cutoff}
and \texttt{surface-dipole} select how rigorously the real-space
cutoff is applied and whether to include the De Leuuw surface dipole
term.

By default $\alpha$, $r_c$ and $k_c$ are chosen automatically, using
equations~\ref{eqn:ewald-cut} to give a default accuracy of $\epsilon
= \exp(-p) = 10^{-5}$ (\ie\ $p = 11.5$) in the coulombic potential energy
evaluation.  An empirically determined value of $t_R/t_F = 5.5$ is
used.  If a different accuracy is desired the cutoffs may be adjusted
using equations~\ref{eqn:ewald-cut}.  The $\alpha$ parameter is
specified by \texttt{alpha} in units of \AA$^{-1}$ and the direct and
reciprocal space cutoff distances $r_{c}$ and $k_{c}$ by
\texttt{cutoff} and \texttt{k-cutoff} in units of \AA\ and \AA$^{-1}$
respectively.  The value of $\alpha$ should only be changed after
careful timing tests if the system size is large.  The power-law given
in equation~\ref{eqn:ewald-alpha} gives a theoretical scaling of
execution time with number of ions of $T \propto N^{1.5}$. In practise $T
\propto N^{1.57}$ has been achieved over a range of $N$ from 72 to
7800, which is very close to optimal.

\textbf{Important note:} The automatically determined value of $r_c$
is chosen to converge the coulombic part of the potential only.  Due
to the very general nature of the potentials it is not possible to
choose $r_c$ automatically so as to guarantee convergence of the
non-electrostatic part. Although in many cases the automatic value
will be adequate \textbf{it is the user's responsibility to ensure
  that it is large enough}. If there are no charges in the system
specification file then $r_c$ is not set and an error message is
issued.

As an example of manual determination of the parameters, for a
simulation of 512 MCY water molecules the values $\alpha =
0.3$\AA$^{-1}$, $r_{c} = 9$\AA\ and $k_{c} = 1.9$\AA$^{-1}$ give
potential energies correct to approximately 1 part in $10^{5}$.  For a
simulation including ions - 1.1 Molal Magnesium Chloride solution -
the same accuracy is attained with $\alpha = 0.45$\AA$^{-1}$, $r_{c} =
9$\AA\ and $k_{c} = 3$\AA$^{-1}$.

The other relevant parameter is the switch \texttt{surface-dipole} which
includes the dipole surface energy term of De Leeuw, Perram and
Smith\cite{deleeuw:80}.  See the note in section~\ref{sec:ewald} for an
explanation of why this term should {\em never\/} be used for an ionic
(as opposed to dipolar) system.

The two adjustable parameters which control the link-cell force
calculation (see section~\ref{sec:link-cell}) are \texttt{subcell} and
\texttt{strict-cutoff}. The former specifies the length (in \AA) of the side of
a link cell and determines the number of cells the MD cell is divided
into. In fact the MD cell is divided into a whole number of subcells
whose side in each of the three directions is nearest to the value of
\texttt{subcell}.  (The default of zero though, is special and sets
subcell to one fifth of the cutoff radius.)  In general the smaller
the link cell, the more accurately the cutoff radius is implemented,
but too many of them reduces the efficiency of the program.

In the default cutoff mode \texttt{strict-cutoff=false} the list of
neighbour cells is constructed to include all cells whose
centre-centre distance is less than the cutoff.  This means that some
molecule pairs separated by more than the cutoff will be included and
some by less will be omitted.  Setting \texttt{strict-cutoff} to true
generates a larger cell neighbour list which is guaranteed to include
all appropriate molecule pairs.  Furthermore, molecules separated by
more than the cutoff are excluded from the force calculation by
setting their separation to a large number, 100 times the cutoff, at
which distance it is assumed the potential is very close to zero.
This is therefore the mode of choice for liquid simulations where any
artificial anisotropy is undesirable.  See section~\ref{sec:link-cell}
for a full explanation.

It is worth noting that it is unnecessary to recompile the program or
change anything else when the cutoffs are modified. Unlike most MD
codes, \moldy\  employs dynamic array allocation and automatically sets
up arrays of the correct size (and no more!) for any given $k_{c}$.
In the case of $r_{c}$ any value up to the length of the smallest MD
cell edge may be given. Any attempt to exceed this will result in the
program terminating with an error\footnote{In the unlikely event this
limit is too small, the modification is simple.  Simply set the {\tt
\#define}d constant {\tt NSH} in {\tt force.c} to the maximum number of
MD cell lengths required and recompile.  This will use slightly more
memory, but not unreasonably more}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Framework Simulations}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

There has recently been much interest in simulations of systems of
molecules interacting with some rigid framework such as zeolites,
clays and other surfaces.  \moldy\  has the capability to include such a
framework in a simulation by defining it as a special kind of molecule.

The system specification should contain an entry, similar to that for
a normal molecule, which describes the atomic sites belonging to one
MD cell's worth of the framework.  Its periodic images should fill
space to construct the required infinite framework.  This is notified
to the program by modifying the first line of the specification of
that molecule to read
\begin{displaymath}
\begin{array}{lllllll}
\multicolumn{7}{l}{\mbox{{\it species-name}}_{i} {\tt \; 1 \; Framework}}  \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
\end{array}
\end{displaymath}
(compare with section~\ref{sec:sys-spec}).  The effect of the special
keyword \texttt{framework} is
\begin{enumerate}
\item to remove the rotational freedom of the molecule.  This
preserves the infinite structure over MD cell repeats by disallowing
relative motion of its parts. (Linear motion does not destroy the
structure and {\em is\/} allowed.)
\item to modify the effect of the periodic boundary conditions.
Normally a molecule is assumed to be ``small'' and periodic relocations
are applied to {\em all\/} of its atoms depending on its centre-of-mass
co-ordinates relative to some interacting molecule.  In contrast, the
atoms of a framework are independently relocated.  This ensures that
each molecule ``sees'' all framework atoms from any unit cell which
are within the cut-off distance.
\end{enumerate}

In the present version of the program, only one framework molecule is
allowed, though more may be permitted in future versions. Consequently
the configuration given as a lattice start must fill the entire MD
box. (A skew start is not sensible under these circumstances since the
orientation of the framework must be explicitly specified to construct
a good space-filling structure.)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Messages and Errors}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Apart from the periodic output, there are occasional ``once-off''
messages which \moldy\  writes to the usual output file.  Such messages
begin with the characters \texttt{*I*}, \texttt{*W*}, \texttt{*E*} or
\texttt{*F*} denoting the classes {\em information}, {\em warning}, {\em
error\/} or {\em fatal\/} respectively.  Their meanings are
\begin{description}
\item[{\tt*I*}] information. These are often produced by subroutines
to give useful information on their particular calculations.  For
example when temperature scaling is turned off a message to that
effect is recorded in the output file.  Various routines which
calculate internal quantities such as the Ewald sum self energies and
distant potential corrections also record their values using an
information message.
\item[{\tt*W*}] warning.  When the system specification is suspicious
but not clearly wrong, or some untoward condition is detected such as
two atoms approaching too closely, a warning message is issued.
\item[{\tt*E*}] error. Error messages are issued when an mistake is
detected reading any of the input files. To make correction easier,
processing continues until the end of that file, so that all of the
errors are found.  The simulation is then stopped with a fatal error.
\item[{\tt*F*}] fatal. The simulation is terminated immediately. Faulty 
input files generate fatal errors after they have been completely
processed.  There are many other conditions which also generate fatal
errors, for example if the simulation algorithms violate some
criterion such as quaternion normalization or constraints (see
section~\ref{sec:quaternions}), if the program runs out of memory or
if a restart file can not be correctly opened or is of the wrong
format.
\end{description}
Most of the messages are self-explanatory.  However there are two
fatal errors which occasionally arise and are somewhat cryptic:

\texttt{*F* Quaternion n (x,x,x,x) - normalisation error in beeman}

and

\texttt{*F* Quaternion n - constraint error (x)}

\noindent
Technically these refer to violations of the conditions that the
quaternions representing the angular co-ordinates be normalized to 1
and that equation~\ref{eqn:qconst} be satisfied.  Either may occur if
the angular velocity of some molecule becomes too high for accurate
integration of the equations of motion. This may have a number of
causes.  First the timestep may simply be too large.  Second the
system may be in a state where atoms are so close as to generate large
torques which accelerate the molecule to a high angular velocity. This
commonly arises if the starting configuration is very far from
equilibrium, particularly in the case of molecules with small moments
of inertia, such as methane.  In most cases the simulation may be
restarted using strong rescaling or a Gaussian thermostat to limit
velocities during the approach to equilibrium.  Occasionally a smaller
timestep may be help during equilibration.  The third cause of
normalisation or constraint errors is an error in the potentials or
the units which allows for a state with high or infinite negative
binding energy.

Note that these messages only occur for polyatomic molecules.  If the
system is monatomic the errors mentioned above may still be present
but will not be detected and the simulation may fail in some less
predictable manner, for example particles may approach too closely
and/or acquire high velocities and fly off to infinity.  The message

\texttt{*W* Sites n and m closer than 0.5A.}

\noindent
gives some warning of this condition.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Compiling and Modifying Moldy} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The \moldy\  distribution consists of numerous files of `C' source code
for \moldy\  and the utility programs, command or job files to compile
the source, \LaTeX\ input for the manual and example control and system
specification files.  For ease of transport these are packed into one
large ``archive'' file, whose format and method of unpacking depends
on the operating system of the target machine.  At present it is
available for:

\begin{description}
\item[unix]  The archive is either a tar archive called {\em
moldy.tar\/} or a Bourne shell script called {\em moldy.shar}. The first
is unpacked by the command \texttt{tar xvf moldy.tar} and the second by
\texttt{/bin/sh moldy.shar}.

\item[VMS]  The archive is a DCL command file called {\em moldy.com},
and is unpacked by the command \texttt{@moldy}.

\item[MS-DOS] The files must be unpacked from the tar archive on
another host and transferred to the PC by disk or ftp.

\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Compilation}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The source code of \moldy\  consists of 23 files of C programs (which have
suffix ``.c'') and 8 header files (suffix ``.h'').
To build \moldy\ , all of the ``.c'' files must be compiled and linked
together to form an executable.  The method of doing this depends on
the operating system of the target computer.
\begin{description}
\item[unix]  The ``make'' program is used and the make file is
supplied in the distribution.  The \texttt{Makefile} supplied will attempt
to compile using the command \texttt{cc -O -DUSE\_XDR} which will usually
be sufficient to build a working executable on most operating
systems.  However some systems may require extra libraries to
be specified and it will usually be possible to build a faster-running
executable by judicious use of optimization options. Options for many
common compilers/operating systems are listed in commented-out form.
To enable them, simply uncomment the appropriate lines in the makefile.
Then just type \texttt{make} to compile and link \moldy\  and
\texttt{make utilities} for the utility programs.

\item[VMS]  Simply type \texttt{@compile} to execute the command file
``compile.com''. This will build \moldy\  and the utilities.

\item[DOS] There is a makefile for Borland Turbo C called Makefile.mak
  in the standard distribution.  This must be edited to select the
  appropriate compiler options before executing {\em make}\footnote{Be
    sure to delete or rename the unix make file ``Makefile'' since
    Turbo C ``make'' will attempt to execute this in preference to
    ``Makefile.mak''} Alternatively the programs may be built within
  the interactive environment.  Consult the makefile to find out which
  source files to link to build \moldy\ and the utilities.  Moldy has
  also been built using Watcom C\footnote{The author's experience of
    MS-DOS and Windows platforms is very limited.  I would very much
    welcome any reports from users on how to build \moldy\ in these
    environments for inclusion in future versions of this manual.}.

\end{description}

\subsection{XDR Dump and Restart}
As described in section~\ref{sec:xdr} binary restart and dump files
may be written and read in a portable way using the Sun XDR calls.
Since these are are not part of the ANSI C standard libraries, this
code is conditionally included by defining the C preprocessor macro
\texttt{USE\_XDR}.  Though non-standard, XDR is almost universally
available on unix operating systems, so the makefile defines this
by default, assuming the syntax of the compiler flag
\texttt{-DUSE\_XDR} to do so.  If the XDR headers and libraries are not
present on your system, then comment out the line reading
\texttt{XDR=-DUSE\_XDR} at the top of the Makefile to deactivate this
feature.  On certain systems (\eg\ older versions of SGI IRIX) it may
be necessary to include some additional library in the link, via the
\texttt{LDFLAGS} make macro.

\subsection{Parallel Version (Message Passing)}
\label{sec:spmdpar}
The parallel version of \moldy\ relies on an interface with a suitable
message-passing library.  This is the recommended version and
supersedes the ``shared-memory'' parallel implementation described in
section~\ref{sec:shmpar}.  The current release contains interfaces to
the MPI library\cite{mpi:94}, the TCGMSG library and the Oxford BSP
library.  MPI is the most recommended interface since it is the new
standard for message-passing libraries, and should become ubiquitous.
If none of these are installed on your machine, some public-domain
implementations are available for workstation clusters,
multiprocessors and many distributed-memory parallel machines.

\begin{description}
\raggedright
\item[MPI] The MPICH and CHIMP implementations can be fetched by
  anonymous ftp from the URLs 
  \texttt{ftp://info.mcs.anl.gov/pub/mpi/mpich} and
  \texttt{ftp://ftp.epcc.ad.ac.uk/pub/chimp/release}.
\item[TCGMSG] This may be obtained by anonymous ftp from
  \texttt{ftp://ftp.tcg.anl.gov/pub/tcgmsg/tcgmsg.4.04.tar.Z}.
\item[BSP] The Oxford BSP Library is available through Oxford
  Parallel's WWW server
  \texttt{http://www.comlab.ox.ac.uk/oucl/oxpara/bsplib1.htm} 
  or by anonymous ftp
  \texttt{ftp://ftp.comlab.ox.ac.uk/pub/Packages/BSP/bsp1.2.tar.Z}.
\end{description}

\noindent
Alternatively a port to another parallel interface should be quite
straightforward, see section\ref{sec:parport}.

Once a suitable message-passing library is installed the procedure for
building \moldy\ is quite simple.  The C preprocessor macro
\texttt{SPMD} must be defined as well as one of \texttt{MPI},
\texttt{TCG} or \texttt{BSP}. This is usually done in the make file by
setting the Make macro \texttt{PARLIBC=-DSPMD -DMPI} for example.
This macro should also include a \texttt{-I} directive specifying the
directory for the library's header files if these are not in the
default path searched by the compiler.  The similar make macro
\texttt{PARLIBL} should contain the linker directives necessary to
link to the library itself. Examples are provided at the top of the
supplied Makefile.

This parallel implementation makes use of the ``replicated data''
approach\cite{smith:91} whereby every processor has a complete copy of
all the arrays containing dynamical variables and every site on every
molecule.  The computation of the real-space potential and forces is
distributed over processors on the basis of link cells.  For the
reciprocal-space part of the Ewald sum, the $\bm{k}$-vectors are
distributed among processors.  This is an extremely efficient way of
implementing parallelism since the forces etc must be summed over
processors only once per timestep, thus minimising interprocessor
communication costs.  It is therefore possible to get considerable
speedup for a small number of workstations coupled by a fast network
such as an Ethernet.

The biggest disadvantage of the ``replicated data'' strategy is that
every processor must maintain a copy of all of the data, and therefore
that the memory requirement per processor increases with the size of
the system.   In many cases this is not a severe problem, as MD
memory requirements are not large compared with memory sizes of modern
computers.  However the poor scaling will eventually limit the number
of processors which may be used.  On a shared-memory multiprocessor,
the alternative parallel version in section~\ref{sec:shmpar} may
provide a solution, if it can be ported to that machine.

The memory limitation will be most acute when the goal is to simulate
an extremely large system on a massively parallel distributed-memory
computer where it is desirable to scale the system size with the
number of processors.  In such architectures the memory per processor
is usually a constant independent of the number of processors. But the
memory {\em per processor}\/ increases with system size.  Mostly the
scaling is linear, but reciprocal-space sum uses temporary arrays
whose size scales with the product of the number of sites and
$\bm{k}$-vectors, and hence with the square of the system size.

An alternative version of {\em ewald.c}\/ which implements the
reciprocal-space term of the Ewald sum by distributing over {\em
  sites}\/ rather than $\bm{k}$-vectors is included in the
distribution as {\em ewald-RIL.c}.  It is based on the RIL algorithm
of Smith~\cite{smith:92} and {\em distributes}\/ the temporary arrays
containing the $\cos(\bm{k}.\bm{r}_i)$ and $\sin(\bm{k}.\bm{r}_i)$ over
the nodes. In other words, each node only stores the terms involving
the $\bm{r}_i$'s to be considered on that node.  Since these arrays
are by far the largest users of memory there is a substantial decrease
in overall memory requirement.  Moreover the size per node now scales
{\em linearly}\/ with the number of $\bm{k}$-vectors and therefore
(assuming $\alpha$ is optimised), to the two-thirds power of the
number of sites.  These arrays will not therefore dominate the memory
requirement in the limit of large numbers of processors and system
size.  The disadvantage of the RIL scheme is that the partial sums of
$\cos(\bm{k}.\bm{r}_i)$ and $\sin(\bm{k}.\bm{r}_i)$ must be summed over
nodes separately for each $\bm{k}$-vector. Though the amount of data
transferred each time is small, the communication and inter-processor
synchronization is far more frequent than for the RKL scheme and the
parallelism becomes very fine-grained.  The upshot is that only
machines with very low communications latency can run this version
effectively.  Practical tests show that the communications overhead
completely negate any parallel gain on systems of networked
workstations and most multiprocessors.  However a significant speedup
is obtained on a Cray T3D, which is exactly the case where this
version is needed.

\subsection{Shared-Memory Parallel Version}
\label{sec:shmpar}
An alternative parallel version is available for shared-memory
multiprocessors with ``parallelising'' compilers.  This relies on the
compiler handling the multi-threading, synchronization and allocation
of local memory stacks for inner function calls. This requires
compiler-specific directives to be inserted in the code and is
therefore less portable than the distributed-memory version of the
previous section. (Note that that version works on this class of
machines too under the message-passing interface.) Nevertheless, it
works and has been run on Stardent, Convex and Cray computers.  It
consists of replacements for files ``force.c'' and ``ewald.c'' called
``force\_parallel.c'' and ``ewald\_parallel.c''. Then the program
should be compiled with the preprocessor macro\ texttt{PARALLEL}
defined ( not \texttt{SPMD} .)

The distributed-memory parallel version (section~\ref{sec:spmdpar}) is
generally recommended over this one.  However because the parallel
sections reference a single global copy of most of the arrays, the
shared-memory version uses much less memory.  This version may
therefore be of use if memory limits the size of the system on 
a multiprocessor machine.

% The approach taken is to retain the vectorized inner loops and
% parallelize the the outer loops, over cells for ``force.c'' and {\bf
% k} vectors for ``ewald.c''.  The two parallel loops are structured by
% the method developed by the Kingston group\cite{wojcik:85}. That is, a
% loop of the form
% \begin{verbatim}
%         for(i = 0; i < N; i++)
%            <body of loop>
% \end{verbatim}
% is transformed into
% \begin{verbatim}
%         for(processor = 0; processor < NPROCESSORS; processor++)
%            for(i = processor; i < N; i += NPROCESSORS)
%               <body of loop>
% \end{verbatim}
% so that the outer loop is over the number of available processors,
% and the inner loop has an increment of that number.  Note that this
% transformation reorders the loop iterations.
% 
% If the outer loop is to execute concurrently, each sub-process or
% thread must have local copies of any temporary variables, notably
% \texttt{i}.  Therefore the contents of each loop are isolated into a
% separate function. Each thread executes a separate incarnation
% of the function.  A shared-memory model is assumed, in which each
% thread accesses a single copy of the parameters and global
% variables, but has a unique copy of all of its local variables.
% 
% The ``master'' thread maintains separate copies of result variables
% and arrays, (\ie the forces, potential energy and stress virial) so
% that each incarnation of the function can write to its own copy
% without interference from other threads.  After all of the threads
% recombine, the separate copies are summed to give the final result of
% the calculation.  This method avoids the need for explicit
% synchronization between threads, but will add to the serial overhead
% on highly parallel machines.
% 
% The method of actually parallelizing the outer loop will vary from
% machine to machine. The stellar compiler is able to generate parallel
% code, and the directive \texttt{/*\$dir}~\texttt{no\_recurrence*/}
% instructs it to parallelize the following loop.  The Ardent, Convex
% and Cray compilers use \texttt{\#pragma} directives, namely
% \texttt{\#pragma ipdep}, \texttt{\#pragma \_CNX force\_parallel} and
% \texttt{\#pragma \_CRI taskloop} respectively.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Portability}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
A major goal in writing \moldy\ was that it be as portable as possible
between different computers  and operating systems.  It is  written in
the Kernighan and Ritchie\cite{kernighan:78} compatible subset of ANSI
C and assumes the library calls and header files  defined for a hosted
implementation of the  standard.  It  should therefore be possible  to
compile and run \moldy\ on any computer which has a good C compiler.

There are two possible sources of difficulty in moving \moldy\ to a
new machine. Though hosted ANSI standard C environments are now
commonly available it may still be necessary to compile \moldy\ using
a pre-ANSI compiler.  In that case some library functions and header
files may not be present. Secondly, to make good use of vector or
parallel architectures, compiler directives or calls to specialised
library functions are usually required.  Replacement ANSI library
functions are supplied in ``ansi.c'' for the VMS and unix (both
Berkeley and AT\&T system V varieties) operating systems.  Different
versions of a function are selected by the C preprocessor and
conditionally compiled according to the pre-defined preprocessor
symbols (see the documentation for your compiler).  For ease of
portability {\em all other system-dependent functions are in the
  module ``auxil.c''\/} and {\em all preprocessor conditionals are in
  the header file ``defs.h''}.

If the target machine has ANSI conformant C libraries, all that must
be done is to define the preprocessor symbol \texttt{ANSI\_LIBS}, either
in ``defs.h'' or by using a compiler option {\em e.g}.\
\texttt{-DANSI\_LIBS}.  This is done automatically in ``defs.h'' for
several machines known to have conformant environments.  If the target
operating system is the system V variant of UNIX, the preprocessor
symbol \texttt{USG} is defined automatically in ``defs.h''.  It is
possible that some environments may defeat the selection making it
necessary to define it by hand, either in ``defs.h'' or by setting
the compiler option \texttt{-DUSG} in the makefile. 

\subsection{System Dependencies}
In this section, details of system-dependent functions are described
for the major operating systems.
  \begin{description}
\item[Replacement ANSI header files]
 \begin{sloppypar}
   The ANSI header files ``string.h'', ``stdlib.h'', ``stddef.h'' and
   ``time.h'' are missing from Berkeley unix, or incomplete.
   Replacements are included which may be dispensed with on an ANSI
   conformant system - If the symbol \texttt{ANSI\_LIBS} is defined
   they simply include the system version.
 \end{sloppypar}

\item[Replacements for ANSI functions] \hspace*{1em}
\noindent 
  \begin{itemize}
  \item The ANSI function to delete a file, \texttt{remove()}, the
    signalling function \texttt{raise()} and the string functions
    \texttt{strstr()} and \texttt{strerror()} are missing from
    pre-ANSI libraries.  Replacements are supplied in ``ansi.c''.
  \item Replacements are provided in ``ansi.c'' for functions
    \texttt{memset()}, \texttt{memcpy()} and \texttt{strchr()} which
    are missing from Berkeley UNIX.
  \item The function \texttt{vprintf()} is often absent from older
    libraries. Replacements are provided which {\em a)\/} call the
    internal function \texttt{\_doprnt()} or {\em b)\/} implements a
    portable \texttt{vprintf()}.  Use the preprocessor macros
    \texttt{HAVE\_VPRINTF} or \texttt{HAVE\_DOPRNT} to select which.
  \end{itemize}
\item[Timing routines] The supplied \texttt{clock()} function on
  32-bit UNIX systems resets to zero after 36 minutes.  Replacements,
  called \texttt{cpu()} for both system V and Berkeley UNIXes and
  POSIX are supplied in ``auxil.c''.  The function \texttt{rt\_clock()}
  is also defined and returns the elapsed time in seconds.  For a
  non-unix system \texttt{cpu()} and \texttt{rt\_clock()} simply call
  the ANSI functions \texttt{clock()} and \texttt{time()}.
\item[File manipulation routines]
 ``Auxil.c'' contains the functions \texttt{replace()} and
  \texttt{purge()}.  \texttt{replace()} renames a file, making a
  backup of any existing file of that name. \texttt{purge()} removes
  the previous or backup version of a file.  These functions make use
  of the file name syntax of the host operating system and are
  therefore system-dependent.  Unix file systems do not have explicit
  version numbers but \moldy\ keeps a single previous version by
  appending a ``\%'' character to the name.  The pure ANSI versions
  just interface to \texttt{rename()} and do nothing respectively.
\end{description}

\subsection{Optimization and Vectorization}
\moldy\  has been designed to run fast on a wide range of computers, and
in particular on those with vector, multiprocessor and
parallel architectures.. This is a difficult
problem, since the constructs which run fast on different
architectures may be quite distinct and occasionally in conflict.
Nonetheless, it has been found that following a few basic rules gives
extremely good performance on a wide range of computer architectures.
In a rough order of importance these are:
\begin{enumerate}
\item Minimise the number of memory references to floating point data
  in critical loops.  Memory access is the major bottleneck on almost
  every modern computer, scalar, vector or parallel.
\item Minimise the number of memory references to floating point data
  in critical loops.  This cannot be emphasised enough.
\item Ensure that memory is accessed contiguously within critical
  loops. That is, arrays should be accessed with a stride of 1 and
  with the last index varying most rapidly\footnote{C uses the
    opposite convention to FORTRAN in storage layout of
    multidimensional arrays}.  This is absolutely critical on machines
  where memory is accessed via a cache, \ie\ all workstations and many
  parallel systems, and frequently very important on machines with
  interleaved memory (\ie\ most vector machines).
\item If the value of any array element is used more than once in a
  loop, write the loop using temporary scalars to store results and
  assign them to the arrays at the end of the loop. This allows the
  compiler to optimize memory references\footnote{Technically, the C
    standard treats arrays passed as formal function parameters as
    pointers which may not refer to disjoint areas of memory.  The
    compiler must therefore assume that if an array element is written
    in a loop then elements of any other arrays may also be changed.
    It must therefore reload from memory even though it already has a
    copy of the value in a register. But if all loads are completed
    before all stores then the compiler is at liberty to re-use the
    values and save memory accesses.}.
\item Minimise the floating-point operation count in critical loops.
\item Minimise integer arithmetic in critical code.  CRAY vector
  machines in particular have no integer multiplication hardware,
  and integer operations are slow as a result.
\end{enumerate}

The performance of \moldy\  has been carefully studied using profiling
tools, and all critical regions of code are written as efficiently
vectorizable loops.  

The most critical sections of code (\ie those which use the majority
of the computer time) are all to do with the site forces calculation.
Thus it is the inner loops in ``force.c'', ``ewald.c'' and
``kernel.c'' to which most attention should be paid.  The
pair-distance loop of \texttt{rdf\_calc()} in ``rdf.c'' should vectorize
for efficient radial distribution function evaluation. Others which
are of minor importance are in ``beeman.c'', ``matrix.c'',
``quaterns.c'' and ``algorith.c''.  ``Auxil.c'' contains alternative
versions of various sum, dot product, scatter and gather routines
\etc\ which are interfaces to machine-specific libraries \eg\
Cray scilib, Convex veclib (which usually have FORTRAN calling
conventions). There are also default versions coded in C which do
vectorize, for machines lacking specialist libraries as well as for
scalar computers.

\subsection{Optimization for Vector Architectures}
The program should, of course, be compiled with options specifying
vectorization.   Since highly
optimizing and vectorizing compilers frequently contain bugs, and
since some options generate ``unsafe'' optimizations, it may be
necessary to restrict the highest optimization level to those modules
which contain critical code.

To  allow  the compiler  to  generate   vector code, it must be
instructed to ignore apparent vector recurrences. The reason is
that the  run-time  dimensioned arrays necessary   to implement such a
flexible  program   must use   pointers as  their  base.    (See any C
textbook, \eg    Kernighan  and  Ritchie\cite{kernighan:78}    for  an
explanation of C pointers  and arrays.)  Unfortunately this means that
the  compiler  can not determine  that each iteration  of  the loop is
independent of the preceding iterations.  In the jargon of vectorizing
compilers, there may be a {\em vector dependency\/} or {\em
  recurrence}. The compiler can be notified that these are not genuine
recurrences either globally by use of a command-line directive or on a
per-loop basis using machine-specific compiler directives inserted into
the source.

Most compilers also have an option which directs it to ignore
recurrences throughout the whole program, \eg \texttt{-va} on the
Convex, \texttt{-va} and \texttt{-h ivdep} on the Cray compilers.  It
should normally be safe to use these options. Each manufacturer's
compiler has its own peculiar set of inline directives.  For example
the CRAY compilers use a \texttt{\#pragma}~\texttt{ivdep} statement
whereas the convex and Stellar compilers use a ``significant comment''
\texttt{/*\$dir no\_recurrence*/}\footnote{A mechanism is
  provided to insert appropriate directives using the C preprocessor.
  The text \texttt{VECTORIZE} has been placed before each loop which
  ought to be vectorized, and the file ``defs.h'' contains
  machine-conditional \texttt{\#define}s to replace it with the
  appropriate directive.  Currently directives for the CRAY, Stellar
  and Convex compilers are included, and null text is substituted for
  other machines.  Notice that in each case the substituted text is
  {\em not\/} the directive described in the manual, but rather that
  directive {\em after\/} it has been passed through the preprocessor.
  To determine what should be substituted on a new vector machine,
  create a small test containing the documented directive and use the
  C preprocessor on that file. The output will show the form that
  should be defined in ``defs.h''.
  
  Unfortunately this method had been obsoleted by the ANSI C standard,
  which makes it impossible to insert pragmas using the
  preprocessor. } 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Modifying Moldy}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Adding a New Potential}
\label{sec:newpot}
By default \moldy\  supports potential functions of the Lennard-Jones,
six-exp and MCY forms.  However it should be very easy to add further
types. The program is written in a highly modular fashion so that {\em
the only code which need be altered is in file ``kernel.c''\/} (and
occasionally in ``defs.h''). 

The calculation of the potential and forces is performed entirely in
the function \texttt{kernel()}.  This function is called repeatedly with
a vector of (squared) distances between some reference site and its
neighbour sites.  Vectors of potential parameters and charges are
supplied which bear a one to one correspondence with the elements of
the distance vector.  It calculates the corresponding values of
${dU(r_{ij})} \over {dr_{ij}}$ which it stores in \texttt{forceij[]}.
There are several variants of the force-calculation loop, one for each
kind of potential.  The potential type in use is passed as a parameter
to \texttt{kernel()} and is used in a \texttt{switch} statement to select
the appropriate code. 

To add a new potential the array of structs called \texttt{potspec[]}
must be extended.  The new array element should contain the name of
the new potential (against which, the names given in system
specification files will be matched) and the number of potential
parameters for each site pair\footnote{By default the arrays are sized
  for up to five parameters. If this is not sufficient, the limit is
  set by the value of the constant \texttt{NPOTP} defined in
  ``defs.h''}.  In parallel with \texttt{potspec[]}, the array
\texttt{pot\_dim[]} must also be updated with a new entry which
describes the dimensions of each parameter for the new potential. It
is used by the input routines to convert from the input units into
program units.  The entry consists of triplets containing the powers
of mass, length and time, one for each parameter.  Then define a new
preprocessor symbol to the index of the new type in the array
\texttt{potspec[]} (after the line
\texttt{\#define}~\texttt{MCYPOT}~\texttt{2}.  The value must
correspond to the index of the new entry in \texttt{potspec[]}
starting from 0 in accordance with the usual C convention.  This
constant should be used to define a new case in the \texttt{switch}
statement of \texttt{kernel()}, and this is where the code to evaluate
the potential goes.

The  existing  cases  may  be  used as  a    model, especially for the
evaluation of the electrostatic term $\erfc(\alpha r) / r$ which
is    evaluated  by  the   polynomial  expansion    of  Abramowitz and
Stegun\cite[section 7.1.26]{abramowitz:70}. There  are  currently {\em
two\/}   versions of each    loop,  the   second omitting this  term for
efficiency when  all the  electric  charges  are  zero  (which case is
flagged by a negative value of $\alpha$).

Finally, the distant potential correction for the new potential should
be added as a new case to function \texttt{dist\_pot()}. The code
should evaluate
\[
- \int^{\infty}_{r_c} r^2 U(r) \, dr
\]
for the potential $U(r)$.

\subsection{Porting the Parallel Version}
\label{sec:parport}
It should be relatively straightforward to port the distributed-memory
parallel version to a new message-passing library.  All of the
interface code is contained in {\em parallel.c}\/ and it will only be
necessary to modify this file.  A new port should declare a new
preprocessor macro along the lines of \texttt{MPI} \etc\ which should be
used to conditionally compile its code only.  Any header files may be
included in the appropriate place in {\em parallel.c}.  Then the
interface functions should be written to call the underlying message
passing library. These should again be conditionally compiled.  It
should be obvious where to place them in the file and the existing
versions will provide a model.  Their specifications are:

\begin{description}
\sloppy
\item[par\_sigintreset(void)] Moldy sets a handler for SIGINT\@.  This
  function is called from the signal handler to restore the default.
\item[par\_begin(int *argc, char ***argv, int *ithread, int
  *nthreads)] Initialize the library and return the number of
  processes and the ID of this process.
\item[par\_finish(void)] Terminate the parallel run normally.
\item[par\_abort(int code)] Terminate the run abnormally.  Return code
  if possible.
\item[par\_broadcast(void *buf, int n, size\_mt size, int ifrom)]
  Broadcast the specified buffer from node ifrom to all nodes.
\item[par\_\{r,d,i\}sum(void *buf, int n)] Perform a global parallel sum
  reduction on the buffer containing n reals\footnote{{\em real}\/ is a
    typedef defined in {\em defs.h}\/ which is set either to {\em
      float}\/ or {\em double}.  The code for \texttt{par\_rsum} must
    handle either case, which may be tested using the \texttt{sizeof}
    operator. For example the preprocessor macro 
    \texttt{\#define M\_REAL
      (sizeof(real)==sizeof(double)?MPI\_DOUBLE:MPI\_FLOAT)} is used
    to determine which constant to pass to the MPI sum function.},
  doubles or ints.
\item[par\_imax(int *idat)] Perform a global "maximum" reduction on
  the single int argument.
\fussy
\end{description}

\appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Example System Specifications}  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:examples}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Argon}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{verbatim}
# LJ Argon - about as simple as you can get
# Parameters from Allen and Tildesley Table 1.1
Argon 108
1          0           0          0    39.948 0 Ar
end
Lennard-Jones
1 1 3.984 3.41
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{TIPS2 Water}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This is the four-site water model of Jorgenson\cite{jorgensen:82}.  
Only the oxygen site interacts via the Lennard-Jones
potential, and the charge site, M, is displaced 0.15\AA\ from the Oxygen.
\begin{verbatim}
# Modified TIPS2 water
Water 64
1          0            0          0 16    0 O
2  0.7569503            0 -0.5858822 1 0.535 H
2 -0.7569503            0 -0.5858822
3          0            0      -0.15 0 -1.07 M
end
lennard-jones
1 1 0.51799  3.2407
end
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Aqueous MgCl$_2$ Solution}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This is a three-component system consisting of MCY
water\cite{matsuoka:75}, Magnesium and Chloride ions.  The Mg$^{2+}$
potential was fitted to the SCF calculations of Dietz and
Heinzinger\cite{dietz:82} and the Cl$^-$ to the calculations of
Kistenmacher, Popkie and Clementi\cite{kistenmacher:73b}.  Note that
the potential parameters are expressed in kcal mol$^{-1}$, and the
control file must set the parameter \texttt{time-unit=4.8888213e-14}.
\begin{verbatim}
# MCY Water/ Mg2+ / Cl - solution
Water 200
1          0            0          0 16    0 O
2  0.7569503            0 -0.5858822 1     0.717484 H
2 -0.7569503            0 -0.5858822
3          0            0    -0.2677 0 -1.434968 M
Magnesium 4
4          0            0          0 24.31 2 Mg2+
Chloride  8
5          0            0          0 35.45 -1 Cl-
end
MCY
1 1 1088213.2   5.152712        0               0
1 2 1455.427    2.961895        273.5954        2.233264
2 2 666.3373    2.760844        0               0
1 4 47750.0     3.836           546.3           1.253 # New values of Mg potl
2 4 111.0       1.06            0               1.0   
1 5 198855.0    3.910           0               0
2 5 1857.0      2.408           77.94           1.369
4 5 28325.5     2.65            0               0
end
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Quartz}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{verbatim}
# Quartz parameters from Van Beest, Kramer and Van Santen
# Physical Review Letters 64,(16) p1955 (1990)
# Units are eV, A, el chg. so time-unit=1.0181e-14
Oxygen 384
1       0       0       0       16      -1.2    O
Silicon 192
2       0       0       0       28.0855 2.4     Si
end
buckingham
1 1     175.0000        1388.7730       2.76000
1 2     133.5381        18003.7572      4.87318
2 2     0.0             0.0             0.0
end
4.903 4.903 5.393 90 90 120 4 4 4
Oxygen   0.415000     0.272000     0.120000
Oxygen   0.857000     0.5850000    0.453300
Oxygen   0.728000     0.143000     0.453300
Oxygen   0.143000     0.728000     0.880000
Oxygen   0.272000     0.415000     0.546700
Oxygen   0.5850000    0.857000     0.213300
Silicon  0.465000     0            0
Silicon  0.535000     0.535000     0.333300
Silicon  0            0.465000     0.666700
end
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Organization of Moldy} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data Structures}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:structs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Control Flow}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Utility Programs} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Five utility programs are included in the \moldy\ package, mostly for
manipulation and analysis of dump data (see section~\ref{sec:dumping}).
They are easily compiled on unix systems using the makefile: the
command is ``\texttt{make}~{\em progname\/}'' for each program or
``\texttt{make utilities}'' to make the lot.  Apart from {\em mdshak\/}
which must be linked with several modules from \moldy\ itself they are
all self-contained in a single source file.  They are written with
unix systems in mind using unix-style option arguments, but ought to
compile and run under VMS if defined as foreign commands.

Since several of them require you to specify lists of (integer)
numbers, for example selected molecules, timeslices \etc\ they share a
common syntax for these options.  For example the command-line
argument \mbox{\texttt{-t 1,5,17-20,34-100:10}} selects numbers 1, 5, 17 to 20
inclusive and 34,44,54\ldots.  Selectors are separated by commas and
each one may be a range separated by a hyphen with an optional
increment following a colon.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Moldyext}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
It is usual to plot the instantaneous values of energy, temperature
\etc\ during the course of a simulation, for example to monitor the
approach to equilibrium.  {\em Moldyext\/} processes the periodic
output produced by \moldy\ (see section~\ref{sec:output}) and extracts
this information from each timestep recorded.  It is presented in
tabular form for input into plotting programs.  The command is
\begin{center}
\texttt{moldyext -f} {\em fields output-file1 output-file2} \ldots
\end{center}
where {\em fields\/} is a list in the selector format above.  The
numbering runs from left to right, ignoring newlines and blank columns
so that the translational KEs in figure~\ref{fig:output} are fields 1
and 14 and the $\sigma_{zz}$ component of the stress tensor is 30.

{\em Moldyext\/} can currently only extract information from the
``instantaneous'' section of the output, not the rolling averages or
standard deviations.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dumpanal}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{\em Dumpanal\/} examines the dump files given as arguments and
prints out the header information to help with identification. For
example
\begin{center}
\texttt{dumpanal} {\em dump-file1 dump-file2} \ldots
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dumpconv}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:dumpconv}
{\em Dumpconv\/} is a tool for moving binary dump files between
computers of different architectures.  It has mostly been superseded
by the portable XDR format dump files introduced in version~2.1 (see
section~\ref{sec:xdr}) but is retained in case of machines for which
no XDR implementation is available.  The command
\begin{center}
\texttt{dumpconv} {\em binary-dump-file text-dump-file} 
\end{center}
creates a straightforward ASCII text file with a representation of the
dump information in the binary file including the header.  The command
\begin{center}
\texttt{dumpconv -d} {\em text-dump-file binary-dump-file} 
\end{center}
converts it back.  Seven significant decimals are used which ought to
retain almost all of the precision of the single precision binary
floating-point numbers.  You can also convert an old ``native'' format
dump into XDR format using the \texttt{-x} option, {\em viz\/}
\begin{center}
\texttt{dumpconv -x} {\em native-dump-file xdr-dump-file}. 
\end{center}
The \texttt{-x} and \texttt{-d} options may be combined if the input is a
text format dump.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dumpext}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Dumps are designed so that \moldy\ can take care of all the
bookkeeping, perform data security checks and to divide a lot of data
into manageable portions.  It is therefore not in a convenient form
for reading by other programs, especially FORTRAN ones.  {\em
Dumpext\/} is a program which processes dump files, extracts a
subset of the information and outputs it in a form more suitable for
reading by other programs.  It is invoked with the command:
\begin{center}
\texttt{dumpext -R} {\em nmols\/} \texttt{-Q} {\em nquats\/} 
\texttt{-c} {\em components\/}
\texttt{[-t} {\em timeslices\/} \texttt{]} \\
\texttt{[-m} {\em molecules\/} \texttt{]}
\texttt{[-o} {\em output-file} \texttt{]}
\texttt{[-b]} 
{\em dump-file1 dump-file2} \ldots
\end{center}
The meanings of its arguments are
\newcommand{\boldlabel}[1]{{\bf #1 \hfil}}
\begin{list}{}{\let\makelabel\boldlabel\itemsep=0pt\parsep=3pt\leftmargin=1.5cm}
\item[-R] the total number of molecules.  This argument is compulsory.
\item[-Q] the number of polyatomic molecules.  This argument is compulsory.
\item[-c] which pieces (``components'') of the information in dump
record to extract.  This is a selector-format list and may list any
combination of
\begin{enumerate}
\itemsep=0pt
\parskip=0pt
\item C of M positions
\item quaternions
\item unit cell matrix
\item potential energy
\item C of M velocities
\item quaternion derivatives
\item unit cell velocities
\item C of M accelerations
\item quaternion accelerations
\item unit cell accelerations
\item C of M forces
\item torques
\item stress tensor
\end{enumerate}
This argument is compulsory.
\item[-t] which timeslices (or dump records) to extract.  This is a
selector format list and is the index in the whole dump sequence, not
just a single file.  Timeslices or dump records are sequentially
numbered in the dump files from 1.  Defaults to all timeslices.
\item[-m] extract information for selected molecules.  This is a
selector list specifying the molecule index.  Defaults to all
molecules.
\item[-o] name of optional output file.  Defaults to standard output.
\item[-b] selects binary output in single-precision floating point
numbers. Defaults to ASCII formatted numbers.
\end{list}
If any of the compulsory arguments are omitted, you will be prompted
to supply a value.  In particular you must {\em always\/} supply the
number of molecules and polyatomic molecules.  (This information is
not recorded in the dump header and is needed to determine the number
of co-ordinates and quaternions in each dump record.)  You must
specify which pieces of information to extract using the \texttt{-c}
option.

The dump files must, of course, be part of the same dump sequence;
this is carefully checked.  They may be supplied as arguments in any
order; {\em dumpext\/} automatically determines the sequence from
the information in the headers.  This is not as pointless as it sounds,
since the list may be generated using unix shell wildcards which arrange
them in alphabetical rather than numeric order.

The output is arranged in columns, one line per time slice.  So if,
for example you wish to extract positions and quaternions there will
be 7 columns corresponding to $x,y,z,q_0,q_1,q_2,q_3$. Multiple
components are printed in the integer order of the component, {\bf
not} the order specified with \texttt{-c}. If binary output is asked for
with the \texttt{-b} option the order is the same. The numbers are
written sequentially as single-precision floating-point numbers (in
machine native format) without record delimiters.  The records may be
easily read in C with an
\texttt{fread()} call with the appropriate number of bytes or from
FORTRAN77 using direct-access unformatted read\footnote{The usual
FORTRAN sequential unformatted read is not suitable as this expects
record size information to be present.  {\em Dumpext\/} can not
write this as its format is entirely determined by the whim of the
compiler writer.  FORTRAN unformatted sequential files are not
guaranteed to be portable even between different compilers on the same
machine.} of the appropriate length records\footnote{Be aware that the
FORTRAN77 standard does not guarantee what units the record length is
specified in.  Predictably some manufacturers' compilers use bytes and
others words.  Consult the documentation!}
\texttt{OPEN(\ldots,ACCESS=DIRECT,LRECL=nnn)}.  In the above example there are
$3 \times 4 + 4 \times 4 = 28$ bytes in each record.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mdshak}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{\em Mdshak\/} was written as an interface between \moldy\ configurations
and a molecular graphics program called SCHAKAL\cite{schakal:88}.  The
output format is sufficiently transparent that it should not be hard
to modify it for any other molecular graphics package.  Note also that
a SCHAKAL file viewer called ``read\_shak'' written by the author for
use with AVS, the general purpose visualization program, is available
free from the International AVS Center\footnote{It may be obtained
using anonymous ftp from \texttt{avs.ncsc.org} or by writing to The
International AVS Center, PO Box 12889, 3021 Cornwallis Road, RTP, NC
27709, USA.}

{\em Mdshak\/} writes a SCHAKAL file containing the co-ordinates of a
single or of multiple time slices during a MD run.  It can read
configurations from ({\em a\/}) a system specification file plus
lattice start,  ({\em b\/}) a system specification file plus
dump file ({\em c\/}) a restart file or ({\em d\/}) a restart file
plus dump file.   It can be driven either interactively or using
command-line arguments.  

In interactive mode you are prompted for the source of the system
specification (sys-spec or restart file) and the configurational
information (restart or dump file).  But you must either redirect the
output (using \texttt{>} on unix) or specify an output file with
\texttt{-o} or the output will go to the screen!

Alternatively, the command line options are
\begin{center}
\texttt{mdshak}
\texttt{[-s} {\em system-specification\/} \texttt{]|}% 
\texttt{[-r} {\em restart-file\/} \texttt{]}
\texttt{[-d} {\em dump-file-format\/} \texttt{]}
\texttt{[-n} {\em dump-range\/} \texttt{]} \\
\texttt{[-c]}
\texttt{[-i} {\em extra-text\/} \texttt{]}
\texttt{[-o} {\em output-file} \texttt{]}
\end{center}
where the meanings of the options are
\begin{list}{}{\let\makelabel\boldlabel\itemsep=0pt\parsep=3pt\leftmargin=1.5cm}
\item[-s] read a system specification file
\item[-r] read a restart file.  Only one of \texttt{-s} or \texttt{-r} may
be given.
\item[-c] if reading a system specification file, skip any preceding
control parameter info.
\item[-d] read the configurational information from a dump file.  The
argument is a dump prototype name containing a \texttt{printf()} format
string -- see section~\ref{sec:dumping}.
\item[-n] range of records in dump file, specified in ``selector''
format.
\item[-i]   this inserts its argument into the output file and is used
to add extra SCHAKAL commands, such as BOX.
\end{list}

{\em Mdshak\/} may be useful for more than just visualization purposes
as it extracts atomic co-ordinates from the system specification,
positions and quaternions.  It is written so that only the output routine
(called \texttt{schakal\_out()}) is SCHAKAL specific.  This is quite
short and can easily be replaced with one tailored to a different
purpose.

\bibliography{simulation,mypubs}
\bibliographystyle{unsrt}

\end{document}
