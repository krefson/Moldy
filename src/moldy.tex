%Molecular DYnamics simulation code, Moldy.
%Copyright (C) 1988, 1992, 1993 Keith Refson
% 
%This program is free software; you can redistribute it and/or modify it
%under the terms of the GNU General Public License as published by the
%Free Software Foundation; either version 2, or (at your option) any
%later version.
% 
%This program is distributed in the hope that it will be useful,
%but WITHOUT ANY WARRANTY; without even the implied warranty of
%MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%GNU General Public License for more details.
% 
%You should have received a copy of the GNU General Public License
%along with this program; if not, write to the Free Software
%Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
% 
%In other words, you are welcome to use, share and improve this program.
%You are forbidden to forbid anyone else to use, share and improve
%what you give them.   Help stamp out software-hoarding!  */
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%% This document requires LaTeX2e to format it and it will %%%%%%%%%
%%%%%% not run under obsolete (LaTeX 2.09) installations.      %%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,twoside]{report}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%tth: \input moldy.sty
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% Use Times-Roman fonts. This works for PSNFSS Latex2e%%%%%%%%
%%%%%%%%%%% mode.  Just comment it out if it doesn't work       %%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\usepackage{pslatex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% Not essential, except that it MUST be used with pslatex %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\usepackage[T1]{fontenc}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% Use the "geometry" package to set page layout.      %%%%%%%%
%%%%%%%%%%% Hard coded params are given as comments below if nec. %%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{geometry}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%% Dimensions and settings                                %%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\geometry{body={160mm,230mm},top=40mm,nohead}
% This gives the following settings on A4 paper.  For printing
% on US letter size, re-enable the \geometry and its \usepackage
%\textwidth  455.24408pt
%\textheight 654.41338pt
%\oddsidemargin  18.86191pt
%\evensidemargin -21.13809pt
%\topmargin  41.54103pt
%\headheight 0.0pt
%\headsep    0.0pt
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% Needed for table 3.1.  If you get rid of it          %%%%%%%
%%%%%%%%%%% edit the tabular header to excise the >{} descriptor.%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{array}
\usepackage{longtable}
\usepackage{afterpage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% For {\textdegree} etc.                                %%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{textcomp}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% Prettifies some script letters.  Omit if necessary. %%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[mathcal]{eucal}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% Postscript figure inclusion.  Epsfig is part of the %%%%%%%%
%%%%%%%%%%% "graphics" bundle.  Install it if necessary.        %%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% Eepic graphics work well if you don't have PostScript
%%%%%%%%%%% but you DO have a graphics driver which supports the
%%%%%%%%%%% "tpic" \special's, (iptex,dviis).  Even if you don't
%%%%%%%%%%% you can use the "eepicemu" package at a pinch but the
%%%%%%%%%%% quality is poor.  
%%%%%%%%%%%   To use it, rename the eepic figures "fig_*-eepic.ftx"
%%%%%%%%%%% to "fig_*.ftx" and then run latex.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%\usepackage{epic}             % For eepic or eepicemu
%%\usepackage{eepic}            % Tpic specials *or*
%%%%\usepackage{eepicemu}       % No special support.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% Bold math symbols.  The 'bm' package, new with teTeX 0.9
%%%%%%%%%%% does this  *right*. Otherwise use \mathbf, but you won't
%%%%%%%%%%% get bold greek or symbols. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%begin{latexonly}
\typeout{^^JAttention - if the ``bm'' Package isn't installed you will
  get an error here.^^JJust hit <ret> and continue. (Bold math won't
  work quite as well).}
\usepackage{bm}
%end{latexonly}
\providecommand{\bm}[1]{\mathbf{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% This defines the \sideset{} macro as a replacement for
%%%%%%%%%%% the AMS version plus the superfig/partfigure environments.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% Specific customized macros for abstracting physical   %%%%%%
%%%%%%%%%%%  font changes.                                        %%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{moldy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%% Hyperref is useful for including hypertext links.   %%%%%%%%
%%%%%%%%%%% Useful options to the package are                   %%%%%%%%
%%%%%%%%%%% [hypertex] - for xdvi.  (Need xhdvik)               %%%%%%%%
%%%%%%%%%%% [pdfmark]  - tp process ps file with distiller to pdf %%%%%%
%%%%%%%%%%% [pdftex] for direct conversion to pdf using pdftex  %%%%%%%%
%%%%%%%%%%% No option defaults to ``hypertex'' using LaTeX and  %%%%%%%%
%%%%%%%%%%% ``pdftex'' using pdflatex.                          %%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{url}
%
% Uncomment this for LaTeX2html translation
%
%\usepackage{html}
%
% Comment this out for LaTeX2html translation
%
\usepackage[breaklinks]{hyperref}
%begin{latexonly}
\providecommand{\htmladdnormallink}[2]{#1}
%end{latexonly}

\renewcommand{\topfraction}{0.9}
\renewcommand{\textfraction}{0.1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Useful shorthand macros                               %%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\moldy}{\emph{Moldy}}
\newcommand{\etc}{\emph{etc.}}
\newcommand{\eg}{\emph{e.g.}}
\newcommand{\ie}{\emph{i.e.}}
\newcommand{\cf}{\emph{c.f.}}
\newcommand{\erf}{\mbox{erf}}
\newcommand{\erfc}{\mbox{erfc}}
\newcommand{\insqrt}{\sqrt{\mathstrut}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Hyphenation                                         %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hyphenation{algo-rithm time-slice time-slices}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% RCS Emulation stuff                                 %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\RCSrevision}{$ $Revision: 2.33 $ $}
\newcommand{\moldyversion}{2.16}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%% Document front matter/titlepage stuff               %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Moldy User's Manual}
\author{Keith Refson\\Department of Earth Sciences\\Parks Road
\\Oxford OX1 3PR\\
\htmladdnormallink{Keith.Refson@earth.ox.ac.uk}{mailto:Keith.Refson@earth.ox.ac.uk}\\}
\version{\RCSrevision for release \moldyversion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{document}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\pagenumbering{roman}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\pagenumbering{roman}
\maketitle
\thispagestyle{empty}

Copyright \copyright\ 1988, 1993--1996 Keith Refson.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The initial implementation of the Nos\'{e}-Hoover and Gaussian
thermostats was by Vladimir Murashov at Dalhousie University.
Rafael R. Pappalardo contributed the modifications to ``mdshak'' to
write XYZ format molecular graphics files. Craig Fisher contributed
the ``msd'', ``mdavpos'', ``bdist'', ``mdbond'', ``ransub'' and 
``syswrite'' programs.

Thanks are due to Craig Fisher and Jos\'{e} Manuel Martinez Fernandez
for diligent proofreading of several versions of the manual and many
helpful suggestions on how to improve it.  Any mistakes that remain are
my own.

\cleardoublepage
\setcounter{page}{1}
\tableofcontents
\listoftables
\listoffigures

\cleardoublepage
\pagenumbering{arabic}
\setcounter{page}{1}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\moldy\ is a computer program for performing molecular dynamics
simulations of condensed matter.  It can handle any assembly of rigid
polyatomic molecules, atoms or ions and any mixture thereof. It uses
the `link cell' method to calculate short-range forces and the Ewald
sum technique to handle long-range electrostatic forces.  Simulations
may be performed either in the usual $NVE$ ensemble or in $NVT$,
$N\sigma H$ or $N\sigma T$ ensembles using Nos{\'e}-Hoover thermostat and
Parrinello and Rahman constant-stress methods. As the MD cell need not
be cubic, the program is equally suitable for simulations of solids
and liquids.

Most existing MD programs are limited in their capabilities, for
example to one kind of potential function, or molecular symmetry, or
to some restricted number of molecules.  \moldy\  is (as far as
possible) free from such arbitrary constraints.  The system is
specified at the beginning of each run and its size is only limited by
the amount of memory available to the program: if a system is too
large to handle, the solution is to buy some more memory.  The system
may contain a mixture of an arbitrary number of molecular species,
each with an arbitrary number of atoms and an arbitrary number of
molecules of each. Molecules or ions may be monatomic or polyatomic,
linear or three dimensional in any combination.  The potential
functions may be of the Lennard-Jones, Buckingham (including
Born-Mayer) or MCY types, and other potential types may be easily
added.  Such flexibility is possible because \moldy\  is written in the
`C' language which permits dynamic memory allocation.

\moldy\  is written to be highly portable and has been tested on a wide
range of computers and operating systems, including VAX/VMS,
MS-DOS and Unix\footnote{Goodness knows who will own the Unix
registered trademark by the time you read this.}  (both BSD and system V
varieties).  It should be straightforward to move it to any other
machine with a good `C' compiler.

To be of real use a simulation  program must run efficiently on modern
high-speed computers, which  are  increasingly of vector   or parallel
architectures.  \moldy\  is written so  as to be highly vectorizable and
has been  tested on a   range of  vector machines  from  manufacturers
including Cray, Convex, Stardent and  Alliant.  On the cray XMP-48 its
performance can exceed 100 MFlop/sec (on a suitably large  system).
\moldy\ is also able to run on a parallel computer of either shared or
distributed memory architectures, and has been tested on
multiprocessors from Stardent, Convex, Cray Research, SGI and IBM SP1
and Cray Research T3D massively parallel machines.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Terms and Conditions}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Permission to compile and run \moldy\ is granted to any individual or
organization without restriction.  This program is distributed in the
hope that it will be useful, but WITHOUT ANY WARRANTY; without even
the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE\@.  See the GNU General Public License for more details.

\moldy\ is free software; you may redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.  The terms of the GNU General Public License are
described in the file \Fname{COPYING} which is included with the
source distribution, or from the Free Software Foundation, 675 Mass
Ave, Cambridge, MA 02139, USA.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Algorithms and Equations}  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

This chapter  describes the implementation  of the  molecular dynamics
technique as used in \moldy.  It is not intended as an introduction to
MD  simulations, and  does assume some    familiarity  with the  basic
concepts of microscopic models  and simulations thereof.  The book  by
Allen and Tildesley\cite{allen:87}  is a  very good    introductory text,
covering   both the  theory  and  the  practicalities and  is   highly
recommended.  It   also  contains   comprehensive  references  to  the
scientific literature of microscopic computer simulation.

\moldy\  is designed to simulate a common class of models of atomic or
molecular systems. The assumptions are: that the system is an assembly
of  \emph{rigid   molecules},  atoms   or  ions;  that  the  forces  of
interaction are derived   from \emph{continuous  potential  functions}
acting between (usually atomic) \emph{sites} on each molecule; that the
dynamics are governed by the \emph{classical} Newton-Euler equations of
motion.  A major aim of \moldy\ has been to allow the most  general of
models within that class and to impose as few restrictions as possible.
In particular arbitrary mixtures of different molecules are allowed
and several popular forms of potential functions are catered for.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Equations of Motion}  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
If we denote the force exerted by atom $\alpha$ of molecule $i$ on
atom $\beta$ of molecule $j$ by $\bm{f}_{i\alpha j\beta}$\footnote{A
comment on notation is appropriate here.  In this chapter, site
quantities are denoted by \emph{lowercase} letters, molecular
quantities by \emph{uppercase}, sites are indexed by \emph{greek}
letters and molecules by \emph{roman}. A missing index denotes a sum
over the corresponding sites or molecules so that, for example
$\bm{r}_{i\alpha j\beta}$ is a site-site vector and $\bm{F}_{ij}$ the
molecule-molecule force.}  then the total force acting on molecule $i$
is
\begin{equation}
\label{eqn:comf}
\bm{F}_i = \sum_j \sum_\beta \sum_\alpha \bm{f}_{i\alpha j\beta}
\end{equation}
and the torque is given by
\begin{equation}
\label{eqn:comt}
\bm{N}_i = \sum_\alpha (\bm{r}_{i \alpha} - \bm{R}_{i}) 
\times\bm{f}_{i\alpha} 
\end{equation}
where $\bm{R}_{i} = 1/M_i \sum_\alpha
m_{i\alpha} \bm{r}_{i\alpha}$ is the centre of mass of molecule $i$.

The motion is governed by the Newton-Euler equations
\begin{equation}
M_i\ddot{\bm{R}}_i = \bm{F}_i \label{eqn:newton}
\end{equation}
\begin{equation}
  \bm{I}_i \cdot \dot{\bm{\omega}}_i - \bm{\omega}_i \times \bm{I}_i
  \cdot \bm{\omega}_i = \bm{N}_i \label{eqn:euler}
\end{equation}
where  $\bm{\omega}_i$ is the angular velocity of the molecule, 
$ \bm{I}_i = \sum_{\alpha} m_{i\alpha} 
( p_{i\alpha}^2 \bm{1} - \bm{p}_{i\alpha}\bm{p}_{i\alpha} ) $ 
is the inertia tensor and 
$\bm{p}_{i\alpha} = \bm{r}_{i\alpha} - \bm{R}_i $
is the atomic site co-ordinate relative to the molecular centre of mass.

% Quaternions
\label{sec:quaternions}
The orientations of the molecules are represented by \emph{quaternions}
as  has now  become common  practice.   They are  preferred over Euler
angles for two reasons. Firstly they lead to equations of motion which
are  free  of singularities\cite{evans:77} which   means  that   no
special-case  code is required. This  leads to much improved numerical
stability      of  the  simulation\cite{evans:77b}.   Secondly,
molecular symmetry   operations   and  combinations of  rotations  are
elegantly expressed   in    terms  of     a     simple      quaternion
algebra\cite{evans:77b,pawley:85b}.

A quaternion  is an ordered number  quartet  which obeys  the  algebra
given  by   Pawley\cite{pawley:81}.  The multiplication   rule in that
reference may be restated as a matrix product treating each quaternion
as a  4-vector.  If  $\Quat{p} \equiv (p_0,p_1,p_2,p_3)$ and  $\Quat{q}
\equiv  (q_0,q_1,q_2,q_3)$  are quaternions then
\begin{equation}
\Quat{pq} = 
\left(
\begin{array}{rrrr}
p_0 & -p_1 & -p_2 & -p_3 \\
p_1 &  p_0 & -p_3 &  p_2 \\
p_2 &  p_3 &  p_0 & -p_1 \\
p_3 & -p_2 &  p_1 &  p_0 
\end{array}
\right) \left(
\begin{array}{r}
q_0 \\ q_1 \\ q_2 \\ q_3
\end{array}
\right)
\end{equation}
The quaternion $ \Quat{\tilde{q}} $ conjugate to $\Quat{q}$ is defined
as $\Quat{\tilde{q}} = (q_0,-q_1,-q_2,-q_3)$ so that
\begin{equation}
\Quat{q\tilde{q}} = (q_0^2+q_1^2+q_2^2+q_3^2,0,0,0).
\label{eqn:qnorm}
\end{equation}
The \emph{norm} is defined as $ |\Quat{q}| \equiv
\sqrt{q_0^2+q_1^2+q_2^2+q_3^2} $ and $\Quat{q}$ is called a
\emph{unit} quaternion if $ |\Quat{q}| = 1 $.  Any possible rotation
can be represented by a unit quaternion. Du Val shows\cite{duval:64}
that if $ \Quat{q} \! = \! (\cos \frac{\alpha}{2}, \bm{l} \sin
\frac{\alpha}{2}) $ (where we have combined the last three components
to form a 3-vector) and $\Quat{p} = (0,\bm{r})$ then the operation
\begin{equation}
\Quat{p'} \equiv (0,\bm{r'}) = \Quat{q p \tilde{q}}
\end{equation}
corresponds to a rotation of the vector $\bm{r}$ by an angle of
$\alpha$ about the axis $\bm{l}$.  The components may also be
expressed in terms of the Euler angles as\footnote{The definition of
  quaternions used here differs from that used in Evans'
  paper\cite[equation 21]{evans:77} in the sign of $q_2$ or $\xi$.
  This error has been compounded by subsequent
  authors\cite{sonnenschein:85,smith:82,laakonsen:85} who also managed
  to permute the components which means that the parameters do not
  form an ordered number quartet which obeys quaternion algebra. Like
  Allen and Tildesley\cite[page 88]{allen:87} we follow the definition
  of Goldstein\cite[pages 143 and 155]{goldstein:80}.}
\begin{eqnarray}
q_0 & = & \cos \frac{\phi+\psi}{2} \cos \frac{\theta}{2} \nonumber \\
q_1 & = & \sin \frac{\phi-\psi}{2} \sin \frac{\theta}{2} \nonumber \\
q_2 & = & \cos \frac{\phi-\psi}{2} \sin \frac{\theta}{2} \nonumber \\
q_3 & = & \sin \frac{\phi+\psi}{2} \cos \frac{\theta}{2}.
\label{eqn:qeuler}
\end{eqnarray}

The relationship between the time derivative of a quaternion and the
principal frame angular velocity was given by Evans\cite[Equation
27]{evans:77} and rewritten using quaternion algebra by 
Refson\cite{refson:87a} as
\begin{equation}
2 \Quat{\dot{q}} = \Quat{q}(0,\bm{\omega}^p)
\label{eqn:qomega}
\end{equation}
The second derivative is given by
\begin{eqnarray}
\nonumber
2\Quat{\ddot{q}} & = & \Quat{q}(- 1/2 (\omega^p)^2,\dot{\bm{\omega}}^p) \\
 & = & \Quat{q}(-2 |\Quat{\dot{q}}|^2,\dot{\bm{\omega}}^p)
\label{eqn:qddot}
\end{eqnarray}
Equations~\ref{eqn:qddot} and~\ref{eqn:euler} allow the simulation to
be implemented using quaternions and their derivatives as the dynamic
variables for rotational motion, and this is the method employed in
\moldy.  This second order formulation was first used by Powles \emph{et
al}.\cite{powles:79} and Sonnenschein showed\cite{sonnenschein:85}
that it gives substantially better stability than if angular
velocities and accelerations are used as dynamic variables.
 
Using equations~\ref{eqn:qddot} to describe the dynamics means that
they are integrated as if all four components were independent.
Therefore the normalization condition $\Quat{q \tilde{q}} = \Quat{1}$
may not be exactly satisfied after performing an integration step.
\moldy\ adopts the usual practice of scaling all components of the
quaternion after each timestep to satisfy the normalization
condition\cite{evans:77b}.

It is less widely realized that the second order equations
(\ref{eqn:qddot}) introduce a \emph{second} unconstrained variable
into the procedure.  Differentiating equation~\ref{eqn:qnorm} gives a
constraint on the quaternion derivatives
\begin{equation}
q_0\dot{q_0} + q_1\dot{q_1} + q_2\dot{q_2} + q_3\dot{q_3} = 0
\label{eqn:qconst} 
\end{equation}
which is just the $q_0$ component of equation~\ref{eqn:qomega}.
Just as with the normalization condition, the integration algorithm
will not preserve this condition exactly unless explicit measures are
taken.  After each timestep the constraint may be re-established by
subtracting the discrepancy from the quaternion derivatives.  If
$\delta = q_0\dot{q_0} + q_1\dot{q_1} + q_2\dot{q_2} + q_3\dot{q_3}$
then the corrected quaternion derivatives are given by
\begin{equation}
\Quat{\dot{q}^\prime } =  \Quat{\dot{q}} - \delta \Quat{q}.
\label{eqn:qconcorr}
\end{equation}
Experiments conducted while developing \moldy\ show that enforcing
this constraint significantly decreases the fluctuations in the total
energy. 

Linear molecules are a slightly special case as the moment of inertia
about the molecular axis is zero.  Though there are unique methods to
represent this situation\cite[page 90]{allen:87} \moldy\ uses a minor
modification of the quaternion algorithm.  All that is necessary is a
little special-case code to avoid dividing by the zero component of
inertia in the solution of equation~\ref{eqn:euler} and to hold the
components of angular velocity and acceleration about the molecular
axis to zero.  This has the considerable advantage of uniform
treatment of all kinds of molecules which is convenient when dealing
with heterogeneous mixtures.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Integration Algorithms}   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:beeman}

The dynamical equations~\ref{eqn:newton} and~\ref{eqn:euler} are
integrated using this author's modification\cite{refson:85} of the
Beeman algorithm\hspace{0pt}\cite{beeman:76}.  For atomic systems the
accuracy is of the same order as the commonly used Verlet
algorithm\cite{verlet:67}.

The accuracy of common integration algorithms was discussed by
Rodger\cite{rodger:89} who showed that the Beeman algorithm is the
most accurate of the supposedly ``Verlet-equivalent'' algorithms. The
Beeman algorithm is the only one accurate to $O(\delta t^4)$ in the
co-ordinates and $O(\delta t^3)$ in the velocities compared to the
velocity Verlet algorithm which is only $O(\delta t)$ in the
velocities. This is insufficient for an accurate determination of the
kinetic energy, pressure and other dynamic quantities. More seriously,
it fails badly in the case of polyatomic molecules and for
constant-pressure and constant-temperature methods where the
(generalized) velocities enter the dynamical equations themselves.

Velocity-dependent forces occur in equations~\ref{eqn:euler}
and~\ref{eqn:qddot}, in the Parrinello-Rahman constant-pressure
equations (section~\ref{sec:const-stress}) and in the Nos{\'e}-Hoover
heat bath algorithms (section~\ref{sec:const-temp}). These usually
present a problem to non ``predictor-corrector'' algorithms which are
based on the assumption that the forces depend only on the
co-ordinates.  Fincham has devised a scheme to allow integration of
the rotational equations using Verlet-like
algorithms\cite{fincham:92}, which is widely used despite the
potential problems caused by the low accuracy of the velocities being
propagated into the dynamics.

These cases are easily and accurately handled by the modification to
Beeman's equations proposed by the author\cite{refson:85}.  These may
be summarized using the symbol $x$ to represent any dynamic variable
(centre-of-mass co-ordinate, quaternion or MD cell edge),
$\dot{x}^{(p)}$ and $\dot{x}^{(c)}$ to represent ``predicted'' and
``corrected'' velocities respectively.

\begin{equation}
  \begin{array}[c]{llcl}
    \textup{i} \quad & x(t+\delta t) &=& x(t) + \delta t \, \dot{x}(t) + 
    \frac{\delta t^2}{6} 
    \left [ 4 \ddot{x}(t) - \ddot{x}(t-\delta t) \right ] \\
    \textup{ii}  & \dot{x}^{(p)}(t+\delta t) & = & \dot{x}(t) + 
    \frac{\delta t}{2} \left [ 3 \ddot{x}(t)- \ddot{x}(t-\delta t) \right ]\\
    \textup{iii}  & \ddot{x}(t+\delta t) & = & F(\{ x_i(t+\delta t),
    \dot{x}_i^{(p)}(t+\delta t)\}, i =  1\ldots n) \\
    \textup{iv} & \dot{x}^{(c)}(t+\delta t) & = & \dot{x}(t) + \frac{\delta t}{6} 
    \left [ 2 \ddot{x}(t+\delta t) + 5 \ddot{x}(t)- \ddot{x}(t-\delta t) \right ]\\
    \textup{v} & \multicolumn{3}{l}{
      \textnormal{Replace $ \dot{x}^{(p)}$ with $\dot{x}^{(c)}$ and
    goto \emph{iii}.  Iterate to convergence}} 
  \end{array}
  \begin{array}[c]{l}
  \begin{array}{l}
    \strut\\
    \strut
  \end{array}\\
  \left .
  \begin{array}{l}
    \strut\\
    \strut\\
    \strut
  \end{array}
  \right \}
  \end{array}
  \label{eqn:beeman}
\end{equation}

The predictor-corrector cycle of steps \emph{iii} to \emph{v} is
iterated until the predicted and corrected velocities have converged
to a relative precision of better than 1 part in $10^{-7}$, which in
practice takes 2 or 3 cycles.  This iteration is not as inefficient as
it might at first appear as it does \emph{not} include the expensive
part of the calculation --- the recalculation of the site forces.
Only the angular accelerations and quaternion second derivatives must
be evaluated at each iteration using equations~\ref{eqn:euler} 
and~\ref{eqn:qddot}, and this operation is relatively cheap.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Potentials and Short-Range Forces}%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The forces determining the dynamics of the system are derived from the
potential function denoted by $\phi_{i\alpha j\beta}(\bm{r} _{i\alpha
  j\beta})$.  The indices $i$ and $j$ run over all molecules in the
system and $\alpha$ and $\beta$ over sites on the respective molecule.
The total potential energy of the system is
\begin{equation}
\label{eqn:toten}
U = \sum_i \sum_{j > i} \sum_\alpha \sum_\beta \phi_{i\alpha j\beta}(
\bm{r}_{i\alpha j\beta}).
\end{equation}
where $\bm{f}_{i\alpha j\beta} = - \bm{\nabla} \phi_{i\alpha  j\beta}(
\bm{r}_{i\alpha j\beta})$ is the force acting on site $\beta$ of molecule
$j$ from site $\alpha$ of molecule $i$.

The total force and torque acting on any particular molecule are
calculated using equations~\ref{eqn:comf} and~\ref{eqn:comt}.  Since
$\bm{f}_{i\alpha j\beta}$ and therefore $\bm{F}_{ij}$ are short-ranged
forces (\ie\ they decay faster than $r^{-3}$) one can define a
\emph{cutoff} radius, $r_c$.  Interactions between sites whose
separation $r_{ij}$ is greater than $r_c$ are assumed to be negligible
and need not be evaluated.  In the case of a polyatomic molecular
system it is usual to apply the cutoff according to the
\emph{intermolecular} separation, $R_{ij}$.


\subsection{Pressure and Stress}
The internal stress of a system of interacting molecules is given by
Allen and Tildesley\cite[pp 46-49]{allen:87} in terms of the molecular
virial, but we may rewrite it more conveniently in terms of the atomic
site virial as

\begin{eqnarray}
\label{eqn:stress-sr}
V \bm{\pi}^{sr} & = & \left <  \sum_i M_i \bm{V}_i \bm{V}_i 
              + \sum_i \sum_{j>i} \bm{R}_{ij} \bm{F}_{ij} 
\right > \\ \nonumber
& = & \left < \sum_i M_i \bm{V}_i \bm{V}_i 
              + \sum_{i} \sum_{j>i} \sum_\alpha \sum_\beta 
                \bm{r}_{i\alpha j\beta}  \bm{f}_{i\alpha j\beta} 
              - \sum_i \sum_\alpha \bm{p}_{i\alpha} \bm{f}_{i\alpha}
\right >
\end{eqnarray}
The quantity $\bm{p}_{i\alpha} \equiv \bm{r}_{i\alpha} - \bm{R}_i$ is the
co-ordinate of each site relative to the molecular centre-of-mass.
The pressure is easily evaluated as one third of the trace of the
stress tensor. 

\subsection{Long-Range Corrections}
The truncation of the interactions at the cutoff radius does
introduce some errors into the calculated potential energy and stress.
By neglecting density fluctuations on a scale longer than the cutoff
radius we may approximate the errors and calculate correction 
terms\cite[pp 64-65]{allen:87}.

\begin{eqnarray}
U_c & = & \frac{2\pi}{V} \sum_\alpha \sum_\beta N_\alpha N_\beta 
               \int_{r_c}^\infty r^2 \phi_{\alpha\beta}(r) \, \Calcd r \\
P_c V & = & \frac{2\pi}{3 V} \sum_\alpha \sum_\beta N_\alpha N_\beta 
               \int_{r_c}^\infty r^3 
               \frac{\Calcd\phi_{\alpha\beta}(r)}{\Calcd r}
                \, \Calcd r \nonumber \\ 
           & = & U_c + \frac{2\pi}{3 V} \sum_\alpha \sum_\beta
           N_\alpha N_\beta r_c^3 \phi_{\alpha\beta}(r_c) \\
\bm{\pi}_c & = & P_c \bm{\delta}
\end{eqnarray}
where the sums run over all the distinct kinds of sites,
$N_\alpha$ is the total number of sites of type $\alpha$ in the system
and $\bm{\delta}$ is the unit matrix.


\subsection{Potential Functions}
\label{sec:potentials}
% LJ, Buckingham (Born-Mayer) & MCY
\moldy\ supports most common forms of potential function including:
\begin{list}{}{%
\setlength{\parsep}{0in} 
\setlength{\labelwidth}{1in}
\setlength{\labelsep}{0.25in}
\setlength{\leftmargin}{1.5in}
\renewcommand{\makelabel}[1]{\hspace{\labelsep}\emph{#1} \hfil}}
\item[Lennard-Jones] $\phi(r) = \epsilon((\frac{\sigma}{r})^{12} -
(\frac{\sigma}{r})^{6})$
\item[6-exp] $\phi(r) = -\frac{A}{r^{6}} +
B\exp(-Cr)$\\
This is the most general 6-exp form and
includes potential of the \emph{Born-Mayer} and \emph{Buckingham} forms.
\item[MCY] $\phi(r) = A \exp(-Br) - C \exp(-Dr)$
\item[generic]  $\phi(r) = A \exp(-Br) + C/r^{12} - D/r^4 -E/r^6 -F/r^8$\\
This is a composite which contains terms of several inverse powers
which may be useful for ionic solution simulations.
\end{list}

In addition to the short-range potential, electric charges may be
specified for each atomic site which interact according to Coulomb's
Law.  See the following section for details.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Ewald Sum}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:ewald}
The long-range Coulomb interactions are handled using the Ewald Sum
technique in three dimensions\cite[p.\ 156]{berthaut:52,allen:87}.
The electrostatic potential of a system of charges is expressed as a
sum of short-range and long-range contributions.  Each term is written
as a series, the first in real space and the second, obtained by
Fourier transformation using the periodicity of the MD cell, in
reciprocal space.  The expression for the Coulomb energy, $U$, is
\begin{eqnarray}
\label{eqn:ewald}
U & = &  \underbrace{\frac{1}{4 \pi \epsilon_0}
\sideset{}{^\dag}\sum_{\bm{n}} \sum_{i=1}^{N} \sum_{j=i+1}^{N} q_iq_j
\frac{\erfc( \alpha | \bm{r}_{ij} +  \bm{n} |)}{| \bm{r}_{ij} +
\bm{n} | }}_{\textnormal{Real-space term}} 
\nonumber \\
 & + & \underbrace{\frac{1}{\epsilon_0 V} \sum_{\bm{k} > 0} \frac{1}{k^2}
       e^{-\frac{k^2}{4 \alpha^2}} 
\left \lbrace 
\left | \sum_{i=1}^{N} q_i \cos(\bm{k \cdot r}_i) \right |^2 + 
\left | \sum_{i=1}^{N} q_i \sin(\bm{k \cdot r}_i) \right |^2 
\right \rbrace}_{\textnormal{Reciprocal-space term}}\\
 & - & 
\underbrace{\frac{\alpha}{4 \pi^\frac{3}{2} \epsilon_0} 
\sum_{i=1}^{N} q_i^2}_{\textnormal{Point self-energy}} 
 - \underbrace{\frac{1}{4 \pi \epsilon_0} \sum_{n=1}^M
\sum_{\kappa=1}^{N_m} \sum_{\lambda=\kappa+1}^{N_m} q_{n\kappa} q_{n\lambda}
\frac{\erf( \alpha | \bm{r}_{\kappa\lambda} |)}{|
\bm{r}_{\kappa\lambda}| }}_{\textnormal{Intra-molecular self energy}}
\nonumber \\
& - & \underbrace{ \frac{1}{8 \epsilon_0 V \alpha^2}
                    \left | \sum_{i=1}^N q_i 
                    \right |^2}_{\textnormal{Charged system term}} +
\; \underbrace{\left [  \frac{1}{6 \epsilon_0 V} 
                    \left | \sum_{i=1}^N q_i \bm{r}_i 
                    \right |^2 \right ]}_{\textnormal{Surface dipole term}}
\nonumber
\end{eqnarray}
where the ``daggered'' summation indicates omission of site pairs $i,
j$ belonging to the same molecule if $\bm{n}=\bm{0}$.  The meaning of
the symbols is

\begin{tabbing}
\rule{2cm}{0cm} \= \rule{2cm}{0cm} \=\\
\> $\bm{n}$        \> lattice vector of periodic array of MD cell images \\
\> $\bm{k}$        \> reciprocal lattice vector of periodic array of MD cell images \\
\> $k$             \> modulus of $\bm{k}$ \\
\> $i,j$           \> absolute indices of all charged sites \\
\> $n$             \> index of molecules \\
\> $\kappa,\lambda$ \> indices of sites within a single molecule \\
\> $N$             \> total number of charged sites \\
\> $M$             \> total number of molecules \\
\> $N_m$           \> number of sites on molecule $m$ \\
\> $\bm{p}_i$      \> co-ord of site $i$ relative to molecular 
centre-of-mass, $\bm{r}_i - \bm{R}_i$ \\
\> $q_i$           \> charge on absolute site $i$ \\
\> $q_{m\kappa}$   \> charge on site $\kappa$ of molecule $m$ \\
\> $\bm{r}_i$      \> Cartesian co-ordinate of site $i$ \\
\> $\bm{r}_{ij}$   \> $\bm{r}_j - \bm{r}_i$ \\
\> $\alpha$        \> real/reciprocal space partition parameter \\
\> $\pi_{lm}$      \> instantaneous stress tensor \\
\> $\delta_{lm}$   \> Kronecker delta symbol \\
\> $l, m$          \> $xyz$ tensor indices \\
\> $V$             \> volume of MD cell
\end{tabbing}


and the force on charge $i$ is given by
\begin{eqnarray}
  \label{eqn:ewald-force}
  \bm{f}_i &=& - \nabla_{\bm{r}_i} U \nonumber \\
  & = & \underbrace{\frac{q_i}{4 \pi \epsilon_0}
    \sideset{}{^\dag}\sum_{\bm{n}} \sum_{\substack{j=1\\j \neq i}}^{N}
    q_j \left \lbrace \frac{\erfc( \alpha | \bm{r}_{ij} + \bm{n} |)}{|
        \bm{r}_{ij} +\bm{n} | } + \frac{2 \alpha}{\sqrt{\pi}}e^{-
        \alpha^2 | \bm{r}_{ij} + \bm{n} |^2} \right \rbrace
    \frac{\bm{r}_{ij} + \bm{n}}{| \bm{r}_{ij} + \bm{n} |^2}
    }_{\textnormal{Real-space term}} \nonumber \\
  & + & \underbrace{\frac{2}{\epsilon_0 V} \sum_{\bm{k} > 0} q_i
    \frac{\bm{k}}{k^2} e^{-\frac{k^2}{4 \alpha^2}} \left \lbrace
      \sin(\bm{k \cdot r}_i) \sum_{j=1}^{N} q_j \cos(\bm{k \cdot r}_j)
      - \cos(\bm{k \cdot r}_i) \sum_{j=1}^{N} q_j \sin(\bm{k \cdot
        r}_j)
    \right \rbrace}_{\textnormal{Reciprocal-space term}}\\
  & + & \underbrace{\left [ \frac{q_i}{6 \epsilon_0 V} \left (
        \sum_{j=1}^N q_j \bm{r}_j \right ) \right
    ]}_{\textnormal{Surface dipole term}} \nonumber
\end{eqnarray}

The molecular forces and torques $\bm{F}$ and $\bm{N}$ are evaluated
from the site forces $\bm{f}_i$ using equations~\ref{eqn:comf} 
and~\ref{eqn:comt}.

Notice that the equation~\ref{eqn:ewald} for the energy contains a
correction for the intra-molecular self-energy, whose derivative is
absent from the equation for the forces
(equation~\ref{eqn:ewald-force}).  This term corrects for interactions
between charges on the \emph{same} molecule which are implicitly
included in the reciprocal space sum, but are not required in the
rigid-molecule model.  Though the site forces $\bm{f}_i$ do therefore
include unwanted terms these sum to zero in the evaluation of the
molecular centre-of-mass forces and torques (equations~\ref{eqn:comf}
and~\ref{eqn:comt}) (by the conservation laws for linear and angular
momentum).

\subsection{Parameter Values}
\label{sec:ewald-auto}

Both the real- and reciprocal-space series (the sums over $\bm{n}$ and
$\bm{k}$) converge fairly rapidly so that only a few terms need be
evaluated.  We define the \emph{cutoff} distances $r_c$ and $k_c$ so
that only terms with $| \bm{r}_{ij} +\bm{n} | < r_c$ and $|\bm{k}| < k_c$
are included.  The parameter $\alpha$ determines how rapidly the terms
decrease and the values of $r_c$ and $k_c$ needed to achieve a given
accuracy. 

For a fixed $\alpha$ and accuracy the number of terms in the
real-space sum is proportional to the total number of sites, $N$ but
the cost of the reciprocal-space sum increases as $N^2$. An overall
scaling of $N^\frac{3}{2}$ may be achieved if $\alpha$ varies with
$N$. This is discussed in detail in an excellent article by David
Fincham\cite{fincham:94}.  The optimal value of $\alpha$ is
%
\begin{equation}
\alpha = \sqrt{\pi} \left ( \frac{t_R}{t_F} \frac{N}{V^2}\right )
^\frac{1}{6} 
\label{eqn:ewald-alpha}
\end{equation}
%
where $t_R$ and $t_F$ are the execution times needed to evaluate a
single term in the real- and reciprocal-space sums respectively.
If we require that the sums converge to an accuracy of $ \epsilon =
\exp ( -p )$ the cutoffs are then given by

\begin{eqnarray}
r_c  &=& \frac{\sqrt{p}}{\alpha} \\
k_c &=& 2 \alpha \sqrt{p}
\label{eqn:ewald-cut}
\end{eqnarray}

A representative value of $t_R/t_F$ specific to \moldy\ has been
established as 5.5.  Though this will vary on different processors
and for different potentials its value is not critical since it
enters the equations as a sixth root.  

It must be emphasized that $r_c$ is used as a cutoff for the
short-ranged potentials as well as for the electrostatic part.  The
value chosen above \emph{does not} take the nature of the
non-electrostatic part of the potential into account.  It is therefore
the responsibility of the user to ensure that $r_c$ is adequate for
this part too.

\subsection{Uniform Sheet Correction}
The 5th term in equation~\ref{eqn:ewald} is necessary only if the system
has a non-zero net electric charge, and is useful in special cases such
as framework systems.  

In a periodic system the electrostatic energy is finite only if the
total electric charge of the MD cell is zero.  The reciprocal space
sum in equation~\ref{eqn:ewald} for $\bm{k}=0$ takes the form
\[\frac{1}{k^2}e^{-\frac{k^2}{4 \alpha^2}} \left | \sum_{i=1}^{N} q_i
 \right |^2\] which is zero in the case of electroneutrality but
infinite otherwise.  Its omission from the sum in
equation~\ref{eqn:ewald} is physically equivalent to adding a uniform
jelly of charge which exactly neutralizes the unbalanced point
charges.  But though the form of the reciprocal space sum is
unaffected by the uniform charge jelly the real-space sum is not.  The
real-space part of the interaction of the jelly with each point charge
as well as the self-energy of the jelly itself must be included giving
the fifth term in equation~\ref{eqn:ewald}.

\subsection{Surface Dipole Term}
The optional final term in equations~\ref{eqn:ewald} 
and~\ref{eqn:ewald-force} if used performs the calculations under
different periodic boundary conditions.  It was suggested by De Leeuw,
Perram and Smith\cite{deleeuw:80} in order to accurately model
dipolar systems and is necessary in any calculation of a dielectric
constant. 

The distinction arises from considerations of how the imaginary set of
infinite replicas is constructed from a single copy of the MD 
box\cite[pp 156-159]{allen:87}.  Consider a near-spherical cluster
of MD cells.  The ``infinite'' result for any property is the limit of
its ``cluster'' value as the size of the cluster tends to infinity.
However this value is non-unique and depends on the dielectric
constant, $\epsilon_s$, of the physical medium surrounding the cluster.
If this medium is conductive ($\epsilon_s=\infty$) the dipole
moment of the cluster is neutralized by image charges, whereas in a
vacuum ($\epsilon_s=1$) it remains.  It is trivial to show that
in that case the dipole moment per unit volume (or per MD cell) does
\emph{not} decrease with the size of the cluster.

The final term in equation~\ref{eqn:ewald} is just the dipole energy,
and ought to be used in any calculation of the dielectric constant of
a dipolar molecular system.  It is switched on by \moldy's control
parameter \Lit{surface-dipole}.  Note that as it represents the
dipole at the surface of the cluster the system is no longer truly
periodic.

Conversely it \emph{must not} be used if the simulated system contains
mobile ions.  Consider an ion crossing a periodic boundary and jumping
from one side of the MD cell to another.  In that case the dipole
moment of the MD cell changes discontinuously.   Because of the
surface dipole term the calculation would model a discontinuous
macroscopic change in the dipole moment of the whole system caused by
an infinite number of ions jumping an infinite distance.  This is
manifested in practice by a large and discontinuous change in the
energy of the system and on the force on each charge within it.

This situation is completely non-physical but is easily avoided.
However the problem may also arise more subtly even when there are no
mobile ions if a framework is being simulated
(section~\ref{sec:frameworks}).  The framework is treated as a set of
discrete, but fixed, atoms rather than a molecular unit.  If the shape
of the unit cell is allowed to vary then ions constituting the
framework may indeed cross MD cell boundaries causing the
aforementioned problems.

\subsection{Stress}

The internal stress (and pressure) of an atomic system is given by the
volume-derivative of the internal energy.  The situation is slightly
more complicated for rigid molecules since molecules do not scale with
volume and only the inter-molecular distances vary.  The resulting
expression for the Coulombic part of the instantaneous stress
$\pi_{ik}^e$ is\cite[Appendix A]{nose:83}

\begin{eqnarray}
\label{eqn:ewald-stress}
V\pi_{lm}^e & = & \underbrace{\frac{1}{4 \pi \epsilon_0}
\sideset{}{^\dag}\sum_{\bm{n}}\sum_{i=1}^{N} \sum_{j=i+1}^{N} q_iq_j 
\left \lbrace 
\frac{\erfc( \alpha | \bm{r}_{ij} +  \bm{n} |)}{| \bm{r}_{ij} +\bm{n} | } +
\frac{2 \alpha}{\sqrt{\pi}}e^{- \alpha^2 | \bm{r}_{ij} +  \bm{n} |^2}
\right \rbrace \frac{(\bm{r}_{ij} + \bm{n})_l(\bm{r}_{ij} +
\bm{n})_m}{| \bm{r}_{ij} + \bm{n} |^2}}_{\textnormal{Real-space term}}
    \nonumber \\
 & + & \underbrace{\frac{1}{\epsilon_0 V} \sum_{\bm{k} > 0} \frac{1}{k^2}
       e^{-\frac{k^2}{4 \alpha^2}}
\left ( \delta_{lm}  \!- \! 2 \left [ \frac{1}{k^2} \! + \! \frac{1}{4 \alpha^2}
\right ] \bm{k}_l\bm{k}_m \right )\left \lbrace 
%
\left | \sum_{i=1}^{N} q_i \cos(\bm{k \cdot r}_i) \right |^2 + 
\left | \sum_{i=1}^{N} q_i \sin(\bm{k \cdot r}_i) \right |^2 
\right \rbrace}_{\textnormal{Reciprocal-space term}} \nonumber \\
& - & \underbrace{\sum_{i=1}^{N}  (\bm{F}_i)_l
  (\bm{p}_i)_m}_{\textnormal{Molecular Virial Correction}} 
-  \underbrace{ \frac{\delta_{lm}}{8 \epsilon_0 V \alpha^2}
                    \left | \sum_{i=1}^N q_i 
                    \right |^2}_{\textnormal{Charged system term}}
\end{eqnarray}

The true internal stress is the ensemble average, $\pi_{lm} = \left <
  \pi_{lm}^e + \pi_{lm}^{\textnormal{s.r.}} + \pi_{lm}^K \right >$,
where $\pi_{lm}^{\textnormal{s.r.}}$ and $\pi_{lm}^K$ are the
short-range force and kinetic contributions respectively.
$\pi_{lm}^e$ enters into the Parrinello-Rahman equations of motion
(see section~\ref{sec:const-stress}).

The term marked \emph{Molecular Virial Correction} in
equation~\ref{eqn:ewald-stress} is the difference between the
site-site virial $\sum_i \bm{f}_i \cdot \bm{r}_i$ and the molecular virial
$\sum_i \bm{F}_i \cdot \bm{R}_i$ and is subtracted after all of the site forces
and the molecular forces have been calculated including the
short-range potential components which are not included in the
equations above.  Though it is not apparent in reference\cite[Appendix
A]{nose:83} this term has exactly the same form for all parts of the
stress --- the short-range potential and the real- and reciprocal
space Coulombic parts.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Periodic Boundaries --- the Link Cell Method}%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:link-cell}
The real space part of the Ewald (equation~\ref{eqn:ewald}) and
short-range potential energy is a sum of contributions over pairs of
sites.  In both cases the interaction decays rapidly with separation,
which means that only site pairs closer then some \emph{cutoff} distance
$r_c$ need be considered.  Several methods are available to enumerate
site pairs and choose those within the cutoff.

Most simple MD codes simply loop over all pairs of particles in the MD
box and compute the separation $r$ for each.  If $r < r_c$ the
interaction is computed.  This method suffers from several
disadvantages.  Since for any given site, the interaction with any
other site is considered only once, only the \emph{nearest} periodic
image of that site is included (the \emph{minimum-image} convention).
However this restricts the cutoff radius to less than half the MD cell
dimension $r_c < 2L$.  More serious is the way the computational
time scales with the number of sites.  If there are $N$ sites, there
are $O(N^2)$ separations to compute and the overall time therefore scales
as $O(N^2)$.

The Verlet \emph{Neighbour List} scheme\cite[pp 146-149]{allen:87} makes
use of the spatial locality of the interaction potential by
maintaining a list for each site of all the ``neighbouring'' sites
(\ie\ all those within the cutoff distance).  This can give
considerable gains for moderate numbers of sites, but it ultimately
requires $O(N^2)$ time (to build the lists) as well as $O(N)$ storage for
the lists.

\moldy\ uses an implementation of the link cell method of Quentrec
\emph{et al}.\cite{quentrec:75} described in Allen and Tildesley's
book\cite[pp 149-152]{allen:87} which is a true $O(N)$ algorithm.  The
fundamental idea is that the MD cell is partitioned into a number of
smaller cells, known as \emph{subcells}.  Every timestep a linked list
of all the particles contained in each subcell is constructed.  The
selection of all pairs of \emph{particles} within the cutoff is
achieved by looping over all pairs of \emph{subcells} within the
cutoff and particles within the subcells.  Because of their regular
arrangement, the list of neighbouring subcells is fixed and may be
precomputed.  Its construction takes only $O(N)$ operations and only
$O(N)$ pair interactions need be calculated.

One drawback of the link cell method has been the difficulty of
implementing it efficiently for vector processors.  The linked list of
``neighbour'' particles is not stored in the regular-stride array
which is required for vectorization.  Heyes and Smith\cite{heyes:87}
pointed out that \emph{gather} operations might be used to assemble a
temporary array of neighbour particle co-ordinates from which the
interaction potential and forces could be evaluated in vector mode.  A
\emph{scatter} operation is then used to add the resulting forces to
the total force array.  This is the technique used in \moldy.  Almost
all modern vector machines have scatter/gather hardware which means
these operations are fairly cheap.

\subsection{Molecular Aspects}

The treatment of molecules as rigid bodies adds an additional
complication to link-cell and neighbour-list algorithms.  If atomic
sites are assigned to link-cells, then there is no obvious way of
determining in the innermost force loop whether two sites belong to
the same, or to different molecules.  It is therefore not possible to
exclude intra-molecular site-site interactions from the force and
potential energy calculation.  Furthermore molecules may be
``split'' by the periodic boundaries, for example half of the sites of
some molecule may reside near the bottom of the MD box and the
remainder near the top.  This means that there is no longer a unique
molecular centre of mass and equations~\ref{eqn:stress-sr}
and~\ref{eqn:ewald-stress} can no longer be used to compute the internal
stress or pressure.

On the other hand, entire molecules may be assigned to subcells on the
basis of their centre-of-mass co-ordinates. All atomic sites belonging
to a molecule are placed in the list belonging to the particular cell
containing the molecular centre of mass.  This enables intramolecular
interactions to be excluded from the calculation and
equations~\ref{eqn:stress-sr} and~\ref{eqn:ewald-stress} can be used to
compute the internal stress.  There is however a computational
disadvantage, which arises because sites belonging to a large molecule
may lie outside the subcell.  In order to correctly include site-site
interactions within the cutoff, the list of neighbour cells must be
extended to include all cells where any parts are closer than $r_c + 2
r_\textnormal{mol}$ where $r_\textnormal{mol}$ is the molecular
radius.  There is an inevitable increase in computer time required to
process the lists, and in the case of a ``strict cutoff'' many
unnecessary intra-site interactions must be evaluated.  In the case of
a system containing a mixture of (perhaps a few) very large molecules
and other, small molecules the computer-time penalty may be very large
indeed.

Versions of \moldy\ prior to 2.16 used this ``molecular
binning'' approach and suffered from the associated computational
penalty. Versions 2.16 and later adopt the former ``site binning''
approach, which is much more efficient.  The intra-molecular potential
energy (which is necessarily included in the site-site interactions)
is computed separately and subtracted from the total, to yield just
the inter-molecular part.  Intra-molecular \emph{forces} sum to zero
in the calculation of the centre-of-mass forces and molecular torques,
just as with the reciprocal-space contribution to the forces.  

The internal stress is computed using a novel approach, inspired by
the extension of the Verlet neighbour list algorithm developed by
Bekker \emph{et al.}\cite{bekker:95}.  Bekker showed that the (tensor)
virial may be written
\begin{eqnarray}
  \label{eqn:bekker-virial}
  \bm{W} &=& \sum_{\bm{n}}\sum_{i=1}^{N} \sum_{j=i+1}^{N}
  \bm{r}_{i(j.\bm{n})}\bm{f}_{i(j.\bm{n})} \nonumber\\
         &=& \sum_{i=1}^{N} \sum_{j=i+1}^{N}
  \bm{r}_{i}\bm{f}_{i} + \sum_{\bm{n}} \bm{n}\bm{g}_{\bm{n}}
\end{eqnarray}
where $\bm{n}$ is the lattice vector between the central MD cell and
its periodic images and is also used as an index to represent a sum
over all image cells and the expression $(j.\bm{n})$ refers to
the periodic image of particle $j$ in image cell $\bm{n}$.  The
quantity $\bm{g}_{\bm{n}}$
\begin{equation}
  \label{eqn:bekker-g}
  \bm{g}_{\bm{n}} = \sum_{i=1}^{N} \sum_{j=i+1}^{N}\bm{f}_{(j.\bm{n})i} = 
  \frac{1}{2} \sum_{i=1}^{N} \sum_{j=1}^{N}\bm{f}_{(j.\bm{n})i}
\end{equation}
is half the total force exerted by all particles in the central MD
cell on all particles in image cell $\bm{n}$.  This is easily
evaluated in the inner loops of the link-cell force calculation by
summing separately the pair forces on all particles in each image cell. The
image-cell translation vector $\bm{n}_{ij}$ has already been computed in
order to evaluate the site-site vector $\bm{r}_{ij} +\bm{n}_{ij}$.

Using equation~\ref{eqn:bekker-virial} to compute the virial has
another advantage. It is not necessary to perform the sum of
contributions within the inner loop of the force calculation (\cf\
equation~\ref{eqn:stress-sr}) since it depends only on the site
co-ordinates and the total force acting on each site.  This gives a
considerable reduction in the number of computations in the costliest
part of the whole calculation.

\subsection{No Minimum-image Convention}
One notable feature of the implementation of the link cell method in
\moldy\ is that it does \emph{not} follow the \emph{minimum image}
convention used in most MD codes.  Instead the list of neighbouring
cells, and hence interactions considered, includes \emph{all} periodic
images of a particle which are within the cutoff.  This means that it
is quite safe to use a cutoff of more than half of the MD cell side in
any direction.  

% quick 'n dirty vs strict.
\subsection{Cell or Strict Cutoff}
\label{sec:strict-cutoff}
There are two options for the way in which site-site interactions are
selected for inclusion in the total energy and forces.  These are
\emph{cell-based} cutoff and \emph{strict} cutoff and are selected
by the \Lit{strict-cutoff} control parameter.

In cell-based mode (\Lit{strict-cutoff=0}) the neighbour cell list is
built to include only those cells whose centre is within the cutoff
radius of the centre of the reference cell.  All interactions between
sites in the neighbouring cell list are computed.  This is a ``quick
and dirty'' method as some interactions between sites closer than the
cutoff will inevitably be excluded whereas some outside the cutoff
range will be included.

In strict mode (\Lit{strict-cutoff=1}) all interactions between pairs
of sites within the cutoff are included.  The neighbouring cell list
contains all pairs of cells with any parts closer than the cutoff
radius.  This ensures that all appropriate interactions are included.
Furthermore, all interactions between sites further apart than the
cutoff are excluded (by the expedient of setting their separation to a
large value in the potential calculation).  This means that large and
asymmetric molecules are handled correctly.

For a given cutoff radius the cell-based mode is rather quicker than
the strict mode since the neighbouring cell list is much smaller and
fewer interactions are computed.  However to ensure that significant
interactions are not omitted, the cutoff ought to be set to a
greater value than strictly required.    This tends to offset the
potential speed gain.   On the other hand, if strict isotropy is
required in a liquid simulation for example then the strict cutoff
option ought to be used.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Temperature Initialization and Control}%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
From the equipartition theorem, every degree of freedom in the system,
$f$ has the same kinetic energy, given by $\left < \mathcal{K} \right
>_f~=~\frac{1}{2}k_BT$.  The effective temperature of the system is
therefore given by the ensemble average of its kinetic energy.
\begin{equation}
\label{eqn:equipartition}
T = \left < \mathcal{T} \right > = \frac{2}{gk_B} \left <
  \sum_{f=1}^{g} \mathcal{K}_f \right > = \frac{1}{3Nk_B}\left <
  \sum_{i=1}^N m_i \bm{v}_i^2 + \bm{\omega}_i \cdot \bm{I} \cdot
  \bm{\omega}_i \right >
\end{equation}
Here $\mathcal{K}_f$ is the instantaneous kinetic energy of degree of
freedom $f$, $g$ is the number of degrees of freedom, $N$ is the
number of molecules, $\mathcal{T}$ is an instantaneous ``temperature''.

It is almost always desirable that a simulation be conducted so that
the temperature is the supplied parameter rather than the kinetic
energy.  This requires some mechanism to fix the \emph{average}
kinetic energy at thermal equilibrium.  The \emph{initial} kinetic
energy may be set approximately by choosing random velocities which
sample the Maxwell-Boltzmann distribution at the desired temperature,
and this is indeed what \moldy\ does on starting a new run (see
section~\ref{sec:velinit}).  But because the initial configuration is
usually far from equilibrium it will have too much potential energy.
As the run progresses this will be converted into kinetic energy,
raising the temperature above the desired value. It is therefore
necessary to have some mechanism for removing excess kinetic energy as
the run progresses.

\moldy\ offers several mechanisms to control the temperature. The
common technique of \emph{velocity scaling} is suitable for use
during the equilibration period but does not generate meaningful
particle trajectories. The Nos{\'e}-Hoover method couples the system to
a heat bath using a fictional dynamical variable and the Gaussian
thermostat replaces the Newton-Euler equations by variants of which
the kinetic energy is a conserved quantity.

\subsection{Rescaling}
\label{sec:rescaling}

At periodic intervals linear and
angular velocities are multiplied by a factor of
\begin{equation}
\label{eqn:scaling}
s = \sqrt{\frac{gk_BT}{2\mathcal{K}}}
\end{equation}
where $T$ is the desired temperature.  By repeatedly setting the
``instantaneous'' temperature to the correct value while the system
approaches its equilibrium state, the kinetic energy is made to
approach its desired value.  \emph{Scaling} may be performed every
timestep, or every few depending on the simulation conditions.

An MD run with scaling does not generate a valid statistical ensemble,
and it must therefore be switched off before any calculation of
thermodynamic averages is performed.

\moldy\ incorporates two refinements to the basic scaling algorithm
(which are selected by the control parameter \Lit{scale-options}).
Linear and angular velocities can be scaled independently, either for
the whole system or for each species individually.  In this way, one
does not rely on the interactions of these degrees of freedom for
convergence to equilibrium.  In many systems these degrees of freedom
are loosely coupled and the exchange of energy between them is slow.
In these cases individual scaling can speed up the approach to
equilibrium considerably.

The other refinement addresses the problem of setting the temperature
accurately.  At equilibrium the system's kinetic energy fluctuates
with mean-square amplitude\footnote{This formula actually applies to
the Canonical rather than the microcanonical ensemble, but it serves
for the purpose of this argument.} $\left < \delta \mathcal{K}^2\right > =
\frac{1}{2}g\left(k_BT\right)^2$, which corresponds to a
rms fluctuation in the instantaneous ``temperature'' 
$\sqrt{\left < \delta \mathcal{T}^2\right >} = 
\sqrt{2 /g} T$.   
The difficulty with applying equation~\ref{eqn:scaling}
is the instantaneous kinetic energy $\mathcal{K}$ in the denominator.
Strictly, scaling ought to use the \emph{average} kinetic energy
$\left<\mathcal{K} \right>$ as in equation~\ref{eqn:equipartition}, but
this quantity is not known until after the run is completed.  Because
of this equation~\ref{eqn:scaling} can only set the temperature to an
accuracy of $\sqrt{1/g}$.  This is often inadequate for purposes of
comparison with experiment.

In order to allow the temperature to be set with greater accuracy,
\moldy\ allows the use of a partial average in the denominator,
\begin{equation}
\label{eqn:rav-scaling}
s = \sqrt{\frac{gk_BT}{2\left < \mathcal{K}\right >^\prime}}
\end{equation}
where $\left < \mathcal{K}\right >^\prime$ is the ``rolling'' average of
$\mathcal{K}$ over some number of preceding timesteps.  That number is
determined by the control parameter \Lit{roll-interval}.   

This option should be used cautiously.  The change in $\left
  <\mathcal{K}\right >$ upon scaling only has a significant effect on
the average after many timesteps. If the subsequent scaling is
performed before this change is reflected in the value of $\left <
  \mathcal{K}\right >^\prime$ it will use an out-of-date value of
the average kinetic energy.  It is therefore recommended that the
number of timesteps between scalings be greater than or equal to the
number used to compute the rolling average.  Otherwise it is possible
to produce wild overshoots and oscillations in the temperature.

Finally, there is a method for tackling really difficult cases when
even individual scaling is unable to keep the temperature under
control.  This might be a far-from-equilibrium configuration where the
potentials are so strong that velocities rapidly become very large,
or when a single molecule acquires a very large velocity.  In that
case the velocities can all be re-initialized randomly from the
Maxwell-Boltzmann distribution periodically.  This provides a kind of
pseudo Monte-Carlo equilibration for difficult cases.

\subsection{Nos{\'e}-Hoover Thermostat}
\label{sec:const-temp}
A more sophisticated approach than rescaling is to couple the system
to a heat bath.  Nos{\'e}\cite{nose:84} proposed an extended-system
Hamiltonian to represent the degrees of freedom of the thermal
reservoir: \moldy\ uses the simpler but equivalent formulation by
Hoover\cite{hoover:85,allen:87}.  The equations of
motion (equations~\ref{eqn:newton} and~\ref{eqn:euler}) are modified thus

\begin{eqnarray}
\label{eqn:nhtherm}
\ddot{\bm{R}}_i &=& \frac{\bm{F}_i}{M_i} - \zeta \dot{\bm{R}}_i
\nonumber \\
\bm{I}_i \cdot \dot{\bm{\omega}}_i - \bm{\omega}_i \times \bm{I}_i
\cdot
\bm{\omega}_i &=& \bm{N}_i - \zeta \bm{I}_i \cdot \bm{\omega}_i \\
\dot{\zeta} &=& \frac{g}{Q}\left ( k_B \mathcal{T} - k_B T \right )
\nonumber
\end{eqnarray}

\noindent
where most of the symbols have their previous meanings, $g$ is the
number of degrees of freedom in the system. $\zeta$ is a new ``heat
bath'' dynamic variable and $Q$ is the associated fictitious ``mass''
parameter.  With a suitable choice of $Q$ these equations generate
trajectories which sample the canonical ensemble\cite{nose:84}.  In
other words both averages and fluctuations calculated as time averages
from a simulation run tend to their canonical ensemble limits.%
\footnote{There has been some discussion in the literature of the
  validity of representing a heat bath by a single dynamical variable,
  which the more diligent reader may wish to
  explore\cite{cho:93,nose:91}.} This does not necessarily guarantee
the correctness of \emph{dynamical} quantities.

It is apparent from equations~\ref{eqn:nhtherm} that $\zeta$ has the
dimensions of a time derivative, and is analogous to the unit cell
velocities in equations~\ref{eqn:par}.  It is therefore treated as if
it was a velocity and updated using only steps \emph{ii--v} of the
Beeman integration procedure (equations~\ref{sec:beeman}).  Note that
the equation for the centre-of-mass acceleration depends
\emph{indirectly} on the velocities through $\mathcal{T}$ as well as
explicitly.  The iteration on steps \emph{iii--v} of
equations~\ref{sec:beeman} is therefore essential to integrate these
equations consistently.

There are two criteria to be considered when choosing the value of
$Q$.  The coupling to the heat bath introduces non-physical
oscillations of period $t_0 = 2 \pi \sqrt{Q / 2 g k_B T}$ which may be
easily detected in the total energy\cite{nose:91}.  Firstly it must be
arranged that there are sufficiently many oscillations during a
simulation run that the computed thermodynamic values represent
averages over many periods $t_0$. This ensures that the configurations
used to calculate the averages sample the whole of the phase space
generated by the fluctuations in $\zeta$ to represent the canonical
ensemble.  Secondly $Q$ should be chosen so that $t_0$ is large
compared to the characteristic decay time of dynamical correlation
functions. This is to ensure that the fictitious dynamics of the heat
bath are decoupled from the real molecular dynamics, and is
particularly important in a simulation of dynamic
properties\cite{cho:92} such as velocity correlation functions. Since
the first criteria favours a small $Q$ and the second a large one, it
may be necessary to increase the total simulation time in order to
satisfy them both.

\subsection{Gaussian Thermostat}
An alternative approach is known as ``constrained dynamics'' whereby
the equations of motion are modified to generate trajectories which
exactly satisfy $\mathcal{T} = T$ at all times.  One such is the Gaussian
constraint (see Allen and Tildesley\cite{allen:87} pp 230-231). The
equations of motion are 

\begin{eqnarray}
\label{eqn:gtherm}
\itemsep=0.5em
\ddot{\bm{R}}_i &=& \frac{\bm{F}_i}{M_i} - \zeta_T \dot{\bm{R}}_i \nonumber \\
\zeta_T &=& \frac{\sum_j\bm{v}_j \cdot \bm{F}_j}{\sum_j M_j\bm{v}_j^2} \\
\bm{I}_i \cdot \dot{\bm{\omega}}_i - \bm{\omega}_i \times \bm{I}_i
\cdot
\bm{\omega}_i &=& \bm{N}_i - \zeta_R \bm{I}_i \cdot \bm{\omega}_i \nonumber \\
\zeta_R &=& \frac{\sum_j\bm{\omega}_j \cdot \bm{N}_j}{\sum_j
  \bm{\omega}_j \cdot \bm{I}_j \cdot \bm{\omega}_j}\nonumber
\end{eqnarray}

These bear a superficial resemblance to equations~\ref{eqn:nhtherm}
but now $\zeta$ is not itself a dynamical variable but a function of the
other dynamical variables.  Note
that $T$ does not enter explicitly into  equations~\ref{eqn:gtherm}
since $\mathcal{T}$ is now a conserved quantity equal to its initial
value at all subsequent times. Perhaps surprisingly these equations of
motion generate configurational \emph{averages} from the canonical
ensemble, but this does \emph{not} hold true for the momenta and
therefore dynamics nor for fluctuations. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Constant Stress/pressure}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:const-stress}
It is frequently desirable to conduct simulations under conditions of
constant pressure or stress, rather than constant volume.  For
example, this allows the simulation of a solid-state phase transition
with a change of symmetry or unit cell size.  \moldy\ incorporates two
constant-stress methods which allow the MD cell to change size and
shape, and two variants which constrains the MD cell to uniform
dilation to give an isobaric ensemble.

In a constant-stress simulation the MD cell changes in size and shape
in response to the imbalance between the internal and externally
applied pressure.  For an exposition of the method the reader should
refer to the papers of Andersen\cite{andersen:80}, Parrinello and
Rahman\cite{parrinello:81}, Wentzcovitch\cite{wentzcovitch:91},
Cleveland\cite{cleveland:88} and to Nos\'{e} and Klein's extension to
rigid molecular systems\cite{nose:83}.  The equation of motion for the
reduced centre-of-mass co-ordinates $\bm{S}_i = \bm{h}^{-1}\bm{R}_i$
is
\begin{equation}
\label{eqn:par}
M_i\ddot{\bm{S}}_i = \bm{h}^{-1} \bm{F}_i - M_i \bm{G}^{-1}\dot{\bm{G}}\dot{\bm{S}}_i
\end{equation}
replacing the straightforward Newton equation~\ref{eqn:newton}.
$\bm{h}$ denotes the $3 \times 3$ MD cell matrix whose columns are
the MD cell vectors $\bm{a}, \bm{b}$ and $\bm{c}$, $\bm{F}_i$ is the
centre-of-mass force and $\bm{G} =\bm{h^\prime h}$.
Equation~\ref{eqn:euler}, the Euler equation, governs the angular
motion exactly as in the constant-volume case.

In the Parrinello-Rahman method the dynamics of the unit cell matrix
$\bm{h}$ are governed by the equation
\begin{equation}
\label{eqn:rahman}
W\ddot{\bm{h}} = \left ( \bm{\pi} - p \right ) \bm{\sigma}
\end{equation}
where $W$ is a fictitious mass parameter, $\bm{\sigma} = V
\bm{h}^{\prime-1}$ and $p$ is the external pressure.  The
instantaneous internal stress $\bm{\pi}$ is given by 
\begin{equation}
\label{eqn:prstress}
\bm{\pi} = \frac{1}{V}\sum_{i=1}^N m_i (\bm{h}_i\dot{\bm{s}}_i)^2 +
\bm{\pi}^{\textnormal{s.r.}} + \bm{\pi}^e 
\end{equation}
with the short-ranged and electrostatic components given by
equations~\ref{eqn:stress-sr} and~\ref{eqn:ewald-stress} respectively.

Wentzcovitch\cite{wentzcovitch:91} and Cleveland\cite{cleveland:88}
showed that the Parrinello-Rahman equations suffer from at least one
significant flaw, namely that they are not ``modularly invariant''.
The dynamics depends on the choice of MD cell which can give rise
to unphysical symmetry breaking effects.  They offer an improved, but
more complicated, expression for the unit cell dynamics
\begin{equation}
  \label{eqn:wentzcovitch}
  W\ddot{\bm{h}} = \frac{1}{V}\left ( \bm{\pi} - p \right ) \bm{h} + W
  \left (
    -\frac{2 \dot{V}}{V} \dot{\bm{h}} + \frac{1}{V^2}\textnormal{Tr}(\bm{\sigma'} \bm{\sigma}
      \dot{\bm{h'}} \dot{\bm{h}} ) \bm{h} + \frac{1}{V} \dot{\bm{h}} \bm{\sigma'} \dot{\bm{h}}
      + \frac{1}{V^2} ( \dot{\bm{h}} \bm{\sigma' \sigma} \dot{\bm{h'}} - \bm{\sigma} \dot{\bm{h'}}
      \dot{\bm{h}} \bm{\sigma'}) \bm{h}
  \right )
\end{equation}
which rectifies these deficiencies.  The atomic dynamics are governed
by equation~\ref{eqn:par} as before.

The choice of fictitious mass, $W$ is governed by similar
considerations to those concerning the heat bath mass, $Q$, discussed
in section~\ref{sec:const-temp}.\footnote{Because of the
different forms of the fictitious kinetic energy term in the
Lagrangians, typical values of $W$ for equation~\ref{eqn:wentzcovitch}
are smaller by a factor of the order of $L^4$, where $L$ is the MD
cell edge, than those useful when the dynamics is given by
equation~\ref{eqn:par}.}

\subsection{Constrained \textit{\textbf{h}} Matrix}
Nos\'{e} and Klein\cite{nose:83} describe and address the problem of
the whole MD cell rotating during the course of the simulation.  This
is because angular momentum is not conserved in a periodic system, and
because the $\bm{h}$ matrix has 9 degrees of freedom, three more than
needed to specify the position and orientation of the MD cell.  Their
solution is to constrain the $\bm{h}$ matrix to be symmetric, and
involves a modification of the Parrinello-Rahman equations.

\moldy\ incorporates a different constraint which is 
simpler to implement (as it does not require modification of the
equations of motion) and which also has a more obvious physical
interpretation.  The three sub-diagonal elements of the $\bm{h}$
matrix are constrained to zero.  That is, the MD cell vector
$\bm{a}$ is constrained to lie along the $x$-axis and $\bm{b}$ is
constrained to lie in the $xy$-plane.  Physically this may be thought
of as implementing an MD box lying on a horizontal surface under the
influence of a weak gravitational field.  The implementation is
trivial; at each timestep the acceleration of those components,
$\ddot{\bm{h}}_{ij}$, is set to zero which is equivalent to adding a
fictitious opposing force.

This constraint technique is not restricted merely to eliminating
redundant degrees of freedom, but can also be used for other purposes.
For example it may be used to allow uniaxial expansion only.  
MD cell constraints are selected using the control parameter
\Lit{strain-mask} (see section~\ref{sec:cp-constraints}).  A value of
238 will freeze all of the off-diagonal components of $\bm{h}$.

\subsection{Constant Pressure}

The above $\bm{h}$ matrix constraints are not adequate for
simulations of liquids at constant pressure.  Since a liquid can not
support shear stress there is no restoring force to keep the
simulation cell nearly cubic, and it will therefore drift to a
parallelepiped or elongated shape.  \moldy\ also supports an
alternative constraint which only permits isotropic MD cell
expansion.  The isotropic variant of
equation~\ref{eqn:wentzcovitch} gives 
\begin{equation}
  \label{eqn:went-unif}
    W\ddot{\bm{h}} = \frac{1}{3 V}\textnormal{Tr}\left ( \bm{\pi} - p \right ) \bm{h} 
    -\frac{2 W}{9} \left ( \frac{\dot{V}}{V}\right )^2 \bm{h}
\end{equation}
and if the cell is cubic this is equivalent to the 
constant-pressure dynamics of Andersen\cite{andersen:80}, with
$W$ = $3 M_\textnormal{Andersen}$.

Applying a uniform-dilation constraint to the Parrinello-Rahman
Lagrangian gives equations of motion
\begin{equation}
  \label{eqn:p+r-unif}
  W\ddot{\bm{h}} = V \frac{\textnormal{Tr}\left ( \bm{\pi} - p \right)}{
    \textnormal{Tr}\left (  \bm{h'} \bm{h} \right )}\bm{h}
\end{equation}
which replace equation~\ref{eqn:rahman}.

Both of the above equations cause the MD cell to dilate or contract
uniformly, and apply whether or not the initial $\bm{h}$-matrix
corresponds to a cubic cell.  It is therefore possible to switch
between a constant-stress and the corresponding constant-pressure
ensemble during a run.  This is the only reason to choose
equation~\ref{eqn:p+r-unif}.  
Equation~\ref{eqn:went-unif} (selected by \Lit{const-pressure=4}) is
normally  the best option for liquid simulations.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Radial Distribution Functions}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%`
\label{sec:rdf}
The \emph{radial distribution function} or RDF is one of the most
important structural quantities characterizing a system, particularly
for liquids.  For a one-component system, the RDF is defined
as\cite[p445]{hansen:86}
\begin{eqnarray}
g(r) & = & \frac{1}{\rho^2} \left < \sum_i \sum_{j\neq i}
\delta(\bm{r} + \bm{r}_i - \bm{r}_j) \right > \\ \nonumber
 &  \approx  & V \left < \delta(\bm{r} + \bm{r}_1 - \bm{r}_2) \right >
\end{eqnarray}
where we use the angle brackets to denote a spherical average as well
as the usual configurational average.  Allen and
Tildesley\cite[pp184,185]{allen:87} describe how to evaluate $g(r)$
from a histogram of pair distances accumulated during a simulation
run. With the notation that $N$ is the total number of particles, $b$
is the number of the histogram bins, $\delta r$ is the bin width (so
that $r = b \delta r$), $n_{\textnormal{his}}(b)$ is the accumulated
number per bin, $\tau$ is the number of steps when binning was carried
out
\begin{equation}
\label{eqn:rdf-atom}
g(r + \delta r/2) = \frac{3 n_{\textnormal{his}}(b)}{4 \pi \rho N \tau
  [(r + \delta r)^3 - r^3]} 
\end{equation}
In the case of a molecular system, the partial RDF for atoms
$\alpha$ and $\beta$ is defined as\cite[p 445]{hansen:86}
\begin{equation}
g_{\alpha \beta}(r) = \frac{1}{\rho^2 V} \left < N(N-1)\delta(\bm{r} +
  \bm{r}_{1\alpha} - \bm{r}_{2\beta}) \right > 
\end{equation}
which may be rewritten more usefully for an arbitrary multi-component
mixture by eliminating the molecular density $\rho$ and number $N$ as
\begin{equation}
g_{\alpha \beta}(r) = V \left < \delta(\bm{r} +  \bm{r}_{1\alpha} -
  \bm{r}_{2\beta}) \right > 
\end{equation}
In the simulation this is evaluated by an expression very similar to
equation~\ref{eqn:rdf-atom}
\begin{equation}
\label{eqn:rdf-site}
g_{\alpha \beta}(r + \delta r/2) = \frac{3 N n_{\textnormal{his}}(b)}{4 \pi
\rho N_\alpha N_\beta \tau [(r + \delta r)^3 - r^3]}
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Initial Configuration}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
One of the more trying aspects of initiating a molecular dynamics
simulation is getting it started in the first place.  It is not hard
to see the reason why.  An MD integration algorithm will only generate
a good approximation to the correct equations of motion if the forces
and velocities of the particles are less than some value.  The
timestep is chosen so that this criterion is satisfied for
near-equilibrium configurations.  But if the configuration is far from
equilibrium certain forces may be extremely large (due to atoms
approaching each other too closely).  And worse, the breakdown of the
integrator leads to breakdown of the conservation laws and the
system evolves to a state even further from equilibrium.

One way around this difficulty is to start the system from a
configuration known to be near-equilibrium, such as a known crystal
structure.   For a solid-state simulation this is the method of
choice, and \moldy\ allows any initial structure to be specified and
replicated to fill the MD cell.  In the case of a liquid, a
crystalline initial state is less desirable, and indeed, none may be
known.  Furthermore such a starting configuration restricts the
allowed number of molecules to a multiple of the number in the unit
cell and worse, may force the use of a non-cubic MD cell.

\moldy\ incorporates a novel method of generating an initial
configuration which, in the main, overcomes these problems.
\subsection{The Skew Start Method}
\label{sec:skewstart}
The essence of the \emph{Skew Start} method is to generate a
configuration which, though not periodic in 3 dimensions, nevertheless
is sufficiently regular to guarantee a minimum separation between
molecular centres of mass.  Figure~\ref{fig:skewstart} demonstrates
the principle in 2 dimensions.

\begin{figure}
\setlength{\unitlength}{0.012500in}%
\input{fig_skewstart.ftx}
\caption[The Skew Start method]{The Skew Start method.  $N$ molecules
  are placed at evenly-spaced intervals, $a$, on a line joining a
  corner of the MD cell to its image $k$ cells away (5 in this
  illustration).  When mapped back into the original cell this
  guarantees a minimum separation of $min(d,a)$.}
\label{fig:skewstart}
\end{figure}

The $N$ molecules are placed at some suitable interval, $a$, on a line
drawn between one corner of the MD cell (of side $L$) and one of its
periodic images.  Clearly the index $(h,k)$ of the image cell corner
should be chosen so that the molecule spacing, $a$, is close to the
spacing of the line's images, $d$. For simplicity, choose $k=1$ which
leads to the condition:
\begin{eqnarray}
\nonumber
a = \frac{L \sqrt{h^2+1}}{N} &\approx& \frac{L}{\sqrt{h^2+1}} = d \\
 \Rightarrow h &\approx& \sqrt{N-1}
\end{eqnarray}
Therefore the optimum value of $h$ is the nearest integer to
$\sqrt{N-1}$.  

The formalism may be extended to three dimensions, and yields the
results for the molecular and ``inter-line'' spacings $a$, $d_y$ and
$d_z$ respectively
\begin{eqnarray}
\label{eqn:skew-hkl}
\nonumber
a & = & \frac{L}{N}\sqrt{h^2+k^2+l^2}\\
d_y  & = & L \frac{\sqrt{k^2+l^2}}{\sqrt{h^2+k^2+l^2}} \\
d_z & \approx & L\frac{l}{k} \qquad\textnormal{(assuming $h/k$ is an integer)}
\nonumber
\end{eqnarray}
The ``equal spacing'' requirements are satisfied approximately by
\begin{eqnarray}
  \nonumber
  h & \approx & N^{2/3} \\
  k & \approx & N^{1/3} \\
  \nonumber
  l & = & 1
\end{eqnarray}
which when substituted into equation~\ref{eqn:skew-hkl} yields
\begin{equation}
  a \approx d_y \approx d_z \approx LN^{-1/3}
\end{equation}

Using this method an arbitrary number of molecules may be packed into
a cubic cell with a guaranteed minimum centre-of-mass separation of
approximately $LN^{-1/3}$.  In contrast to other methods, such as
random placement with excluded volume, it will always yield a
configuration no matter how high the density.  It is also very simple
to implement.

It still remains to determine the initial orientations of the
molecules in the case of polyatomics.  In the current implementation
these are assigned randomly, which works well for small or
near-spherical molecules.  Further refinements which may help avoid
overlaps for elongated molecules are possible, such as a periodic
sequence of orientations along the line, but no investigation of this
possibility has yet been carried out.

In practice the method has proved to work well for water and aqueous
systems and always yields a configuration which may be evolved towards
equilibrium by the MD equations of motion.  Any feedback on its
performance in more difficult cases will be welcome.

\subsection{Initial Velocities}
\label{sec:velinit}
It remains to choose the initial velocities of the molecules to
complete the specification of the initial configuration.  The recipe
is the same irrespective of whether the molecules are started on a
lattice or from a skew start.  The initial centre-of-mass velocities
are chosen from the Maxwell-Boltzmann distribution at the temperature
specified for the simulation\cite[pp 170]{allen:87}.  That is, the
velocities are chosen from a set of random numbers with a Gaussian
distribution and normalized so that the probability density $p(v)$ of
the $xyz$ component of the velocity $v_{ik}$ of molecule $k$ is
\begin{equation}
p(v_{ik}) = \left ( \frac{m_k}{2 \pi k_B T}\right )^{1/2} 
\exp(-\frac{m_k v_{ik}^2}{2 k_B T})
\end{equation}
This is easily accomplished given a random number generator which
samples from a Gaussian distribution with unit variance.  Given a
random number $R_{ik}$, each component of velocity is set to
\begin{equation}
v_{ik} = \sqrt{\frac{k_B T}{m_k}} R_{ik}
\end{equation}
Each component of the angular velocity (expressed in the
principal frame) has a probability distribution
\begin{equation}
p(\omega^p_{ik}) = \left ( \frac{I_{ik}}{2 \pi k_B T}\right )^{1/2}
\exp(-\frac{I_{ik} (\omega^p_{ik})^2}{2 k_B T})
\end{equation}
which is ensured by assigning a random velocity
\begin{equation}
\label{eqn:omega-rand}
\omega^p_{ik} = \sqrt{\frac{k_B T}{I_{ik}}} R_{ik}
\end{equation}

Since the dynamical variables used by \moldy\ for the angular
co-ordinates are in fact the quaternions and their derivatives, we
must set the quaternion derivatives and accelerations to the corresponding
values. Using equations~\ref{eqn:qomega} and~\ref{eqn:qddot} we
have
\begin{equation}
\Quat{\dot{q}} = \Quat{q}(0,\bm{\omega}^p/2)
\end{equation}
and
\begin{equation}
\Quat{\ddot{q}} = -\frac{1}{4}(\omega^p)^2 \Quat{q}
\end{equation}

Finally, we note that if a molecule has less than three degrees of
freedom, that is $I_{ik}=0$ for some $i$, the corresponding angular
velocities \etc\ are simply set to zero.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Frameworks}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:frameworks}
In addition to the bulk properties of solids and liquids, much
attention has been devoted in recent years to using MD simulation to
model atoms or molecules interacting with surfaces or other structures
such as zeolites.  The distinctive feature of such a situation is that
the 2- or 3-dimensional surface or structure is larger than the
interacting molecules by many orders of magnitude.  In fact the
idealization of this system makes the structure infinite in extent.
An atomistic model of this kind of a system necessitates choosing the
periodic boundary conditions of the MD cell to be commensurate with
the periodicity of the surface or structure.  This manual will refer
to an infinitely repeating crystalline surface or structure as a
\emph{framework}.

There are two possible formulations of a system of this kind for use
in an MD simulation.  Firstly the framework may be modelled as a set of
independent atoms interacting via pair potentials.  This merely
requires specifying the correct initial structure and MD cell plus a
suitable set of pair potentials. The latter model both the internal
forces which determine the crystal structure of the framework and its
interaction with the atoms or molecules of the fluid.  Conceptually
there is no distinction between this situation and a regular solid or
liquid system, and the mechanics of initiating a simulation are
handled in exactly the usual manner.

However there are situations in which this ``atomic'' approach is
impractical.  Because the system being modelled is essentially
``two-phase'' the atoms of the framework find themselves under the
influences of two distinct kinds of force.  There are the strong
forces, usually covalent or ionic, which bind the atoms to form the
framework itself and the weaker, non-bonded forces of the interaction
with the fluid.  Ideally these could all be modelled by a single
consistent set of interatomic potentials which are sufficiently
transferable to yield an accurate crystal structure for the framework
as well as the molecular structure of the fluid and its interaction
with the surface.  Regrettably such potentials are hard to find.

Furthermore the characteristic vibrational frequencies of the solid
framework will probably be much higher than those of the fluid.
Consequently the timestep must be chosen sufficiently small to
accurately model the crystalline vibrations.  This will usually be far
smaller than the value required for the fluid, necessitating very
lengthy MD runs to model both regimes properly.  This is, of course,
exactly the argument used to justify rigid-molecule models. 

\moldy\ implements a variation on the rigid-molecule model to simulate
a rigid framework structure periodically extended throughout space.
There are a few subtleties which must be correctly handled to achieve
a consistent implementation, which are described hereafter.  

\subsection{Implementation}
The framework is in many respects exactly like an ordinary molecule.
It should be defined to exactly fill the MD cell so that the
periodic repeat of the cell generates the periodicity of its
crystal structure.  The distinctive features of a framework molecule are:
\begin{itemize}
\item The framework is fixed in space and is not allowed to rotate. 
Any rotation would of course destroy the 3D structure.  For most
purposes it is convenient to regard the framework as being at rest, hence
translational motion is forbidden also.
\item No interactions between sites on a framework molecule and on itself
or any of its periodic images are evaluated.  That is,
framework-framework interactions, both potentials and forces, are
systematically excluded from the real-space and reciprocal-space parts
of the Ewald sum, including the point and intra-molecular self terms
of equation~\ref{eqn:ewald}. (The exact modifications to
equations~\ref{eqn:ewald},\ref{eqn:ewald-force} \etc\ are left as an
exercise for the reader.)
\item In the real-space force calculation, sites are treated as being
independent atoms rather than belonging to a molecule.  In particular
the cutoff is applied on the basis of the (framework) site to (fluid)
molecule distance.  By virtue of the ``all-image'' convention, all the
requisite molecule-framework interactions are correctly
included.  When assigning sites to sub-cells, each site is therefore
placed in the sub-cell which contains its co-ordinate.  (By contrast
sites belonging to an ordinary molecule are placed in the cell which
contains the molecular centre of mass.)
\end{itemize}

With these modifications, \moldy\ is able to successfully model a fluid
in contact with a 3D rigid framework. 2-dimensional systems such as a
fluid at a surface or between two surfaces may be represented as a 3D
system by adding an artificial periodicity in the third dimension. To
reduce the errors so introduced, the framework can be made ``large
with space inside'' to fill an MD cell with a large $c$-axis.  

In the case of a 3D framework it is clearly not sensible to allow the
MD cell to change shape or size, since this would destroy the internal
structure of the framework.  However if the framework represents a 2D
layer or surface, then the layer spacing may be allowed to vary using
the constant-stress equations (section~\ref{sec:const-stress}) and
applying constraints to allow only the $c$-axis to fluctuate.  In that
case, bear in mind that the dynamics are governed by the
Parrinello-Rahman equations of motion for the cell, rather than the
Newtonian equations for the layer.  In particular the mass is given by
the parameter $W$ rather than the mass of the framework molecule.
(These may, of course be set equal if required.)  Note also that no
layer-layer interactions are calculated, and any force is the result
of the externally applied pressure.\footnote{This is a restriction of
  the current implementation and may be lifted in future versions.}

Finally there are two subtle complications which arise from the
framework concept.

\subsection{Stress and Pressure Undefined}
There is no unique definition of the internal stress or pressure of a
framework system.    The pressure of a system in a space with periodic
boundary conditions  is defined in terms of the molecular virial
\begin{equation}
\label{eqn:virial}
\mathcal{W} = \frac{1}{3} \sum_{i=1}^N \sum_{j \neq i}^N \bm{R}_{ij}
\cdot \bm{F}_{ij}
\end{equation}
But the framework has no centre-of-mass, and so the quantity
$\bm{R}_{ij}$ can not be defined.  The site-virial formulation of
equation~\ref{eqn:stress-sr} is of no assistance as the definition of the
``internal'' co-ordinate $\bm{p}_{i\alpha}$ involves the centre of
mass co-ordinate $\bm{R}_i$.  Neither can one simply choose a
convenient reference $\bm{R}_i$.  Since the force exerted by the fluid
acting on the framework is in general non-zero, the term
\begin{equation}
\sum_i \sum_\alpha \bm{p}_{i\alpha} \bm{f}_{i\alpha}
= \sum_i \sum_\alpha \bm{r}_{i\alpha} \bm{f}_{i\alpha}
- \sum_i \bm{R}_i \bm{F}_i
\end{equation}
clearly depends on $\bm{R}_i$.  The situation may also be viewed
physically.  The definition of pressure of a system is the derivative
of the free energy with respect to volume.  But with an infinite rigid
framework the volume derivative can not be defined.

The useful quantity in this case is the partial pressure of the
fluid.  Though not currently implemented, this may be rectified in a
future version of \moldy.

Finally we note that in the case of a 2D layer structure, which is
\emph{not} rigid in the third dimension, the perpendicular component of
the stress tensor \emph{does} have a physical meaning and is correctly
calculated. 
 
\subsection{Charged Frameworks}
A minor complication arises when using a framework which has a
non-zero net electric charge.  Although the system as a whole may be
electrically neutral, the omission of  framework-framework
interactions from the calculation also means that the
$\bm{k}=0$ term does not vanish.  To see this examine
equation~\ref{eqn:ewald}.  In the non-framework case the indices $i$
and $j$ in the terms
\begin{displaymath}
\left | \sum_{i=1}^{N} q_i \cos(\bm{k \cdot r}_i) \right |^2 
  = \sum_{i=1}^{N} \sum_{j=1}^{N} q_i q_j 
    \cos(\bm{k \cdot r}_i)\cos(\bm{k \cdot r}_j) 
\end{displaymath}
run over all site pairs.  If $\bm{k}=0$
the squared sum is 
\begin{displaymath}
\left | \sum_{i=1}^{N} q_i \right |^2 = 0
\end{displaymath}
If a framework is present the formulation becomes
\begin{displaymath}
\left | \sum_{i=1}^{N} q_i \cos(\bm{k \cdot r}_i) \right |^2 
-
\left | \sum_{i=M\!+\!1}^{N} q_i \cos(\bm{k \cdot r}_i) \right |^2 
\end{displaymath}
assuming sites $M+1 \ldots N$ are the framework sites.  On setting
$\bm{k}=0$ this reduces to
\begin{displaymath}
\left | \sum_{i=1}^N q_i \right |^2 - \left | \sum_{i=M\!+\!1}^N q_i \right |^2
\end{displaymath}
It is therefore necessary to modify the charged-system term of
equation~\ref{eqn:ewald} to
\begin{equation}
U_z = - \frac{1}{8 \epsilon_0 V \alpha^2}
\left \lbrace
\left | \sum_{i=1}^N q_i \right |^2 - \left | \sum_{i=M\!+\!1}^N q_i \right |^2
\right \rbrace
\end{equation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Running Moldy}  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The way \moldy\ is invoked depends to some extent on the operating
system, but usually by issuing the command \Lit{moldy}.\footnote{On
  VMS, \Lit{moldy} may be defined as a foreign command by \Lit{\$
    moldy :== \$mydisk:[mydir]moldy}} For Unix(tm) Windows 95 and NT
and MS-DOS the executable file \Fname{moldy} or \Fname{MOLDY.EXE}
should be placed in the shell search path (\eg\ in the current
directory)\footnote{It is important that the \Fname{dumpext} utility
  is found in a directory in the shell search path as it is invoked by
  several of the other utilities to read dump files.}. There is no GUI
and \moldy\ should always be run from a command line, from a terminal
window under Unix or a MS-DOS window under Windows 95/NT.  There are
two optional arguments - the name of the control file (see
section~\ref{sec:control}) and the output file (see
section~\ref{sec:output}).  If either is omitted, control input is
read from the ``standard input'' which may be a terminal or a job
command file depending on the operating system and circumstances, and
the output is written to ``standard output'' which may be a terminal
or batch job logfile.\footnote{Some operating systems (Unix and
  MS-DOS) allow \emph{file redirection} whereby the standard input is
  associated with some file.  This may also be used to supply the
  control file, provided that no command line parameter is given.}
Here are examples for VAX/VMS and Unix (tm), which assume that in each
case the command has been set up to invoke \moldy.  Under VMS the
commands
\begin{verbatim}
        $ moldy control.dat output.lis
        $ moldy control.dat
\end{verbatim}
will start \moldy\  which will read its input from \Fname{control.dat}.
The output will be directed to the file \Fname{output.lis} in the first
case and written to the terminal or batch log in the second.  Under
UNIX any of
\begin{verbatim}
        % moldy < control > output.lis
        % moldy control output.lis
        % moldy control
\end{verbatim}
will cause moldy to read from the file called \Fname{control} and in
the first two examples to write its output to \Fname{output.lis}.  The
command-line interface for Windows and MS-DOS is very similar. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Control File}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:control}

The information needed to initiate and control a run of \moldy\ is
specified in a file known as the \emph{control file}. This contains
the parameters governing the run \eg\ the number of timesteps to be
executed or the frequency of output, and the names of files to be used
\eg\ for reading a restart configuration from or for writing the
output to. Parameters in the control file are specified by entries of
the form \Lit{keyword~=~value} which appear one to a line,
terminated by the special keyword \Lit{end}.  Spaces and blank
lines are ignored as are comments (\ie\ the remainder of a line
following a \Lit{\#}~symbol) and keywords may be entered in upper
or lower case. For example
\begin{verbatim}
   title= Moldy example      # This is a comment

   # The above blank line is ignored
   nsteps = 1000
   step=0.0005
   restart-file = RESTART.DAT
   end                       # The control file ends here
\end{verbatim}
sets the title of the simulation to ``Moldy example'', the number of
steps to execute to 1000, the timestep to 0.0005 ps and supplies the
name of a restart file to read from.

It is not necessary to specify all of the parameters on each run.
Unless it is explicitly assigned a value in the control file, each
parameter has a default value.  This is either the value listed in
table~\ref{tab:parameters} or, in the case where the simulation is
continuing from a restart file, the value it had on the previous run
(see section~\ref{sec:restarting}). Parameters are read in sequence
from the control file and if one appears more than once only the final
instance is used.

The two most important parameters are \Lit{step} which sets the
size of the simulation timestep (in ps), and \Lit{nsteps} which
specifies the number of steps to perform.  Together these control the
length of time to be simulated.  It is also possible to specify that a
run should be terminated after a certain amount of computer time has
been used - given by parameter \Lit{cpu-limit}.  This will be
particularly useful in batch mode systems, where the run is killed
after some specified CPU time has elapsed.  Setting \Lit{cpu-limit}
to the maximum time allowed will cause \moldy\ to terminate the run
\emph{before} the limit is reached and write out a backup file (see
section~\ref{sec:backup}).

There are several kinds of parameters:
\begin{description}

\item[character strings] Apart from \Lit{title} these are just file
names \eg\ \Lit{sys-spec-file}.  No checks
are performed on the validity of the name (because \moldy\  has to work
on many different computer systems), so if you make a mistake you are
likely to get an error message to the effect that \moldy\  couldn't find
the file you asked for.  To remove a default value, just specify a
null string \eg\ \Lit{save-file = }.

\item[booleans] These are just switches which turn a feature off or
on. `0' means off or false and `1' means on or true. The parameters
\Lit{text-mode-save}, \Lit{new-sys-spec}, 
\Lit{surface-dipole} and \Lit{lattice-start} are booleans.

\item[real parameters] Several parameters are real numbers \eg\
\Lit{step} which specifies the timestep.  They may be entered in the
usual floating point or scientific notation \eg\ \Lit{step~=~0.0005}
or \Lit{step~=~.5e-3}, and are taken to be in the units given in
table~\ref{tab:parameters}.

\item[integer parameters] Parameters such as \Lit{dump-level} take a
numeric value, which should be an integer.

\item[timestep-related parameters] Several parameters govern when some
calculation begins and ends and how frequently it is performed in
between. These are known as ``begin'', ``end'' and ``interval''
parameters, but are really a special case of integer parameters.  For
example \Lit{begin-average}, \Lit{dump-interval} and
\Lit{scale-end}.  The calculation begins \emph{on} the timestep
specified on the \Lit{begin} parameter, occurs every \Lit{interval}
timesteps thereafter and ends \emph{after} the timestep specified by
the \Lit{end} parameter.  Setting the \Lit{interval} parameter to
zero is the usual method of turning that calculation off.

The \Lit{begin} and \Lit{end} parameters behave in a special fashion
when the simulation is continued from a restart file; they are
interpreted \emph{relative} to the current timestep.  Notice especially
that \Lit{nsteps}, the number of timesteps is treated in this way.

\end{description}

A complete list of the parameters,
their meanings and default values appears in
table~\ref{tab:parameters}. 

\afterpage{%
\begin{longtable}{|l|l|l|>{\saferagged}p{2.9in}|}
\caption{Control Parameters}\\\hline
\textbf{name} & \textbf{type} & \textbf{default} & \textbf{function}\\\hline\hline
\endfirsthead
%begin{latexonly}
\caption[]{Control Parameters (\emph{continued})}\\\hline
%end{latexonly}
\textbf{name} & \textbf{type} & \textbf{default} & \textbf{function}\\ \hline\hline
\endhead
\hline
\endfoot
\setlength{\rightskip}{0pt plus 2cm}
\label{tab:parameters}
\Lit{title} &                  character  & {\small Test Simulation} &
A title to be printed on all output. \\
\Lit{nsteps} &                 integer &                       0 &
Number of MD steps to execute. \\
\Lit{cpu-limit} &              real &                  1e20 &
Terminate run if excessive CPU time used. \\
\Lit{step} &                   real &                  0.005 &
Size of timestep (in ps)\\ \hline
\Lit{sys-spec-file} &          character  &    null &
Name of system specification file.  Appended to control file if null. \\
\Lit{lattice-start} &          boolean &               false  &
Switch for crystalline initial configuration. \\
\Lit{save-file} &              character  &    null &
File to save restart configuration in. \\
\Lit{restart-file} &           character  &    null &
File to read restart configuration from. \\
\Lit{new-sys-spec} &           boolean &               false  &
Read restart configuration with changed system specification. \\
\Lit{text-mode-save} &         boolean &               false &
Write a portable ``restart'' file consisting of control, system
specification and lattice start files. \\ \hline
\Lit{density} &                real &                  1.0 &
Initial density in g\,cm$^{-3}$.  Used by \emph{skew start} only to
determine initial MD cell dimensions. \\ \hline
\Lit{scale-interval} &         integer &               10 &
Number of steps between velocity scalings. \\
\Lit{scale-end} &              integer &               1000000 &
When to stop scaling. \\
\Lit{const-temp} &             integer &               0 &
1 for Nos{\'e}-Hoover, 2 for Gaussian thermostat. \\
\Lit{ttmass} &                 real &                  100 &
Translational inertia parameter for Nos{\'e}-Hoover thermostat 
(kJ\,mol$^{-1}$\,ps$^2$).\\
\Lit{rtmass} &                 real &                  100 &
Rotational inertia parameter for Nos{\'e}-Hoover thermostat 
(kJ\,mol$^{-1}$\,ps$^2$).\\
\Lit{scale-options} &           integer &              0  &
Select variations on scaling or thermostat. \\
\Lit{temperature} &            real &                  0 &
Temperature of initial configuration for scaling and thermostat (K). \\ \hline
\Lit{const-pressure} &         integer &               0  & %
\noindent%
\begin{list}{}{%
\vspace{-\topsep}\vspace{-\partopsep}%
\setlength{\partopsep}{0pt}%
\setlength{\topsep}{0pt}%
\setlength{\leftmargin}{1em}%
\setlength{\itemsep}{0pt}%
\setlength{\parsep}{0pt}%
}
\item[1] Parrinello and Rahman constant stress
\item[2] P-R compatible constant pressure ensemble
\item[3] Wentzcovitch/Cleveland constant stress
\item[4] Andersen constant pressure.
\end{list}
\vspace{-\topsep}\vspace{-\partopsep}\\
\Lit{w} &                      real &                  100.0 &
Extended system mass parameter (amu). \\
\Lit{pressure} &               real &                  0 &
External applied pressure (MPa). \\
\Lit{strain-mask} &            integer &               200 &
Bitmask controlling $\bm{h}$ matrix constraint. \\ \hline
\Lit{alpha} &                  real &                  \emph{auto} &
$\alpha$ parameter for Ewald sum. Set any negative value to disable Ewald sum.\\
\Lit{k-cutoff} &               real &                  \emph{auto} &
Reciprocal space cut off distance in {\AA}$^{-1}$. \\
\Lit{cutoff} &                 real &                  \emph{auto} &
Direct space cutoff distance in {\AA}. \\
\Lit{strict-cutoff} &          boolean &               false &
Flag to select rigorous or cheap but approximate cutoff algorithm. \\
\Lit{surface-dipole} & boolean &               false  &
Include surface dipole term in Ewald sum. \\ \hline
\Lit{roll-interval} &          integer &               10 &
Period over which to calculate rolling averages. \\
\Lit{print-interval} &         integer &               10 &
How frequently to print normal output. \\ \hline
\Lit{begin-average} &          integer &               1001 &
When to start accumulating the thermodynamic averages. \\
\Lit{average-interval} &       integer &               5000 &
How frequently to calculate and print averages. \\
\Lit{reset-averages} &         boolean &               false  &
Discard accumulated averages in restart file. \\ \hline
\Lit{begin-rdf} &              integer &               1000000 &
When to start accumulating radial distribution function information. \\
\Lit{rdf-interval} &           integer &               20 &
How frequently binning calculation is performed. \\
\Lit{rdf-out} &                integer &               5000 &
How frequently to calculate and print RDFs. \\
\Lit{rdf-limit} &              real &                  10 &
Calculate RDFs up to what distance? ({\AA}) \\
\Lit{nbins} &                  integer &               100 &
Number of binning intervals between 0 and rdf-limit. \\ \hline
\Lit{xdr} &                    boolean &               true &
Write restart,  backup and dump files in portable
binary format using Sun XDR. \\ \hline
\Lit{dump-file} &              character  &    null &
Template of file names used for data dumps. \\
\Lit{begin-dump} &             integer &               1 &
Timestep to begin dumping at. \\
\Lit{dump-interval} &          integer &               20 &
How frequently to perform dumps. \\
\Lit{dump-level} &             integer &               0 &
Amount of information to include in dump. \\
\Lit{ndumps} &         integer &               250 &
Number of dump records in each dump file. \\ \hline
\Lit{backup-interval} &        integer &               500 &
Frequency to write backup file. \\
\Lit{backup-file} &            character  &    \Fname{MDBACKUP} &
Name of backup file. \\ \hline
\Lit{temp-file} &              character  &    \Fname{MDTEMPX} &
Name of temporary file used for writing restart configurations. \\ \hline
\Lit{subcell} &                real &                  0 &
Size of sub-cell (in {\AA}) to divide MD cell into for link cell force
calculation. \\ \hline
\Lit{seed} &                   integer &               1234567 &
Seed for random number generator. \\ \hline
\Lit{page-width} &             integer &               132 & 
Number of columns on output paper. \\
\Lit{page-length} &    integer &               44 &
Number of lines on a page of output. \\ \hline
\Lit{mass-unit} &              real &                  1.6605655e-27 &
Unit of mass for system specification file. \\
\Lit{length-unit} &            real &                  1e-10 &
Unit of length for system specification file. \\
\Lit{time-unit} &              real &                  1e-13 &
Unit of time for system specification file. \\
\Lit{charge-unit} &            real &                  1.6021892e-19 &
Unit of charge for system specification file. \\ \hline
\end{longtable}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Setting up the System}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{System Specification}
\label{sec:sys-spec}

The information which describes to \moldy\  the system to be simulated
and the interaction potentials is contained in a file known as the
\emph{system specification file}.  This may be presented to \moldy\  in
either of two ways: If the control file parameter \Lit{sys-spec-file}
is null or absent, it is assumed to be appended to the end of the
control file.  Otherwise it is read from the file whose name is
the value of \Lit{sys-spec-file}.

This file is divided into two sections.  First is the description of
the molecules, atoms or ions, which is followed by the potential
functions.  As for the control file, the input is case independent and
free format, but line structured. Blank lines, spacing and comments
are ignored.

\pagebreak[3]
The physical description consists of a series of entries, one for each
molecular species, terminated by the keyword \Lit{end}. The entry
for species $i$ should have the form
\begin{displaymath}
\begin{array}{lllllll}
\multicolumn{7}{l}{\textit{species-name}_{i} \quad N_{i}}  \\
id_{1} & x_{1} & y_{1} & z_{1}&  m_{1} & q_{1} & name_{1} \\
id_{2} & x_{2} & y_{2} & z_{2}&  m_{2} & q_{2} & name_{2} \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
id_{n_{i}} & x_{n_{i}} & y_{n_{i}} & z_{n_{i}}& 
m_{n_{i}} & q_{n_{i}} & name_{n_{i}} \\
\end{array}
\end{displaymath}
where \textit{species-name}$_{i}$ is the name of the molecule and $N_{i}$
is the number of molecules of that type in the system. Each molecule
has $n_{i}$ atoms, one for each line in that group and each kind of
atom is identified by a number $id_{i}$ (the site id) which will be
used to specify the appropriate potential parameters. Its co-ordinates
are $(x_{i},y_{i},z_{i})$, its mass is $m_{i}$, its charge is $q_{i}$
and its name is $name_{i}$.  See Appendix~\ref{sec:examples} for some
sample system specification files.

If there is more than one atom of any type (in the system - not just
the same molecule) it is sufficient to identify it by its $id$ (and
the site co-ordinates!).  If $m_{i}$, $q_{i}$ or $name_{i}$ \emph{are}
given they must agree exactly with the previous values or an error
will be signalled.

Site ids, masses and charges are all checked for `reasonableness'
and impossible values cause an error. The set of site ids does not
have to start at 1 or be contiguous, but since this may indicate a
mistake, a warning is issued.

Following the physical specification is the specification of the
potential functions. This takes the form
\begin{displaymath}
\begin{array}{llllll}
\multicolumn{4}{l}{\textit{potential-type}} \\
i & j & p^{1}_{ij} & p^{2}_{ij} & \ldots & p^{r}_{ij}  \\
k & l & p^{1}_{kl} & p^{2}_{kl} & \ldots & p^{r}_{kl}  \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
m & n & p^{1}_{mn} & p^{2}_{mn} & \ldots & p^{r}_{mn}  \\
\Lit{end} \\
\end{array}
\end{displaymath}
where \emph{potential-type} is one of the keywords
\Lit{Lennard-Jones}, \Lit{Buckingham}, \Lit{MCY}, \Lit{generic},
\Lit{morse} or \Lit{hiw} to identify the kind of potentials to be
used, $i, j, k, l, m, n$ are site ids and $p^{\alpha}_{ij}$ is the
$\alpha^{th}$ potential parameter between sites $i$ and $j$.  There should
be one line for each distinct pair of site ids.  If any pair is
omitted a warning is issued and the parameter values are set to zero.

The meaning of the parameters for the currently defined potentials is
as follows:
\begin{Litdescription}
\item[Lennard-Jones] The potential is 
\[\phi(r_{ij}) = \epsilon((\sigma/r_{ij})^{12} -
(\sigma/r_{ij})^{6}),\] and has two parameters, $\epsilon ( \equiv p^{1}_{ij})$
and $\sigma ( \equiv p^{2}_{ij})$, which occur on each line in that
order.  Note that the definition of $\epsilon$ \emph{includes} the
factor of 4 more usually separated out.  The control parameter
\Lit{time-unit} may be divided by four to read potentials
specified in the standard form.

\item[Buckingham] This includes potentials of the Born-Mayer type and
has formula \[\phi(r_{ij}) = -A_{ij}/r^{6}_{ij} + B_{ij}\exp(-C_{ij}r_{ij}).\]
The three parameters appear on each line in the order $A, B, C$.
\item[MCY] This type supports potentials of the form of the water
model of Matsuoka, Clementi and Yoshimine\cite{matsuoka:75}, 
\[\phi(r_{ij}) = A_{ij}\exp(-B_{ij}r_{ij}) - C_{ij}\exp(-D_{ij}r_{ij}),\]
and the four parameters appear on the line in the order $A, B, C, D$.
\item[generic] This contains a number of inverse power terms and
  an exponential repulsion in support of ionic solution models.
  It takes the form
\[\phi(r_{ij}) = A_{ij} \exp(-B_{ij}r_{ij}) + C_{ij}/r_{ij}^{12} -
  D_{ij}/r_{ij}^4 -E_{ij}/r_{ij}^6 -F_{ij}/r_{ij}^8\]
with the six parameters $A_{ij}$ -- $F_{ij}$.
\item[morse] This is the Busing-Ida-Gilbert plus Morse-potential as
  used in the Japanese MD program Mxdorto.  It has the form
\[\phi(r_{ij}) = B_{ij}  exp ((C_{ij}-r_{ij})D_{ij})   - E_{ij}/r_{ij}^6 + F_{ij} \exp (-2G_{ij}(r_{ij}-H_{ij})) - 2F_{ij}\exp (-G_{ij}(r_{ij}-H_{ij}))\]
with seven parameters $B_{ij}$ -- $H_{ij}$.
\item[HIW]  This is a Lennard-Jones potential with an extra
  fourth-power term to describe ion-water interactions in solution
  using the \emph{HIW} model of R. R Pappalardo and
  E. Sanchez-Marcos\cite{pappalardo:93}.  The form is
\[\phi(r_{ij}) =  A_{ij}/r_{ij}^4 + B_{ij}/r_{ij}^6 + C_{ij}/r_{ij}^{12}\]
\end{Litdescription}
\noindent
Other types of potential may be easily added: see section~\ref{sec:newpot}.

It is possible to specify the units in which these quantities are
given by means of the control file parameters \Lit{mass-unit},
\Lit{length-unit}, \Lit{time-unit} and \Lit{charge-unit} (which are
themselves specified in SI units). All potential parameters, site
masses and charges, but not co-ordinates, are taken to be in those
units. Their default values are amu, {\AA}, 0.1ps and $q_{e}$, which means
that the unit of energy is kJ\,mol$^{-1}$.  So to read in {\AA}, amu and
kcal mol$^{-1}$, specify \Lit{time-unit=4.8888213e-14}, for  {\AA}, amu
and eV use \Lit{time-unit=1.0181e-14}, and for Lennard-Jones
potentials specified in  {\AA}, amu and $\epsilon$ in K (ie  $E/k_B$) use
\Lit{time-unit=0.548343e-12}, which includes the extra factor of 4.

Once the system specification has been read in, all quantities are
converted to `internal' units: amu, {\AA}, ps, and $\insqrt (
\textnormal{amu {\AA}}^{3} \textnormal{ps}^{-2}/(4 \pi \epsilon_{0}) )$.
The prototype molecule for each species is then shifted so that its
zero of coordinates lies on its centre of mass, and rotated into the
principal frame (polyatomics only).

\subsection{The Initial Configuration}

\moldy\  provides two methods of setting up an initial configuration.
By default the \emph{skew start} method of section~\ref{sec:skewstart}
is used to place the molecular centres of mass in a regular
arrangement which ensures molecular separation.  If there is more than
one species present, molecules of each are chosen randomly for each
site.  Molecular orientations are chosen randomly from a uniform
distribution.  This method has been found to work well for reasonably
small or fairly isotropic molecules and it is anticipated that it will
be the usual method of starting a simulation of the liquid state.   On
the other hand, if the constituent molecules are sufficiently large
and irregular, or if it is intended to simulate the solid state then
the \emph{lattice start} method will be more appropriate.

This method is activated by setting the control parameter
\Lit{lattice-start} to 1, and creates the initial configuration by
periodic replication of some crystalline unit cell.  In that case
\moldy\  expects to find, following the \Lit{end} which terminates the
system specification, an initial configuration specification of the
following form:
\begin{displaymath}
\begin{array}{llllllll}
\multicolumn{8}{l}{a \quad b \quad c \quad \alpha \quad \beta \quad
  \gamma \quad n_{x} \quad n_{y} \quad n_{z}} \\ 
\textit{species-name}_{1} &
X_{1} & Y_{1} & Z_{1} &  q_{10} & q_{11} & q_{12} & q_{13} \\
\vdots &  \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
\textit{species-name}_{i} & X_{i} & Y_{i} & Z_{i} \\
\vdots &  \vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
\textit{species-name}_{n} &
X_{n} & Y_{n} & Z_{n} &  q_{n0} & q_{n1} & q_{n2} & q_{n3}  \\
\Lit{end}. \\
\end{array}
\end{displaymath}
Here $a, b, c$ and $\alpha, \beta, \gamma$ are the crystal unit cell
parameters, and $n_{x}, n_{y}, n_{z}$ are the number of unit cells in
each direction which comprise the MD cell.  The next $n$ lines
describe the $n$ molecules of the basis which will be replicated to
form the full configuration.  Molecules may appear in any order, but
of course the total number of each, multiplied by the number of unit
cells $n_{x} n_{y} n_{z}$, must agree with that given in the system
specification file.

Each molecule is identified by its name, as given in the system
specification file.  $X, Y$ and $Z$ are \emph{fractional}
co-ordinates, between 0 and 1 giving the location of the molecular
centres of mass in the crystal unit cell. The orientation is given by
the four quaternions $q_{0}, q_{1}, q_{2}, q_{3}$, which specify a
rotation about the centre-of-mass \emph{relative to the orientation of
  the prototype molecule in the system specification file}.  (Notice
the slight inconsistency with the positions, which are of the centres
of mass, \emph{not} the zeroes of co-ordinates in the system
specification file. This may be fixed in future releases.)
Quaternions need only be included for polyatomic species, that is
molecules $1$ and $n$ above, and omitted for the monatomic species
$i$.

After the molecular positions and orientations have been set up, their
velocities (and angular velocities if appropriate) are initialized.
Their values are sampled at random from the
Maxwell-Boltzmann distribution for the temperature $T$, as given by
the control parameter \Lit{temperature}.  This is done for both
starting methods.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Restarting from a Previous Run}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:restarting}

At the end of a simulation run, it is often desirable to store the
configuration of the system in a file.  This \emph{restart file} may be
used at a later date to continue the simulation from that point rather
than from scratch.  To instruct \moldy\  to write a restart file, simply
set the control parameter \Lit{save-file} to a suitable filename; to
start from a restart file, set \Lit{restart-file} to be the name of
that file.

Each restart file is a binary file which contains enough information
to reconstruct the exact state of the system and of the program.  It
includes a copy of all the control parameters in force, the current
timestep number, a complete system specification, all the simulation
dynamic variables and the intermediate data used in the calculation of
averages and radial distribution functions.  Thus a run continued from
a restart file will proceed just as if there had been no interruption
and will generate identical results (provided the control parameters
are not changed).

When continuing a simulation, it is only necessary to explicitly
specify control parameters which are to be changed.  Their previous
values are read from the restart file and are used as defaults when
reading the control file. Consequently control files for restarting
tend to be rather short. \Emph{Caution}: always include a new
(possibly null) value for \Lit{save-file}. Otherwise when the new run
terminates, the new restart file may overwrite the old
one.\footnote{Whether the old file is lost depends on the operating
  system. Under systems such as VMS which have version numbers a new
  version is created and the old one remains. Under Unix, the old file
  is renamed by the addition of a ``\%'' character and thus is saved.
  On other systems it will be lost.}

Neither is it necessary to repeat the system specification since that
too is stored in the restart file.  However there are occasions
when it is desirable to do just that, for example if the value of one
of the potential parameters is to be modified.  In that case, set the
switch \Lit{new-sys-spec} to 1 (true) and provide a system
specification as per a new simulation.  This is checked for
consistency with the existing one and if correct replaces it.  The
following checks are applied, which only verify that it is sensible to
assign the old dynamic variables to the new system. \emph{1}. The
number of species must be the same. \emph{2}. Each species must have
the same number of rotational degrees of freedom as its predecessor.
It is not possible to replace a polyatomic by a monatomic or
linear molecule, for example.  \emph{3}. The number of molecules of
each species must not change.  This means that the order in the
specification file must be identical too.  It is however possible to
change the number of sites on a molecule, subject to \emph{2}.

\subsection{Periodic Backup}
\label{sec:backup}
Closely related to restarting is the backup mechanism.  This is
provided to guard against the complete loss of a simulation due to
computer failure. Periodically during a run, \moldy\ writes its state
to a \emph{backup file} -- which is in fact just a restart file.  In
the event of a crash, the simulation can be restarted from the point
the last backup was written rather than from the beginning. The
related control parameters are \Lit{backup-file} which specifies the
file name and \Lit{backup-interval} which gives the frequency of
backups.  It should not normally be necessary to change the name, but
the optimum interval will depend on the size of the simulated system
and the speed of the computer. By default it is 500.  At the
successful end of a run the backup file is deleted so that only if
there is an abnormal termination does one remain.\footnote{A backup
  file is also written if the run is terminated for exceeding its cpu
  limit.}

The restart from a backup is entirely automatic. If a backup file
exists when a run is started, it is read in and the run continues from
it.  In contrast to a normal restart all of the control parameters are
taken from the backup file and the control file (and a restart file if
one is specified) is ignored.\footnote{This is not quite true. \moldy\ 
  does read the control file and any restart file but only to
  determine the name of the backup file. Thus even if the backup has a
  non-standard name it can still be found.} In consequence, if a run
is aborted or stops abnormally for some reason, the backup file must
be removed manually otherwise next time a run starts, the unwanted
simulation will continue instead.

If a run terminates abnormally there may also be a \emph{lock file}
called \Fname{MDBACKUP.lck} which ought to be removed.  \moldy\
attempts to prevent two runs from overwriting each other's backup
files by creating a lock file whose name is formed from the backup
name by appending \Fname{.lck}.  A second run which attempts to use the
same backup file will test for the presence of the lock file and abort
the run if it finds it.

A restart or backup file is created by first writing the data to a
temporary file which is then renamed to the final name.  This ensures
that there is no possibility of a file being left incomplete or
corrupt if the computer crashes part-way through the write.  If the
file already exists either it is replaced (on systems which only keep
one version of a file) or a new version is created (on systems such as
VMS which retain multiple versions).  In the unlikely event of it
being necessary to change where the temporary file is
kept,\footnote{This may be necessary if the restart file is located on
  a different device or disk partition from the current directory. To
  rename the temporary file successfully, it must reside in the same
  partition or device as the restart file.} it may be specified with
the control parameter \Lit{temp-file}.

\subsection{Portable Restart Files}
\label{sec:xdr}
\moldy\ is able\footnote{From version 2.1 onwards} to read and write
restart and dump files in a portable binary format which is
transportable between computers of different architectures.  So a
restart file written on, for example, a Sun may be used to initiate a
new run on a Cray, and the dump files generated on the Cray may be
analyzed on the Sun.  This feature will also be of considerable use in
modern heterogeneous networks where diverse machines frequently share
a common file space.

The format is based on Sun Microsystems XDR protocol\cite{sunxdr}.
The XDR routines are available on almost every modern Unix machine,
and are simple enough to implement on any other
system.\footnote{Because the XDR calls are not part of ANSI standard
  C, however, the XDR code is conditionally compiled into \moldy\ only
  if the \Lit{USE\_XDR} preprocessor symbol is defined during
  compilation.} If the control parameter \Lit{xdr} is set to 1 then
all files will be written using this format. \moldy\ automatically
determines whether a restart file was written using XDR (by examining
the file header) and reads it in the appropriate fashion irrespective
of the value of \Lit{xdr}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Setting the Temperature}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\moldy\ implements three different methods to control the temperature
of the simulated system. These are the velocity rescaling technique
described in section~\ref{sec:rescaling}, the Nos{\'e}-Hoover thermostat
and constrained equations of motion (section~\ref{sec:const-temp}).
Scaling is selected by the parameters \Lit{scale-interval} \etc\ %
Every \Lit{scale-interval} timesteps until \Lit{scale-end}, the
velocities are adjusted so that the kinetic energy corresponds exactly
to the desired temperature (the value of control parameter
\Lit{temperature}).  The Nos{\'e}-Hoover and constrained thermostat
are selected by setting \Lit{const-temp} equal to \Lit{1} or
\Lit{2} respectively.

The control parameter \Lit{scale-options} selects refinements to
the basic scaling or thermostat algorithms. This is an integer
parameter interpreted as a set of bit flags with the following meanings.
\begin{description}
\item[bit 0]    perform scaling or thermostatting for each molecular species individually.
\item[bit 1]    scale/thermostat the rotational and translational components of
the kinetic energy separately.
\item[bit 2]    use the rolling averages of kinetic energy to
calculate the scale factor rather than the instantaneous values.
\item[bit 3]    discard all existing velocities and accelerations and
re-initialize from the Maxwell-Boltzmann distribution.
\end{description}
The bits may be set in any combination so, for example
\Lit{scale-options=6} sets bits 1 and 2 ($ 6 = 2^1 + 2^2$) and scales
separately for rotation/translation using the rolling averages.  If
bit 3 is set the others are ignored.  Only bits 0 and 1 have any
meaning in the case of a thermostat, and signify that each species, or
the translational and rotational degrees of freedom are isolated from
each other and coupled to their own, individual heat baths.

The options for scaling separately rotation and translation, and per
species may be useful for achieving equilibration in ``difficult''
systems where mode-coupling is ineffective.  In those situations it is
otherwise possible for all the energy to be transferred into the
rotational modes of a particular species, halting any progress to
equilibrium for other degrees of freedom.   These options ensure that
all degrees of freedom have some thermal energy.

The option controlled by bit 3, to discard all existing information
and start from a random set of velocities may be of use when starting
from far-from-equilibrium situations.  In such cases the forces are
frequently so large that the velocities and accelerations exceed the
limits of the integration algorithm and timestep, which results in
\moldy\ stopping with a \emph{quaternion normalization} or
\emph{quaternion constraint} error.  Judicious use of this option
every few timesteps (using \Lit{scale-interval}) ought to allow the
system to relax to a state sufficiently close to equilibrium for
normal scaling to take over.

Bit 2 is intended to deal with the problem of setting the temperature
accurately using scaling.  The \emph{ensemble average} kinetic energy
which characterizes the temperature of the system and the
instantaneous value fluctuates about this value.  However in the
traditional implementation of scaling, velocities are multiplied by a
factor of $\sqrt{\emph{desired KE} / {\emph{instantaneous KE}}}$.
Thus the scaling factor is ``wrong'' by the ratio of the instantaneous
to average KE's which means that the temperature can not be set more
accurately than the relative size of the fluctuations in the KE\@.
The option selected by bit 2 goes some way towards the ideal scaling
factor by using the rolling average KE instead of the instantaneous
value.  The fluctuations in this short-term average should be much
lower than in the instantaneous value, allowing more accurate
temperature control.  However it will almost always be easier to use a
true thermostat to achieve this goal.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Output}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:output}
At the beginning of each run \moldy\ writes a \emph{banner page}
containing a summary of the system being simulated and details of the
important control parameters. The bulk of the output file is the
\emph{periodic output} which contains the instantaneous values of
various thermodynamic variables, their rolling averages and associated
standard deviations. The \emph{rolling average} is just the mean over
the preceding $n$ timesteps where $n$ is set by the control parameter
\Lit{roll-interval}.  An annotated example is given in
Figure~\ref{fig:output}.  The frequency of periodic output may be
altered by setting the control parameter \Lit{print-interval} to
the interval required.  (This may be necessary to constrain the size
of the output file which can grow to be very large indeed with the
default interval of only 10.)

\begin{figure}
\tiny
%
\begin{tabular}{rrrrrrrr
@{\hspace{1em}}r@{\hspace{1em}}rr@{\hspace{1em}}r@{\hspace{1em}}r}
\multicolumn{6}{r}{\hfill Nov 17 15:13:06 1989 \hfill Water\_test
\hfill Page 4} & & & & & & &\\
Trans KE & Rot KE & Pot Energy & Tot Energy & TTemp & RTemp & Temp &
h(1,*) & h(2,*) & h(3,*) & Stress & Stress & Stress \\
\multicolumn{13}{l}{======== Timestep 10      Current values
======================================================== } \\
243.88 & 453.88  & -187.35  & 533.5  & 305.5  & 568.6  & 424.4  &
12.53  & 0.00  & 0.00  & 589  & 46.4  & 120 \\
22.053  & 0  & 1.0401 & & 221.0  & 0.0 & & 0.00  & 12.53  & 0.00  & 46.4
& 373  & 90.1 \\
 &  &  &  &  & & &  0.00  & 0.00  & 12.53 & 120  & 90.1  & -207 \\
\multicolumn{13}{l}{-------- Rolling averages over last 10 timesteps
--------------------------------------------------------------------------
------------------------------------------------
} \\
240.27 & 319.31 & -82.472 & 533.39 & 301.0 & 400.0 & 342.9 & 12.53 &
0.00 & 0.00 & 1.2e+03 & 296 & 127 \\
22.077 & 0 & 34.205  & & 221.3 & 0.0 & & 0.00 & 12.53 & 0.00 & 296 &
589 & 133 \\
& & & & & & & 0.00 & 0.00 & 12.53 & 127 & 133 & -132 \\
\multicolumn{13}{l}{-------- Standard deviations
---------------------------------------------------------------------------------------------------------------------------------------------------
} \\
1.8214 & 71.893 & 56.441 &.19942 & 2.3 & 90.1 & 43.4 & 0.00 & 0.00 &
0.00 & 1.32e+03 & 750 & 51 \\
0.013 & 0 & 17.173 & & 0.1 & 0.0 & & 0.00 & 0.00 & 0.00 & 750 & 119 & 55.2 \\
 & & &  &  &  &  & 0.00  & 0.00 & 0.00 & 51 & 55.2 & 49 \\
\end{tabular}
\caption[Sample \moldy\  output.]{Sample \moldy\  output from a simulation 
of a two component mixture.  The first component is a polyatomic
molecule and the second is atomic.  There are three \emph{frames}, for
the instantaneous values, the rolling averages and their associated
standard deviations.  Within a frame, each row has the following
meaning: for translational and rotational kinetic energies and
temperatures it is the per-species value; for the potential energy it
is the direct and reciprocal space components, and the MD cell matrix,
\Lit{h} and the stress are laid out as $3\times 3$ matrices.}
\label{fig:output}
\end{figure}

As well as the short term rolling averages, long term averages are
calculated and printed out at regular but usually infrequent
intervals.  Accumulation starts on the timestep given by the control
parameter \Lit{begin-average} and every \Lit{average-interval}
timesteps thereafter, the means and standard deviations are calculated
and printed.  This output is interspersed with the periodic output and
is formatted with one variable to a line in the form \emph{mean +/-
  standard deviation}. Where a variable has more than one component (such as
multiple species for the translational temperature or Cartesian
components for the mean square forces) the components are printed
across the page.\footnote{Remember that the standard deviation is a
  measure of the \emph{fluctuations} about the mean, \Emph{not} the
  \emph{uncertainty} in the mean. For that the standard error in the
  mean is required, which is more difficult to evaluate.
  Theoretically it is the \emph{s.d.} divided by $\sqrt N$ where $N$
  is the number of independent observations.  But successive timesteps
  are highly correlated and do not count as independent.  See
  ref~\cite{allen:87} section 6.4, page 191 onwards for a full
  discussion.}  In addition to those variables printed as part of the
periodic output, the pressure, the virial, mean square forces, mean
square torques and total dipole moments are calculated.

\subsection{Output units}
All of the various forms of output use the same units, though for
brevity they are not explicitly mentioned on the periodic output.
Lengths are measured in {\AA}, energies are all expressed in
kJ\,mol$^{-1}$, temperatures in Kelvin, pressure and stress in MPa,
mean square forces and torques in N$^2$ mol$^{-1}$ and Nm$^2$
mol$^{-1}$, charge in electron charges and dipole moments in Debye.
Because energy is an extensive quantity the printed values refer to
the \emph{whole system}.  (There is no practical way of expressing
energies per mole of any particular constituent in a program capable
of simulating arbitrary mixtures.)

If these units do not suit, they can be changed in the configuration
file \Fname{defs.h}, where the conversion from internal to output units
is parameterized.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Radial Distribution Functions}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Radial distribution functions are calculated by binning site pair
distances periodically throughout the simulation (see
section~\ref{sec:rdf}).  As this process is expensive in computer time
the binning subroutine is invoked only every few timesteps, as set by
the control parameter \Lit{rdf-interval} (20 by default).  Since
the pair distances only change a little on each timestep, very little
statistical information is lost.  Collection of binning data may also
be turned off during an equilibration period: specify when binning is
to start by means of the parameter \Lit{begin-rdf}.  The parameters
\Lit{rdf-limit} and \Lit{nbins} control the details of binning,
giving respectively the largest distance counted and the number of
bins that interval is divided into. The calculation of the interatomic
distances is done separately from that used in the evaluation of the
forces, using the same link cell scheme.  This ensures that all site
pairs separated by less than \Lit{rdf-limit} are included.  This
parameter may be varied independently of the interaction
cutoff, thereby allowing RDFs to be evaluated out to large distances
without incurring the time penalty of increasing the cutoff.%
\footnote{In previous versions of \moldy\ the calculation of the
  interatomic distances was done on the basis of the ``minimum image''
  convention.  Consequently the calculated value of
  $g_{\alpha\beta}(r)$ tailed off for $r_c > L/2$.  This restriction
  is now lifted}

Every \Lit{rdf-out} timesteps (by default 5000) the RDFs are
calculated from the binned distances and printed out, and the counters
are reset to zero to begin accumulation again.  Distances are binned
and RDFs $g_{\alpha \beta}(r)$ calculated separately for each distinct
type of atom-atom (or site-site) pair.  An explanation of the output
format is given in Figure~\ref{fig:rdf-output}.  Note that each number
should be considered as the value at the \emph{centre} of its bin, so
that entry $i$ in each list is the value of
$g_{\alpha\beta}((i+1/2)b)$ where $b$ is the bin width.

\begin{figure}
\begin{tiny}
\begin{verbatim}
        Radial Distribution Functions   Bin width=0.1
        O-O RDF
 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000
 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000481 0.035710 0.183334 0.442186 0.613992 1.024402
 1.046396 0.964906 0.830174 0.660035 0.693341 0.615902 0.593192 0.510595 0.530697 0.532030 0.535959 0.524457 0.523221 0.466219
 0.496028 0.438487 0.456500 0.410547 0.443861 0.457956 0.446822 0.452202 0.419768 0.439333 0.465509 0.486887 0.461970 0.475745
 0.478883 0.480854 0.509090 0.533728 0.552747 0.552555 0.575402 0.547278 0.544836 0.493597 0.488168 0.520727 0.508073 0.479948
 0.501159 0.484000 0.485378 0.489160 0.464448 0.466791 0.476508 0.446576 0.470948 0.474468 0.449340 0.462169 0.501220 0.519107
 0.513338 0.510192 0.499766 0.525963 0.504663 0.517673 0.498359 0.512156 0.507061 0.466390 0.464342 0.445886 0.417555 0.407778
 0.387220 0.374041
        O-H RDF
 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000 26.976688 0.000000 0.000000 0.000000 0.000000
 0.000000 0.016214 0.061257 0.304082 0.647342 0.847404 0.757188 0.601222 0.478273 0.462682 0.449614 0.450424 0.518998 0.572242
 0.689704 0.914269 1.184674 1.441772 1.570390 1.609068 1.600392 1.430457 1.322722 1.183606 1.103701 1.061788 0.980018 0.960570
 0.924390 0.908883 0.877591 0.857668 0.890761 0.852463 0.815447 0.824963 0.841255 0.890416 0.929030 0.960589 0.984145 1.020650
 1.028199 1.047496 1.064600 1.099812 1.095715 1.073793 1.078131 1.049212 1.052160 1.052001 1.020737 1.010782 0.979748 0.983158
 0.988946 0.967620 0.955655 0.944384 0.952145 0.948509 0.946692 0.960097 0.959299 0.964074 0.969219 0.972704 0.998504 1.027791
 1.041576 1.037637 1.039961 1.016804 1.004726 1.026805 1.030903 1.006268 0.972421 0.948140 0.908959 0.877089 0.849855 0.817964
 0.776986 0.721485

\end{verbatim}
%%\hrulefill
\end{tiny}
\caption[Example output of radial distribution functions.]{Example
output of radial distribution functions. After the header line
consisting of underscores there is an indication of the bin width $b$
(that is the distance between points at which the RDF is tabulated).
Then for each site type pair $\alpha\beta$ there is a line listing
which pair (\eg\ \Lit{O-O RDF}) followed by \Lit{nbins} values of
$g_{\alpha\beta}((i+1/2)b)$.  }
\label{fig:rdf-output}
\end{figure}

There are a couple of tricks which may be played with the system
specification if the atomic pair RDFs do not give exactly the
functions required.  Firstly, it is possible to calculate RDFs about a
particular site, distinguishing it from otherwise identical atoms by
assigning it a new and unique site id in the system specification
file.  (This is the MD equivalent of the isotopic substitution method
used in neutron diffraction). Secondly, if the \emph{molecular} pair
correlation is required, this is identical to the RDF of an atom
located at the molecular centre-of-mass.  A ``ghost'' site without
charge, mass or potentials may be added if necessary.
\pagebreak[3]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dumping}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:dumping}
The dump facility is provided in order to allow the calculation of
dynamic properties, such as time correlation functions and additional
static averages not normally calculated by \moldy.  During a run, dump
files are produced which contain a record of the simulation dynamic
variables (positions, quaternions \etc) at varying degrees of
detail.  Any property of interest, dynamic or static, may then be
evaluated using the data in the dump.

A dump consists of a sequence of files since the amount of data
generated in a run can be very large indeed and it is usually more
convenient to manipulate a series of smaller files rather than one
large and unwieldy one. \moldy\  takes considerable pains to ensure that
a contiguous sequence of dump files is maintained and also ensures
that dumps from different runs are not accidentally intermixed.  There
is no requirement that a dump file be produced by a single run of
\moldy\, which extends an existing file or starts a new one as appropriate.
A simulation may stop and be restarted many times without
disturbing the dump file sequence.  The  sequence
should (in most cases) even survive a system crash and a restart from
a backup file (see section~\ref{sec:backup}).

Each dump file in a sequence is a binary file consisting of a
\emph{dump header}, which contains information about the contents of
the file followed by a number of \emph{dump records} which contain the
actual data.

Several control parameters govern dumping. It starts at the timestep
specified by \Lit{begin-dump}, and a dump record is written every
\Lit{dump-interval} timesteps thereafter.  After \Lit{ndumps}
dump records have been written to a file, it is closed and another is
begun. Filenames are generated from a prototype (given by the
parameter \Lit{dump-file}) by appending a number, so that if the
prototype is \Fname{MDDUMP} then successive files will be named
\Fname{MDDUMP0}, \Fname{MDDUMP1}, \Fname{MDDUMP2} \etc\ If it is
not convenient for the sequence number to appear at the end of the
file, include the characters ``\%d'' at an appropriate
point.\footnote{This is actually the code \Lit{sprintf()}, the C
  library function, uses to signify converting an integer to a decimal
  character string. This function is used to create the actual file
  name from the prototype and the integer dump sequence number. (See
  any C library manual for details.)}  For example under VMS,
specifying \Lit{dump-file=mddump\%d.dat} will name the files
\Fname{mddump0.dat}, \Fname{mddump1.dat} \etc

Each dump record is a sequence of single-precision floating point
binary numbers.  These are written either in native (\ie\ the
machine's own) format or XDR format (see section~\ref{sec:xdr})
depending on the value of the control parameter \Lit{xdr}.  The
record's exact contents are determined by the control parameter
\Lit{dump-level}, which is a bit flag, \ie\ a value of $2^{n}$
means that bit $n$ is set.  Four bits are used and any combination may
be specified but the cumulative values 1, 3, 7 and 15 are most
useful.  A value of 0 disables dumping. The data dumped for each bit
are as follows:
\begin{description}
\item[bit 0]    centre of mass co-ordinates, quaternions, unit cell matrix 
and potential energy.         
\item[bit 1]    centre of mass velocities, quaternion and unit cell
matrix derivatives.
\item[bit 2]    centre of mass accelerations, quaternion and unit cell
matrix second derivatives.
\item[bit 3]    forces, torques and stress tensor.
\end{description}
Items selected are written in the order laid out above.  Within each
set of variables, values are ordered primarily by species in the order
they appeared in the system specification.  Within a species ordering
is by molecule (or atom) and at the finest level by $x$, $y$ or $z$
component ($q_{0}, \ldots q_{3}$ for quaternions). Therefore if $n$ is
the total number of molecules and $n_{r}$ is the number with
rotational freedom the size of each record is
\begin{displaymath}
\begin{array}{cll}
   & 3n + 4n_{r} + 9 + 1 & \textnormal{(if bit 0 is set)} \\
 + & 3n + 4n_{r} + 9 & \textnormal{(if bit 1 is set)} \\
 + & 3n + 4n_{r} + 9 & \textnormal{(if bit 2 is set)} \\
 + & 3n + 3n_{r} + 9 & \textnormal{(if bit 3 is set)} \\
\end{array}
\end{displaymath}
single precision floating point numbers.

The header is a copy of a \Lit{struct dump\_t} (see
source file \Fname{structs.h} for the format). It contains the simulation
title and version number, the timestep at the beginning of the file,
the control parameters \Lit{dump-interval} and \Lit{dump-level}, the
maximum and actual number of dump records in the file, a unique marker
(actually a timestamp), common to all the files in a dump run, and the
timestamp\footnote{A timestamp is simply the number of seconds elapsed
  since midnight on January 1, 1970.} of any restart file used to
start the run.

It is not possible to dump directly to magnetic tape. \moldy\ must
rewind to the beginning of a file to keep the header up to date with
the number of dumps in the file, as well as extend existing files.
Neither operation is allowed on a tape drive.  Large disk stores are
now very cheap so this should not be a problem in practice.  If disk
store \emph{is} limited then the simulation may be divided into
multiple \moldy\ runs interspersed with copying of dump files to
tape.

Notice that \moldy\  must sometimes read an existing but complete dump
file to propagate the unique marker to all of the files in a sequence.
Therefore when continuing a simulation and a dump run, at least
the immediately preceding dump file must still be accessible.  This
should be borne in mind when copying dumps to tape!

\moldy\  is careful to ensure that existing files are not
overwritten - especially necessary since dump records are added to
the end of an existing dump file.  Whenever \moldy\  prepares to start a
new dump file it checks to see if one of that name is already present.
If so, a new name is chosen by ``mutating'' the old one, and a warning
message to that effect is written to the output file. On the other
hand, if the \emph{first} file of a new dump run (including one
initiated because of some error in continuing an old one) already
exists, the \emph{prototype} file name is mutated as above and the
whole dump run is written to files based on the mutated name.

When a run is restarted checks are made to ensure that the values of
the dump control parameters have not been altered.  If they
have, it is not possible to continue an existing dump sequence and a
new one will be started.  (If existing dump files are present the new
sequence will have mutated file names.)  This also happens if an
existing file does not appear to be a \moldy\  dump.  Existing dump
files are also tested to ensure that there is no corruption (due, for
example to a system crash) and that they contain the correct number of
records.  If the dump sequence can not be continued in these
circumstances, \moldy\  terminates with a fatal error rather than waste
computer time.

%To ensure that the header always records the correct number of dump
%records in a file, it is updated \emph{after} the actual record has
%been written.  It is possible that following s crash there may be one
%more record than recorded.  \moldy\  ignores it and recalculates and
%dumps the data.

A utility program included in the distribution, \emph{dumpext},
identifies dump files by printing out the headers and
can be used to extract atomic or molecular trajectories. This
should be useful as a prototype for writing programs to analyse
dump data.

It is frequently convenient to perform analysis of dump data, and
perhaps graphical output on a different computer to that which
generated the data.  In the past it has not usually been possible to
sensibly transfer binary data between computers of different
architectures.  However \moldy\ is able to write dump files in a
portable format using XDR (see section~\ref{sec:xdr}) which may be
read by \emph{dumpext} on any machine.  The control parameter
\Lit{xdr} enables XDR mode for dumps as well as restart files.
As yet, XDR is not available on every machine.  Therefore a program
called \emph{dumpconv} is provided which converts dump files to a
portable text file format (which may be easily moved between machines)
and back again. It is described in appendix~\ref{sec:dumpconv}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Constant Stress or Pressure Simulation}%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The control parameter \Lit{const-pressure} switches from a
constant-volume simulation to one of several con\-stant-stress or
constant-pressure ensembles (see section~\ref{sec:const-stress})
according to its value.  Available values are
\begin{enumerate}
\item The constant-stress method of Parrinello and
  Rahman\cite{parrinello:81}.
\item A constant-pressure method which is the uniform-dilation limit
  of the Parrinello and Rahman dynamics.  This is convenient if
  switching between the two, but like P-R, the dynamics is not
  modularly invariant and does not preserve the virial.
\item The improved constant-stress method of
  Cleveland\cite{cleveland:88} and Wentzcovitch\cite{wentzcovitch:91}.
\item The Andersen constant-pressure method\cite{andersen:80}, which is the
  uniform-dilation limit of Wentzcovitch dynamics.
\end{enumerate}
The value of the MD cell mass parameter, $W$, is given by the control
parameter \Lit{w} and the external pressure by \Lit{pressure}.  Note
that because of the different ficticious kinetic energy term in the
Lagrangians, typical values of $W$ for the Wentzcovitch and Andersen
ensembles are smaller by a factor of the order of $L^4$, where $L$ is
the MD cell edge, than those useful in the Parrinello-Rahman and
compatible uniform-dilation cases.

At present it is not possible to specify an anisotropic external
stress, though this capability may be added in future versions of the
program.

\label{sec:cp-constraints}
The $\bm{h}$ matrix may be constrained so as to disable motion of any
or all of its components using the parameter \Lit{strain-mask}. 
\Lit{Strain-mask} is a bitmap: each ``bit'' of the integer
freezes one of the components of $\bm{h}$;
bit $i$ freezes $ \bm{h}_{kl}$ with 
$ i = 3 (k\!-\!1)\! +\! l\! -\!1$.
The bitmask is the sum of $2^i$ over the $i$'s to be set, so the
\Lit{strain-mask} values

\begin{displaymath}
\left (
\begin{array}{rrr}
1 & 2 & 4 \\ 8 & 16 & 32 \\ 64 & 128 & 256
\end{array}
\right )
\textnormal{constrain the corresponding components of }
h, 
\left (
\begin{array}{rrr}
h_{11} & h_{12} & h_{13} \\ h_{21} & h_{22} & h_{23} \\ h_{31} & h_{32} & h_{33}
\end{array}
\right ).
\end{displaymath}
\noindent
Thus the default constraint of $\bm{h}_{?1} = \bm{a} = (a_x,0,0),
\bm{h}_{?2} = \bm{b} = (b_x,b_y,0)$ is given by \Lit{strain-mask=200}
\linebreak[2]
(8+64+128).  Another useful value is 238 which freezes all the
off-diagonal components.  This is needed for a liquid simulation since
there are no shear restoring forces acting on those components.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cutoffs and Adjustable Parameters}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

There are four parameters related to the Ewald sum method of force
evaluation (see section~\ref{sec:ewald}), $\alpha$, $r_c$, $k_c$, and
\Lit{subcell}.  In addition the two options \Lit{strict-cutoff}
and \Lit{surface-dipole} select how rigorously the real-space
cutoff is applied and whether to include the De Leuuw surface dipole
term.

By default $\alpha$, $r_c$ and $k_c$ are chosen automatically, using
equations~\ref{eqn:ewald-alpha}-~\ref{eqn:ewald-cut} to give a default accuracy of $\epsilon
= \exp(-p) = 10^{-5}$ (\ie\ $p = 11.5$) in the Coulombic potential energy
evaluation.  An empirically determined value of $t_R/t_F = 5.5$ is
used.  If a different accuracy is desired the cutoffs may be adjusted
using equations~\ref{eqn:ewald-alpha}-~\ref{eqn:ewald-cut}.  The $\alpha$ parameter is
specified by \Lit{alpha} in units of {\AA}$^{-1}$ and the direct and
reciprocal space cutoff distances $r_{c}$ and $k_{c}$ by
\Lit{cutoff} and \Lit{k-cutoff} in units of {\AA}\ and {\AA}$^{-1}$
respectively.  The value of $\alpha$ should only be changed after
careful timing tests if the system size is large.  The power-law given
in equation~\ref{eqn:ewald-alpha} gives a theoretical scaling of
execution time with number of ions of $T \propto N^{1.5}$. In practise $T
\propto N^{1.57}$ has been achieved over a range of $N$ from 72 to
7800, which is very close to optimal.

\Emph{Important note:} The automatically determined value of $r_c$
is chosen to converge the Coulombic part of the potential only.  Due
to the very general nature of the potentials it is not possible to
choose $r_c$ automatically so as to guarantee convergence of the
non-electrostatic part. Although in many cases the automatic value
will be adequate \Emph{it is the user's responsibility to ensure
that it is large enough}. If there are no charges in the system
specification file then $r_c$ is not set and an error message is
issued.

As an example of manual determination of the parameters, for a
simulation of 512 MCY water molecules the values $\alpha =
0.3${\AA}$^{-1}$, $r_{c} = 9${\AA}\ and $k_{c} = 1.9${\AA}$^{-1}$ give
potential energies correct to approximately 1 part in $10^{5}$.  For a
simulation including ions - 1.1 Molal magnesium chloride solution -
the same accuracy is attained with $\alpha = 0.45${\AA}$^{-1}$, $r_{c} =
9${\AA}\ and $k_{c} = 3${\AA}$^{-1}$.

The Ewald sum may be disabled by setting specific values for
\Lit{control.alpha}.  The exact behaviour is
\begin{itemize}
\item If \Lit{control.alpha} $ > 10^{-7}$, $\alpha$ is set to that
  value and used in the Ewald sum.
\item If \Lit{control.alpha} $ = 0$ then the value of $\alpha$ is
  chosen automatically as above.
\item If \Lit{control.alpha} $ < 0$ the reciprocal space part of the
  Ewald sum is not invoked, and the computation of coulombic forces in
  the real-space sum is turned off.  This happens automatically if all 
  charges in the system specification file are zero.
\item If $0 < $ \Lit{control.alpha} $ < 10^{-7}$ then the reciprocal
  space part of the Ewald sum is \emph{not} called but coulombic
  interactions \emph{are} included in the real-space part and truncated
  at $r_c$.
\end{itemize}

The other relevant parameter is the switch \Lit{surface-dipole} which
includes the dipole surface energy term of De Leeuw, Perram and
Smith\cite{deleeuw:80}.  See the note in section~\ref{sec:ewald} for an
explanation of why this term should \emph{not} be used for an ionic
(as opposed to dipolar) system.

The two adjustable parameters which control the link cell force
calculation (see section~\ref{sec:link-cell}) are \Lit{subcell} and
\Lit{strict-cutoff}. The former specifies the length (in {\AA}) of the side of
a link cell and determines the number of cells the MD cell is divided
into. In fact the MD cell is divided into a whole number of subcells
whose side in each of the three directions is nearest to the value of
\Lit{subcell}.  (The default of zero though, is special and sets
subcell to one fifth of the cutoff radius.)  In general the smaller
the link cell, the more accurately the cutoff radius is implemented,
but too many of them reduces the efficiency of the program.

In the default cutoff mode \Lit{strict-cutoff=false} the list of
neighbour cells is constructed to include all cells whose
centre-centre distance is less than the cutoff.  This means that some
molecule pairs separated by more than the cutoff will be included and
some by less will be omitted.  Setting \Lit{strict-cutoff} to true
generates a larger cell neighbour list which is guaranteed to include
all appropriate molecule pairs.  Furthermore, molecules separated by
more than the cutoff are excluded from the force calculation by
setting their separation to a large number, 100 times the cutoff, at
which distance it is assumed the potential is very close to zero.
This is therefore the mode of choice for liquid simulations where any
artificial anisotropy is undesirable.  See section~\ref{sec:link-cell}
for a full explanation.

It is worth noting that it is unnecessary to recompile the program or
change anything else when the cutoffs are modified. Unlike most MD
codes, \moldy\ employs dynamic array allocation and automatically sets
up arrays of the correct size (and no more!) for any given $k_{c}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Framework Simulations}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

There has recently been much interest in simulations of systems of
molecules interacting with some rigid framework such as zeolites,
clays and other surfaces.  \moldy\  has the capability to include such a
framework in a simulation by defining it as a special kind of molecule.

The system specification should contain an entry, similar to that for
a normal molecule, which describes the atomic sites belonging to one
MD cell's worth of the framework.  Its periodic images should fill
space to construct the required infinite framework.  This is notified
to the program by modifying the first line of the specification of
that molecule to read
\begin{displaymath}
\begin{array}{lllllll}
\multicolumn{7}{l}{\textit{species-name}_{i} %
                  \quad \Lit{1} \quad \Lit{Framework}}  \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
\end{array}
\end{displaymath}
(compare with section~\ref{sec:sys-spec}).  The effect of the special
keyword \Lit{framework} is
\begin{enumerate}
\item to remove the rotational freedom of the molecule.  This
preserves the infinite structure over MD cell repeats by disallowing
relative motion of its parts. (Linear motion does not destroy the
structure and \emph{is} allowed.)
\item to modify the effect of the periodic boundary conditions.
Normally a molecule is assumed to be ``small'' and periodic relocations
are applied to \emph{all} of its atoms depending on its centre-of-mass
co-ordinates relative to some interacting molecule.  In contrast, the
atoms of a framework are independently relocated.  This ensures that
each molecule ``sees'' all framework atoms from any unit cell which
are within the cutoff distance.
\end{enumerate}

In the present version of the program, only one framework molecule is
allowed, though more may be permitted in future versions. Consequently
the configuration given as a lattice start must fill the entire MD
box. (A skew start is not sensible under these circumstances since the
orientation of the framework must be explicitly specified to construct
a good space-filling structure.)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Messages and Errors}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Apart from the periodic output, there are occasional once-off
messages which \moldy\ writes to the usual output file.  Such messages
begin with the characters \Lit{*I*}, \Lit{*W*}, \Lit{*E*} or
\Lit{*F*} denoting the classes \emph{information}, \emph{warning},
\emph{error} or \emph{fatal} respectively.  Their meanings are
\begin{Litdescription}
\item[*I*] information. These are often produced by subroutines
to give useful information on their particular calculations.  For
example when temperature scaling is turned off a message to that
effect is recorded in the output file.  Various routines which
calculate internal quantities such as the Ewald sum self energies and
distant potential corrections also record their values using an
information message.
\item[*W*] warning.  When the system specification is suspicious
but not clearly wrong, or some untoward condition is detected such as
two atoms approaching too closely, a warning message is issued.
\item[*E*] error. Error messages are issued when a mistake is
detected reading any of the input files. To make correction easier,
processing continues until the end of that file, so that all of the
errors are found.  The simulation is then stopped with a fatal error.
\item[*F*] fatal. The simulation is terminated immediately. Faulty 
input files generate fatal errors after they have been completely
processed.  There are many other conditions which also generate fatal
errors, for example if the simulation algorithms violate some
criterion such as quaternion normalization or constraints (see
section~\ref{sec:quaternions}), if the program runs out of memory or
if a restart file can not be correctly opened or is of the wrong
format.
\end{Litdescription}
Most of the messages are self-explanatory.  However there are two
fatal errors which occasionally arise and are somewhat cryptic:

\Lit{*F* Quaternion n (x,x,x,x) - normalization error in beeman}

and

\Lit{*F* Quaternion n - constraint error (x)}

\noindent
Technically these refer to violations of the conditions that the
quaternions representing the angular co-ordinates be normalized to 1
and that equation~\ref{eqn:qconst} be satisfied.  Either may occur if
the angular velocity of some molecule becomes too high for accurate
integration of the equations of motion. This may have a number of
causes.  First the timestep may simply be too large.  Second the
system may be in a state where atoms are so close as to generate large
torques which accelerate the molecule to a high angular velocity. This
commonly arises if the starting configuration is very far from
equilibrium, particularly in the case of molecules with small moments
of inertia, such as methane.  In most cases the simulation may be
restarted using strong rescaling or a Gaussian thermostat to limit
velocities during the approach to equilibrium.  Occasionally a smaller
timestep may help during equilibration.  The third cause of
normalization or constraint errors is an error in the potentials or
the units which allows for a state with high or infinite negative
binding energy.

Note that these messages only occur for polyatomic molecules.  If the
system is monatomic the errors mentioned above may still be present
but will not be detected and the simulation may fail in some less
predictable manner, for example particles may approach too closely
and/or acquire high velocities and fly off to infinity.  The message

\Lit{*W* Sites n and m closer than 0.5A.}

\noindent
gives some warning of this condition.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Compiling and Modifying Moldy} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The \moldy\  distribution consists of numerous files of ``C'' source code
for \moldy\  and the utility programs, command or job files to compile
the source, \LaTeX\ input for the manual and example control and system
specification files.  For ease of transport these are packed into one
large archive file, whose format and method of unpacking depends
on the operating system of the target machine.  At present it is
available for:

\begin{description}
\item[unix] The archive is usually a tar archive called
  \Fname{moldy.tar} possibly compressed with the ``compress'' or
  ``gzip'' programs and named \Fname{moldy.tar.Z} or
  \Fname{moldy.tar.gz}. These files may be uncompressed using the
  ``gunzip''  or ``uncompress'' programs, \emph{viz.}
  \Lit{gunzip moldy.tar.gz} or \Lit{uncompress moldy.tar.Z} whereupon
  the archive is unpacked by the command \Lit{tar xvf moldy.tar}.
  
  An alternative form of archive for those unusual systems without a
  ``tar'' program is a shell archive --- a Bourne shell script called
  \Fname{moldy.shar}. This is unpacked by \Lit{/bin/sh moldy.shar}.  

\item[VMS]  The archive is a DCL command file called \Fname{moldy.com},
and is unpacked by the command \Lit{@moldy}.

\item[MS Windows 3/Windows 95/NT] The shareware program ``winzip'' may
  be used to unpack the compressed tar archive \Fname{moldy.tar.gz}.
  There is also a precompiled binary version for Windows 95/98/NT
  which is available as \Fname{moldy.zip}.  Winzip may also be used to
  uncompress this distribution.  Two versions of each executable are
  provided in directories ``cygwin'' and ``mingw''.  One of these sets
  should be installed in a suitable directory which should be added to
  the user path.  The Cygwin-compiled binaries rely on the shared
  library \Fname{cygwin1.dll} and incorporate XDR support (see
  section~\ref{sec:compile}).  If Cygwin is not already installed the
  DLL (included) must also be installed in a suitable directory on the
  system.  The Mingw32-compiled executables do not require a dll and
  should run on any Windows machine, but do not support the creation
  or reading of XDR format restart files or dumps.

\item[MS-DOS] The files must be unpacked from the tar archive on
another host and transferred to the PC by disk or ftp.

\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Compilation}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:compile}
The source code of \moldy\  consists of 23 files of C programs (which have
suffix ``\Fname{.c}'') and 8 header files (suffix ``\Fname{.h}'').
To build \moldy, all of the \Fname{.c} files must be compiled and linked
together to form an executable.  The method of doing this depends on
the operating system of the target computer.
\begin{description}
\item[unix]  
This version of \moldy\ uses the GNU autoconf system to configure for
compilation.  In most cases it should be possible to do

\Lit{\% ./configure}\\
\Lit{\% make}

The ``configure'' script will determine the capabilities of the
compiling system and create the files \Fname{config.h} and
\Fname{Makefile} tailored to the system.  It has built-in information
about the compiler names and optimization options (it should recognise
most major workstation types)\footnote{Since these date rapidly as
  vendors improve their compilers and introduce new architectures
  feedback from users on appropriate options is welcome and will be
  included in future releases.}.  It should be able to determine the
characteristics of a machine unknown to it and to create \Fname{Makefile} and
\Fname{config.h} to build a working version.  In that case you may need to
"hand-tune" compiler or optimization options, which may be specified
by setting the OPT and OPT2 environment variables.

You can set or change the default compiler or options by calling
configure with the environment variables CC, CPPFLAGS, CFLAGS, OPT,
OPT2, LDFLAGS or LIBS defined.  Any values you supply for these will
override the built-in ones, \eg\


\begin{tabbing}
\Lit{\% env CC=gcc OPT=-O1 OPT2=-O4 ./configure} \=    \emph{(c-shell)}\\
\Lit{\$ CC=gcc OPT=-O1 ./configure}      \>   \emph{(bourne-shell/korn-shell/bash)}
\end{tabbing}

OPT2 is used to compile only the most performance-critical modules and
will usually select a very high level of optimization.  It should be
safe to select an optimization which means ``treat all function
arguments as restricted pointers which are not aliased to any other
object''.  OPT is used for less performance-critical modules and may be
set to a lower level of optimization than OPT2.

There is just one other option to \Lit{configure},
\Lit{--enable-parallel} which attempts to configure for building the
parallel version.  The syntax is

\Lit{--enable-parallel=}\textit{parsys}

where \textit{parsys} is one of \Lit{mpi} \Lit{bsp} \Lit{shmem} or
\Lit{tcgmsg}.  If \textit{parsys} is omitted the default is \Lit{mpi}.
See the section~\ref{sec:spmdpar} on compiling for parallelism for a
description of these libraries.

This is all that is required for a parallel build if the include files
for the parallel system are in a directory searched by the C compiler
and the libraries can be found using \Lit{-l}\textit{parsys}.  The
Cray T3D/T3E and SGI Power Challenge and Origin 2000 systems fall into
this category.  Otherwise it may be necessary to specify these by
setting the environment variables CPPFLAGS and LIBS, \eg\:

\Lit{env CPPFLAGS=-I/usr/local/mpi/include 
    LIBS="-L/usr/local/mpi/bin -lmpi" ./configure}

Some parallel systems such as the MPICH implementation of MPI
from Argonne National Laboratories supply a compiler script
called, in this case ``mpicc''.  If you are using MPICH it is
sufficient to do:

\Lit{env CC=mpicc ./configure --enable-parallel}

Configure assumes that ``mpicc'' invokes the system C compiler
and adds the appropriate optimization flags.  Other cases where
an alternate compiler specification is used are for the IBM SP2
where the command is ``mpcc'' and for the Oxford bsp library
which provides ``bspcc''.

\item[VMS]  Simply type \Lit{@compile} to execute the command file
\Fname{compile.com}. This will build \moldy\  and the utilities.

\item[DOS/MS Windows 3] There is a makefile for Borland Turbo C called
  \Fname{Makefile.mak} in the standard distribution.  This must be
  edited to select the appropriate compiler options before executing
  \emph{make}.\footnote{Be sure to delete or rename the unix make file
    \Fname{Makefile} since Turbo C \emph{make} will attempt to
    execute this in preference to \Fname{Makefile.mak}}
  Alternatively the programs may be built within the interactive
  environment.  Consult the \Fname{makefile} to find out which source
  files to link to build \moldy\ and the utilities.  \moldy\ has also
  been built using Watcom C.
  
\item[Windows 95/98/NT] The most straightforward way to build \moldy\ is
  to install one of the ports of the GNU gcc compiler such as Cygwin
  or Mingw32.  Cygwin provides a full unix-like environment while
  Mingw32 has the advantage that the executable files do not depend on
  a DLL file and are therefore more portable.  On the other hand only
  Cygwin has support for the XDR calls to produce portable restart and 
  dump files (see section~\ref{sec:xdr}).  As of version B.20, Cygwin
  incorporates Mingw32 which can be selected using a command-line option.
  
  Cygwin may be downloaded from the homepage at URL
  \url{http://sourceware.cygnus.com/cygwin/} and links to Mingw32 as
  well as general information on GNU compilers under Windows may be
  found at
  \url{http://www.xraylith.wisc.edu/~khan/software/gnu-win32/x86-win32-ports.html}.
  It is also well worth installing the additional ``sunrpc'' package
  which contains the XDR headers and libraries needed to produce
  portable restart and dump files (see section~\ref{sec:xdr}).  A
  binary installation for Cygwin is available from URL
  \url{ftp://ftp.franken.de/pub/win32/develop/gnuwin32/cygwin/porters/Vinschen_Corinna/B20/sunrpc-4.0.cygwin1.bin.tar.gz}.
  There is also a source version which might work under Mingw32, but
  only the binary version under Cygwin has been tested.

  The compilation procedure is exactly the same as under a unix
  environment -- \Lit{configure} followed by \Lit{make}. \textbf{N.B.}
  The executables so created must be run under either a Cygwin
  ``bash'' shell or a MS-DOS window.  

  \moldy\ has also been successfully compiled using Watcom C and the
  development environment.  Consult the Makefile to see which objects
  to link to build \moldy\ and the utilities. It is also possible that
  the Borland C \Fname{Makefile.mak} will work under Borland C for
  Windows 95 or NT\footnote{The author's experience of Windows 3 and
    Windows 95 platforms is somewhat limited.  I would very much
    welcome any reports from users on how to build \moldy\ in these
    environments for inclusion in future versions of this manual.}.


\end{description}

\subsection{Parallel Version (Message Passing)}
\label{sec:spmdpar}
The parallel version of \moldy\ relies on an interface with a suitable
message-passing library.  This is the recommended version and
supersedes the ``shared-memory'' parallel implementation described in
section~\ref{sec:shmpar}.  The current release contains interfaces to
the MPI library\cite{mpi:94}, the TCGMSG library and the Oxford BSP
library.  MPI is the most recommended interface since it is the new
standard for message-passing libraries, and should become ubiquitous.
If none of these are installed on your machine, some public-domain
implementations are available for workstation clusters,
multiprocessors and many distributed-memory parallel machines.

\begin{description}
\raggedright
\item[MPI] The MPICH implementation can be downloaded by anonymous ftp
  from the URL \url{ftp://info.mcs.anl.gov/pub/mpi/mpich.tar.gz} and
  with other information at \url{http://www.mcs.anl.gov/mpi/index.html}.
  
  The CHIMP implementation can be downloaded by anonymous ftp from
  \url{ftp://ftp.epcc.ed.ac.uk/pub/chimp/release/chimp.tar.Z}
\item[TCGMSG] This may be obtained by anonymous ftp from
  \url{ftp://ftp.tcg.anl.gov/pub/tcgmsg/tcgmsg.4.04.tar.Z}
\item[BSP] The Oxford BSP Library is available through Oxford
  Parallel's WWW server
  \url{http://www.BSP-Worldwide.org/implmnts/oxtool.html} or by
  anonymous ftp
  \url{ftp://ftp.comlab.ox.ac.uk/pub/Packages/BSP/v1.3_bsplib_toolset.tar.gz}.
\item[SHMEM] The CRI native communications library for T3D and T3E
  systems.
\end{description}

\noindent
Alternatively a port to another parallel interface should be quite
straightforward, see section~\ref{sec:parport}.

Once a suitable message-passing library is installed the procedure for
building \moldy\ is as described in section~\ref{sec:compile}. 

On a non unix-like system the configuration must be done ``by hand''
using whatever build mechanism is available.  The C preprocessor macro
\Lit{SPMD} must be defined as well as one of \Lit{MPI}, \Lit{TCGMSG},
\Lit{BSP} or \Lit{SHMEM}. This is usually done in the makefile by
setting the Make macro \Lit{PARLIBC=-DSPMD -DMPI}, for example.  This
macro should also include a \Lit{-I} directive specifying the
directory for the library's header files if these are not in the
default path searched by the compiler.  The similar make macro
\Lit{PARLIBL} should contain the linker directives necessary to link
to the library itself. Examples are provided at the top of the
supplied \Fname{Makefile}.

This parallel implementation makes use of the \emph{replicated data}
approach\cite{smith:91} whereby every processor has a complete copy of
all the arrays containing dynamical variables and every site on every
molecule.  The computation of the real-space potential and forces is
distributed over processors on the basis of link cells.  For the
reciprocal-space part of the Ewald sum, the \emph{k}-vectors are
distributed among processors.  This is an extremely efficient way of
implementing parallelism since the forces \etc\ must be summed over
processors only once per timestep, thus minimizing interprocessor
communication costs.  It is therefore possible to get considerable
speedup for a small number of workstations coupled by a fast network
such as an Ethernet.

The biggest disadvantage of the replicated data strategy is that
every processor must maintain a copy of all of the data, and therefore
that the memory requirement per processor increases with the size of
the system.   In many cases this is not a severe problem, as MD
memory requirements are not large compared with memory sizes of modern
computers.  However the poor scaling will eventually limit the number
of processors which may be used.  On a shared-memory multiprocessor,
the alternative parallel version in section~\ref{sec:shmpar} may
provide a solution, if it can be ported to that machine.

The memory limitation will be most acute when the goal is to simulate
an extremely large system on a massively parallel distributed-memory
computer where it is desirable to scale the system size with the
number of processors.  In such architectures the available memory per
processor is usually a constant independent of the number of
processors. But the memory needed \emph{per processor} increases with
system size.  Mostly the scaling is linear, but the reciprocal-space
sum uses temporary arrays whose size scales with the product of the
number of sites and \emph{k}-vectors, and hence to the
{\small$\frac{3}{2}^{\textnormal{th}}$} power of the system size.

An alternative version of \Fname{ewald.c} which implements the
reciprocal-space term of the Ewald sum by distributing over
\emph{sites} rather than \emph{k}-vectors is included in the
distribution as \Fname{ewald-RIL.c}.  It is based on the RIL algorithm
of Smith~\cite{smith:92} and \emph{distributes} the temporary arrays
containing the $\cos(\bm{k} \cdot \bm{r}_i)$ and $\sin(\bm{k} \cdot
\bm{r}_i)$ over the nodes. In other words, each node only stores the
terms involving the $\bm{r}_i$'s to be considered on that node.  Since
these arrays are by far the largest users of memory there is a
substantial decrease in overall memory requirement.  Moreover the size
per node now scales \emph{linearly} with the number of
\emph{k}-vectors and therefore (assuming $\alpha$ is optimized), to
the two-thirds power of the number of sites.  These arrays will not
therefore dominate the memory requirement in the limit of large
numbers of processors and system size.  The disadvantage of the RIL
scheme is that the partial sums of $\cos(\bm{k} \cdot \bm{r}_i)$ and
$\sin(\bm{k} \cdot \bm{r}_i)$ must be summed over nodes separately for
each \emph{k}-vector. Though the amount of data transferred each time
is small, the communication and inter-processor synchronization is far
more frequent than for the RKL scheme and the parallelism becomes very
fine-grained.  The upshot is that only machines with very low
communications latency can run this version effectively.  Practical
tests show that the communications overhead completely negate any
parallel gain on systems of networked workstations and most
multiprocessors.  However a significant speedup is obtained on a Cray
T3D, which is exactly the case where this version is needed.

\subsection{Shared-Memory Parallel Version}
\label{sec:shmpar}
An alternative parallel version is available for shared-memory
multiprocessors with ``parallelizing'' compilers.  This relies on the
compiler handling the multi-threading, synchronization and allocation
of local memory stacks for inner function calls. It requires
compiler-specific directives to be inserted in the code and is
therefore less portable than the distributed-memory version of the
previous section. (Note that that version works on this class of
machines too under the message-passing interface.) Nevertheless, it
works and has been run on Stardent, Convex and Cray computers.  It
consists of replacements for files \Fname{force.c} and
\Fname{ewald.c} called \Fname{force\_parallel.c} and
\Fname{ewald\_parallel.c}. Then the program should be compiled with
the preprocessor macro \Lit{PARALLEL} defined (not \Lit{SPMD}).

The distributed-memory parallel version (section~\ref{sec:spmdpar}) is
generally recommended over this one.  However because the parallel
sections reference a single global copy of most of the arrays, the
shared-memory version uses much less memory.  This version may
therefore be of use if memory limits the size of the system on 
a multiprocessor machine.

% The approach taken is to retain the vectorized inner loops and
% parallelize the the outer loops, over cells for \Fname{force.c} and {\bf
% k} vectors for \Fname{ewald.c}.  The two parallel loops are structured by
% the method developed by the Kingston group\cite{wojcik:85}. That is, a
% loop of the form
% \begin{verbatim}
%         for(i = 0; i < N; i++)
%            <body of loop>
% \end{verbatim}
% is transformed into
% \begin{verbatim}
%         for(processor = 0; processor < NPROCESSORS; processor++)
%            for(i = processor; i < N; i += NPROCESSORS)
%               <body of loop>
% \end{verbatim}
% so that the outer loop is over the number of available processors,
% and the inner loop has an increment of that number.  Note that this
% transformation reorders the loop iterations.
% 
% If the outer loop is to execute concurrently, each sub-process or
% thread must have local copies of any temporary variables, notably
% \Lit{i}.  Therefore the contents of each loop are isolated into a
% separate function. Each thread executes a separate incarnation
% of the function.  A shared-memory model is assumed, in which each
% thread accesses a single copy of the parameters and global
% variables, but has a unique copy of all of its local variables.
% 
% The ``master'' thread maintains separate copies of result variables
% and arrays, (\ie\ the forces, potential energy and stress virial) so
% that each incarnation of the function can write to its own copy
% without interference from other threads.  After all of the threads
% recombine, the separate copies are summed to give the final result of
% the calculation.  This method avoids the need for explicit
% synchronization between threads, but will add to the serial overhead
% on highly parallel machines.
% 
% The method of actually parallelizing the outer loop will vary from
% machine to machine. The stellar compiler is able to generate parallel
% code, and the directive \Lit{/*\$dir}~\Lit{no\_recurrence*/}
% instructs it to parallelize the following loop.  The Ardent, Convex
% and Cray compilers use \Lit{\#pragma} directives, namely
% \Lit{\#pragma ipdep}, \Lit{\#pragma \_CNX force\_parallel} and
% \Lit{\#pragma \_CRI taskloop} respectively.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Portability}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
A major goal in writing \moldy\ was that it be as portable as possible
between different computers and operating systems.  It is written in
the Kernighan and Ritchie\cite{kernighan:78} compatible subset of ANSI
C and assumes the library calls and header files defined for a hosted
implementation of the standard.  It should therefore be possible to
compile and run \moldy\ on any computer which has a good C compiler.

The ``configure'' script immensely eases portability on unix-like
systems by detecting the capabilities of the compiler and the
installed header files and library functions. The details are given
below for completeness or in case of a configure failure or for a
system where ``configure'' does not work.

Though hosted ANSI standard C environments are now commonly available
it may still be necessary to compile \moldy\ using a pre-ANSI
compiler.  Replacement ANSI library functions are supplied in
\Fname{ansi.c} for the VMS and unix operating systems.  For ease of
portability \emph{all other system-dependent functions are in the
  module \Fname{auxil.c}} and \emph{all preprocessor conditionals are
  in the header file \Fname{defs.h}}. If the target machine has ANSI
conformant C libraries, all that must be done is to define the
preprocessor symbol \Lit{ANSI\_LIBS}, either in \Fname{defs.h} or by
using a compiler option \eg\ \Lit{-DANSI\_LIBS}.

\subsection{System Dependencies}
In this section, details of system-dependent functions are described
for the major operating systems.
  \begin{description}
\item[Replacement ANSI header files]
 \begin{sloppypar}
   The ANSI header files \Fname{string.h}, \Fname{stdlib.h},
   \Fname{stddef.h} and \Fname{time.h} are missing from Berkeley
   unix, or incomplete.  Replacements are included which may be
   dispensed with on an ANSI conformant system - If the symbol
   \Lit{ANSI\_LIBS} is defined they simply include the system
   version.
 \end{sloppypar}

\item[Replacements for ANSI functions] \hspace*{1em}
\noindent 
  \begin{itemize}
  \item The ANSI function to delete a file, \Lit{remove()}, the
    signalling function \Lit{raise()} and the string functions
    \Lit{strstr()} and \Lit{strerror()} are missing from
    pre-ANSI libraries.  Replacements are supplied in \Fname{ansi.c}.
  \item Replacements are provided in \Fname{ansi.c} for functions
    \Lit{memset()}, \Lit{memcpy()} and \Lit{strchr()} which
    are missing from Berkeley UNIX.
  \item The function \Lit{vprintf()} is often absent from older
    libraries. Replacements are provided which \emph{a)} call the
    internal function \Lit{\_doprnt()} or \emph{b)} implements a
    portable \Lit{vprintf()}.  Use the preprocessor macros
    \Lit{HAVE\_VPRINTF} or \Lit{HAVE\_DOPRNT} to select which.
  \end{itemize}
\item[Timing routines] The supplied \Lit{clock()} function on some
  32-bit UNIX systems resets to zero after 36 minutes.  Replacements,
  called \Lit{cpu()} for system V and Berkeley UNIXes and POSIX are
  supplied in \Fname{auxil.c}.  The function \Lit{rt\_clock()} is also
  defined and returns the elapsed time in seconds.  For a non-unix
  system \Lit{cpu()} and \Lit{rt\_clock()} simply call the ANSI
  functions \Lit{clock()} and \Lit{time()}.
\item[File manipulation routines]
 \Fname{Auxil.c} contains the functions \Lit{replace()} and
  \Lit{purge()}.  \Lit{replace()} renames a file, making a
  backup of any existing file of that name. \Lit{purge()} removes
  the previous or backup version of a file.  These functions make use
  of the file name syntax of the host operating system and are
  therefore system-dependent.  Unix file systems do not have explicit
  version numbers but \moldy\ keeps a single previous version by
  appending a ``\%'' character to the name.  The pure ANSI versions
  just interface to \Lit{rename()} and do nothing respectively.
\end{description}

\subsection{Optimization and Vectorization}
\moldy\ has been designed to run fast on a wide range of computers,
and in particular on those with vector, multiprocessor and parallel
architectures. This is a difficult problem, since the constructs which
run fast on different architectures may be quite distinct and
occasionally in conflict.  Nonetheless, it has been found that
following a few basic rules gives extremely good performance on a wide
range of computer architectures.  In a rough order of importance these
are:
\begin{enumerate}
\item Minimize the number of memory references to floating point data
  in critical loops.  Memory access is the major bottleneck on almost
  every modern computer, scalar, vector or parallel.
\item Minimize the number of memory references to floating point data
  in critical loops.  This cannot be emphasized enough.
\item Ensure that memory is accessed contiguously within critical
  loops. That is, arrays should be accessed with a stride of 1 and
  with the last index varying most rapidly.\footnote{C uses the
    opposite convention to FORTRAN in storage layout of
    multidimensional arrays}  This is absolutely critical on machines
  where memory is accessed via a cache, \ie\ all workstations and many
  parallel systems, and frequently very important on machines with
  interleaved memory (\ie\ most vector machines).
\item If the value of any array element is used more than once in a
  loop, write the loop using temporary scalars to store results and
  assign them to the arrays at the end of the loop. This allows the
  compiler to optimize memory references.\footnote{Technically, the C
    standard treats arrays passed as formal function parameters as
    pointers which are permitted to refer to overlapping areas of
    memory.  The compiler must therefore assume that if an array
    element is written in a loop then elements of any other arrays may
    also be changed.  It must therefore reload from memory even though
    it already has a copy of the value in a register. But if all loads
    are completed before any stores then the compiler is at liberty to
    re-use the values and save memory accesses.}
\item Minimize the floating-point operation count in critical loops.
\item Minimize integer arithmetic in critical code.  CRAY vector
  machines in particular have no integer multiplication hardware,
  and integer operations are slow as a result.
\end{enumerate}

The performance of \moldy\  has been carefully studied using profiling
tools, and all critical regions of code are written as efficiently
vectorizable loops.  

The most critical sections of code (\ie\ those which use the majority
of the computer time) are all to do with the site forces calculation.
Thus it is the inner loops in \Fname{force.c}, \Fname{ewald.c} and
\Fname{kernel.c} to which most attention should be paid.  The
pair-distance loop of \Lit{rdf\_calc()} in \Fname{rdf.c} should
vectorize for efficient radial distribution function evaluation.
Others which are of minor importance are in \Fname{beeman.c},
\Fname{matrix.c}, \Fname{quaterns.c} and \Fname{algorith.c}.
\Fname{Auxil.c} contains alternative versions of various sum, dot
product, scatter and gather routines \etc\ which are interfaces to
machine-specific libraries \eg\ Cray scilib, Convex veclib (which
usually have FORTRAN calling conventions). There are also default
versions coded in C which do vectorize, for machines lacking
specialist libraries as well as for scalar computers.

\subsection{Optimization for Vector Architectures}
The program should, of course, be compiled with options specifying
vectorization.   Since highly
optimizing and vectorizing compilers frequently contain bugs, and
since some options generate ``unsafe'' optimizations, it may be
necessary to restrict the highest optimization level to those modules
which contain critical code.

To allow the compiler to generate vector code, it must be instructed
to ignore apparent vector recurrences. The reason is that the run-time
dimensioned arrays necessary to implement such a flexible program must
use pointers as their base.  (See any C textbook, \eg\ Kernighan and
Ritchie\cite[Chapter 5]{kernighan:88} for an explanation of C pointers and
arrays.)  Unfortunately this means that the compiler can not determine
that each iteration of the loop is independent of the preceding
iterations.  In the jargon of vectorizing compilers, there may be a
\emph{vector dependency} or \emph{recurrence}. The compiler can be
notified that these are not genuine recurrences either globally by use
of a command-line directive or on a per-loop basis using
machine-specific compiler directives inserted into the source.

Most compilers also have an option which directs it to ignore
recurrences throughout the whole program, \eg\ \Lit{-va} on the
Convex, \Lit{-va} and \Lit{-h ivdep} on the Cray compilers.  It
should normally be safe to use these options. Each manufacturer's
compiler has its own peculiar set of inline directives.  For example
the CRAY compilers use a \Lit{\#pragma}~\Lit{ivdep} statement
whereas the convex and Stellar compilers use a ``significant comment''
\Lit{/*\$dir no\_recurrence*/}.\footnote{A mechanism is
  provided to insert appropriate directives using the C preprocessor.
  The text \Lit{VECTORIZE} has been placed before each loop which
  ought to be vectorized, and the file \Fname{defs.h} contains
  machine-conditional \Lit{\#define}s to replace it with the
  appropriate directive.  Currently directives for the CRAY, Stellar
  and Convex compilers are included, and null text is substituted for
  other machines.  Notice that in each case the substituted text is
  \emph{not} the directive described in the manual, but rather that
  directive \emph{after} it has been passed through the preprocessor.
  To determine what should be substituted on a new vector machine,
  create a small test containing the documented directive and use the
  C preprocessor on that file. The output will show the form that
  should be defined in \Fname{defs.h}.
  
  Unfortunately this method had been made obsolete by the ANSI C standard,
  which makes it impossible to insert pragmas using the
  preprocessor. } 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Modifying Moldy}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Adding a New Potential}
\label{sec:newpot}
By default \moldy\ supports potential functions of the Lennard-Jones,
six-exp and MCY forms.  However it should be very easy to add further
types. The program is written in a highly modular fashion so that
\emph{the only code which need be altered is in file \Fname{kernel.c}}
(and occasionally in \Fname{defs.h}).

The calculation of the potential and forces is performed entirely in
the function \Lit{kernel()}.  This function is called repeatedly with
a vector of (squared) distances between some reference site and its
neighbour sites.  Vectors of potential parameters and charges are
supplied which bear a one to one correspondence with the elements of
the distance vector.  It calculates the corresponding values of
$-\frac{1}{r_{ij}}\frac{dU(r_{ij})}{dr_{ij}}$ which it stores in
\Lit{forceij[]}.  There are several variants of the force-calculation
loop, one for each kind of potential.  The potential type in use is
passed as a parameter to \Lit{kernel()} and is used in a \Lit{switch}
statement to select the appropriate code.

To add a new potential the following modifications must be perfomed:
\begin{itemize}
\item The array of structs called \Lit{potspec[]} must be extended.
  The new array element should contain the name of the new potential
  \emph{in all lowercase}\footnote{Potential names in system
    specification files are converted to lowercase before being
    compared with \Lit{potspec[]}, so it is impossible to match a name
    containing uppercase letters.}  and the number of potential
  parameters for each site pair.\footnote{By default the arrays are
    sized for up to seven parameters. If this is not sufficient, the
    limit, set by the value of the constant \Lit{NPOTP} defined in
    \Fname{defs.h} may be increased.}  The name of a potential type
  given in system specification files will be matched against this
  name after being converted to lowercase.
\item In parallel with \Lit{potspec[]}, the array \Lit{pot\_dim[]}
  must also be updated with a new entry which describes the dimensions
  of each parameter for the new potential. This array is used by the
  input routines to convert from the input units into program units.
  Each entry consists of triplets, one triplet per parameter,
  containing the powers of mass, length and time corresponding to the
  dimensionality of that parameter.
\item Define a new preprocessor symbol (after the line
  \Lit{\#define~MCYPOT~2}) to an integer which will be used as the
  index of the new type in the arrays and to select the code in the
  case statement.  The value must correspond to the index of the new
  entry in \Lit{potspec[]} starting from 0 in accordance with the
  usual C convention.  
  
\item This constant should be used as the label to a new case in the
  \Lit{switch} statement of \Lit{kernel()}, and this is where the code
  to evaluate the potential goes.  The existing cases may be used as a
  model, especially for the evaluation of the electrostatic term
  $\erfc(\alpha r) / r$ which is evaluated by the polynomial expansion
  of Abramowitz and Stegun\cite[section 7.1.26]{abramowitz:70}. There
  are currently \emph{two} versions of each loop, the second omitting
  this term for efficiency when all the electric charges are zero
  (which case is flagged by a negative value of $\alpha$).

\item Finally, the distant potential correction for the new potential
  should be added as a new case to function \Lit{dist\_pot()}. The
  code should evaluate
\[
- \int^{\infty}_{r_c} r^2 U(r) \, \Calcd r
\]
for the potential $U(r)$.
\end{itemize}

\subsection{Porting the Parallel Version}
\label{sec:parport}
It should be relatively straightforward to port the distributed-memory
parallel version to a new message-passing library.
Section~\ref{sec:parstrat} describes the parallel implementation. All
of the interface code is contained in \Fname{parallel.c} and it will
only be necessary to modify this file.  A new port should declare a
new preprocessor macro along the lines of \Lit{MPI} \etc\ which
should be used to conditionally compile its code only.  Any header
files may be included in the appropriate place in \Fname{parallel.c}.
Then the interface functions should be written to call the underlying
message passing library. These should again be conditionally compiled.
It should be obvious where to place them in the file and the existing
versions will provide a model.  Their specifications are:

\begin{Litdescription}
\sloppy
\item[par\_sigintreset(void)] Moldy sets a handler for SIGINT\@.  This
  function is called from the signal handler to restore the default.
\item[par\_begin(int *argc, char ***argv, int *ithread, int
  *nthreads)] Initialize the library and return the number of
  processes and the ID of this process.
\item[par\_finish(void)] Terminate the parallel run normally.
\item[par\_abort(int code)] Terminate the run abnormally.  Return code
  if possible.
\item[par\_broadcast(void *buf, int n, size\_mt size, int ifrom)]
  Broadcast the specified buffer from node \Lit{ifrom} to all nodes.
\item[par\_\{r,d,i\}sum(void *buf, int n)] Perform a global parallel
  sum reduction on the buffer containing n reals,\footnote{\Lit{real}
    is a typedef defined in \Fname{defs.h} which is set either to
    \Lit{float} or \Lit{double} (see section~\ref{sec:types}).  The
    code for \Lit{par\_rsum()} must handle either case, which may be
    tested using the \Lit{sizeof} operator. For example the
    preprocessor macro \Lit{\#define M\_REAL
      (sizeof(real)==sizeof(double)?MPI\_DOUBLE:MPI\_FLOAT)} is used
    to determine which constant to pass to the MPI sum function.}
  doubles or ints. 
\item[par\_imax(int *idat)] Perform a global maximum reduction on
  the single int argument.
\fussy
\end{Litdescription}

The SPMD parallel strategy updates the dynamic variables independently on
all processors (see section~\ref{sec:parstrat}).  To update the
separate copies of the co-ordinates and other dynamic variables
synchronously the results of the floating-point arithmetic must be
identical.  Therefore the result returned by \Lit{par\_rsum} and
\Lit{par\_dsum} must be identical to the last bit on all processors:
see the footnote on page~\pageref{sec:parstrat}.  Another consequence
is that execution on heterogeneous workstation networks is not
supported - the identity of floating-point operations in not
guaranteed even if all use IEEE arithmetic.  \moldy\ periodically
tests for divergence of trajectories and will exit with the message

\Lit{*F* Trajectories on parallel threads are diverging.}

\noindent if this condition is detected.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Program Structure} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The source of \moldy\ consists of 31 different C source files
amounting to 167 functions and 9000 lines of code. A complete and
detailed description would be a compendious volume of questionable
value.  Instead, much of the detailed documentation is contained in
the source code in the form of comments. This chapter concentrates on
describing the organization of the calculation and the data structures
used throughout the code, describes some of the more complicated and
less obvious algorithms and provides call graphs and brief function
descriptions to act as a map of the program structure.

\moldy\ is written in modular fashion in adherence to the principles
of \emph{structured programming} to as great a degree as practical.
This does not mean merely the avoidance of \Lit{goto}s but, instead
the organization of the program into modules and functions which are
independent of each other and of global environmental variables.
Functions are kept to a limited size and as far as practical
serve a single, well defined purpose.\footnote{The term ``function''
  in C corresponds to both functions and subroutines in FORTRAN.} This
ensures that the internal workings of a function are unaffected by
changes elsewhere in the program, and do not have any influence on any
other part of it, except through the defined interface.  In \moldy\,
functions are grouped into different files according to a rough
classification of their purpose.  

The other primary consideration in the design of a large computer
program is the provision and organization of storage for the data.
Structured programming advocates that definitions of data objects be
restricted as closely as possible to the code that uses them, and that
the code be organized in a modular fashion to encourage data locality.
This minimizes the risk of a programming error in one part of the code
modifying a variable used in a completely different part and producing
difficult-to-locate side effects.  With two exceptions,%
\footnote{These are the struct \Lit{control}
  (section~\ref{sec:sysvars}) and the integers \Lit{ithread} and
  \Lit{nthreads} holding the parallelization parameters
  (section~\ref{sec:pario}).} global data is avoided in \moldy\ and
all arrays are passed as function arguments where necessary.  Heavy
use is made of C structures (or ``structs'') to further group related
data so that it may be manipulated \emph{in toto}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data Structures}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
\subsection{Types and Typedefs}
\label{sec:types}

A number of derived types are defined in the header file
\Fname{defs.h} for reasons of economy of expression, portability and
ease of customization.  Most of these derived types are named using a
suffix \Lit{\_mt} to mark them as such.  These are
\begin{Litdescription}
\item[real] This is the ``standard precision'' floating-point type
  used for all the dynamic variables and most other internal
  variables. It is set to \Lit{double} by default. Changing this to
  \Lit{float} will give a single-precision version of \moldy\ with
  a consequent memory saving.  However additional work must be done to
  create a fully single-precision version, since the standard
  double-precision maths library will still be used.  The C standard
  does not require a single-precision maths library, but most systems
  do make the functions available. However there is no
  standardization of the interface so this can not be done portably.
\item[boolean] Used for storing logical values.  Typed to
  \Lit{int}.
\item[gptr] Generic pointer type, set to \Lit{void} in the case of ANSI C.
  Pre-ANSI compilers do not support \Lit{void} so \Lit{char} is
  used instead.
\item[time\_mt] This is used to store integer format times and dates as
  returned by the \Lit{time()} function.  It is declared as
  \Lit{unsigned long} and is used because pre-ANSI compiling
  systems may not define the \Lit{time\_t} type for this purpose.
\item[size\_mt] Used for storage of C object sizes as returned by
  \Lit{sizeof}.  Like \Lit{time\_mt} this would be unnecessary if
  we were guaranteed an ANSI C compilation system.
\item[vec\_mt] Array of 3 \Lit{real}s for holding a vector type.
\item[quat\_mt] Array of four reals for holding a quaternion type.
\item[mat\_mt] $3 \times 3$ array of reals for storing a matrix.
\end{Litdescription}

\subsection{Memory Management}

The allocation of memory for storage of the multitude of data required
in a molecular-dynamics simulation is one of the main design criteria
of the code. The general nature of the systems to be accepted by
\moldy, namely the arbitrary mixtures of molecules with different
numbers and kinds of atoms requires a number of large multidimensional
arrays with system-dependent bounds in more than one dimension.  It is
impractical to declare these statically with dimensions fixed at some
suitably large value because total memory use would then be infeasibly
large.  The availability of standard, portable, dynamic memory
allocation was one of the major reasons the author chose to write
\moldy\ in C.\footnote{At the time \moldy\ was being planned in 1988 C
  was the \emph{only} widely available language offering dynamic
  memory allocation.  Fortran 90, which also offers dynamically
  declared arrays was standardized in 1991 and compilers only became
  common in the mid-nineties.} \moldy\ uses C's capability of array
emulation by pointers and heap-based memory
allocation\cite{kernighan:88} rather than true C arrays which, like
FORTRAN's, are restricted to bounds fixed at compile-time.

Much of the dynamic memory used in \moldy\ is allocated on entry to a
function and deallocated before exit to emulate local,
variably-dimensioned arrays.  The main exceptions are the arrays of
dynamical variables which are allocated once during the startup phase
and not freed until program exit.  All dynamic memory is allocated
using the function \Lit{talloc()} which is a wrapper around the
standard library function \Lit{malloc()}.  Function \Lit{talloc()}
simply calls \Lit{malloc()}, tests the return value and calls an error
exit function if it failed to allocate the memory requested.  Its
interface takes advantage of the C preprocessor macros
\Lit{\_\_LINE\_\_} and \Lit{\_\_FILE\_\_} to print out the location of
a failing call, and a wrapping macro \Lit{aalloc()} is provided in
\Fname{defs.h} for this purpose. This also contains other
\Lit{\textsl{x}alloc()} macros customized for various data types.  The
complementary function \Lit{tfree()} calls the library function
\Lit{free()} but also allows tracing of allocation and freeing for
debugging purposes.  All of \moldy's memory-management functions are
in the source file \Fname{alloc.c}.

Like FORTRAN, C only permits the declaration of arrays of size fixed
at compile time. Unlike FORTRAN, C lacks any method of declaring
arrays with adjustable innermost dimensions as function formal
parameters.  However through the use of pointer --- array mapping and
dynamic memory allocation, variable-sized multidimensional arrays may
be emulated\cite[p107]{kernighan:88},\cite[pp 20--23]{press:92C}.
Multidimensional array emulation is done by the function
\Lit{arralloc()} (see Figure~\ref{fig:arralloc}). This takes the size
of the atomic data-type, the number of dimensions and the lower and
upper bounds for each dimension as arguments and returns a pointer to
the allocated pseudo-array. This is an array of \emph{pointers} (to an
array of pointers to \ldots) to the data area.  The C mapping of array
notation onto pointer syntax allows this construct to be referenced
exactly as if it was a true multidimensional array. For example\\
\parbox{\textwidth}{%
\begin{quote}
  \Litf
double **r;\\
r = arralloc(sizeof(double), 2, 0, m-1, 0, n-1);
\end{quote}}\\
\noindent defines a 2D array, $m \times n$ of \Lit{double} so that
\Lit{r[i][j]} is a reference to the $i, j$ th element in the usual
manner. This pseudo-array may be passed directly to a function, \eg\\
\parbox{\textwidth}{%
\begin{quote}
  \Litf
double doit(r, i, j)\\
double **r;\\
int    i, j;\\
\{\\
\hspace*{1cm} r[i][j] = 0.0;\\
\}
\end{quote}}\\
\noindent
since the underlying pointer arrays contain all the necessary
information to access indivual elements. Function \Lit{arralloc()} is
implemented so as to lay out the individual pointer and data arrays as
part of a single block of memory which is allocated by a single call
to \Lit{talloc()}. It then sets up the values of the pointers to
emulate the requested array. The memory can be freed with a single
call to \Lit{tfree().}

The \Lit{arralloc()} mechanism is unnecessary for 2D arrays where
the innermost dimensions are fixed, such as for an array of position
co-ordinates which has dimensions \Lit{[n][3]}.  In such cases one
of the \Lit{\textsl{x}alloc()} macros is used to allocate an array
with fixed innermost dimensions and whose type is a pointer to a
fixed-size array \Lit{double (*x)[3]} rather than a pointer to a
pointer \Lit{double **x}.

\begin{figure}[tb]
  \begin{center}
    \input{fig_arralloc.ftx}
  \end{center}
  \caption[Storage layout of a 2-dimensional pointer-based
    pseudo-array]{Storage layout of a 2-dimensional pointer-based
    pseudo-array. The base pointer \Lit{r} is of type ``pointer to
    pointer to double'' and declared \Lit{double **r}.  This points
    at a 1-dimensional array with length $m$ of pointers, which in
    turn point to the $m$ rows of data arrays.  This structure
    contains all the information needed to access element
    \Lit{r[i][j]} using pointer indirection rather than an indexing
    computation and therefore without any reference to the values of
    $m$ or $n$.  Higher dimensional arrays are set out in a similar
    fashion with more levels of pointer arrays, $n-1$ for an
    $n$-dimensional array}
    \label{fig:arralloc}
\end{figure}

There is one important instance of a more sophisticated use of arrays
of pointers; the allocation of the atomic-site, site-force,
centre-of-mass force and torque arrays in the main timestep loop
function \Lit{do\_step()}. These syntactically resemble 3D arrays
declared, \eg\ \Lit{site[nspecies][nsites][3]} but because the
number of sites differs between molecular species they do not map onto
``rectangular'' 3D arrays.  However the ``array of pointers''
construct does allow for rows of different lengths and this is easily
set up.  These pseudo-arrays can again be passed straightforwardly as
function arguments and used with the obvious and intuitive indexing
scheme at the cost of a little extra code to allocate and initialize
the pointers.

\subsection{System Variables and Data Structures}
\label{sec:sysvars}

\moldy\ makes consistent use of C language structures or ``structs''
to combine related pieces of data into a single variable. This may
then be passed as a single function argument avoiding long and
cumbersome argument lists and the consequent risk of programming
error.  All of the major struct types used in this way are defined in
the header file \Fname{structs.h} where each type is carefully annotated
with the meaning of its members.

The struct \Lit{control} is shared between almost all modules in the
program using external linkage.\footnote{This is analogous to a COMMON
  block in FORTRAN.} It contains the values of the parameters from the
control file --- the exact mapping is defined by the array (of
structs) \Lit{match[]} declared in source file \Fname{startup.c}.  The
values are read from the control file by function
\Lit{read\_control()} in source file \Fname{input.c} and adjusted by
\Lit{start\_up()} in \Fname{startup.c} where the timestep-related
parameters are updated and the floating-point values are transformed
into program units.  These are the only functions which alter values
in \Lit{control}.

Most of the information needed to describe the system is stored in the
struct \Lit{system} and the array of structs \Lit{species[]}.  Struct
\Lit{system} contains counters to record the total numbers of species
(\Lit{nspecies}), atomic sites (\Lit{nsites}), molecules
(\Lit{nmols}), polyatomic molecules\footnote{strictly speaking
  molecules with rotational degrees of freedom.} (\Lit{nmols\_r}) and
pointers to the arrays of dynamical variables.  Its counterpart
\Lit{species[]} is a dynamically allocated array, length
\Lit{nspecies}, of structs of type \Lit{spec\_mt} which
contains individual data for each molecular or atomic species.  This
includes the mass, moments of inertia, dipole moment, and charge, the
number of sites belonging to this species and the number of molecules.
It also contains pointers to the array of site identification numbers,
and Cartesian site co-ordinates (expressed in the molecular principal
frame) for this species and also to the arrays of dynamical variables.

The dynamical variables are stored in dynamically-allocated arrays of
total length \Lit{nmols} and \Lit{nmols\_r} which may be regarded as
the concatenation of individual arrays containing variables belonging
to each molecular species. The pointers in \Lit{species[i]}
locate the beginning of the array of variables belonging to species
\Lit{i} and those in \Lit{system} to the beginning of the entire
array.  The variables are manipulated by either route as is most
convenient (but never both within a single function).

The potential parameters are stored separately in the array
\Lit{potpar} since they refer to pairs of site types
(\emph{site-id's}).  This is an array of structs of type
\Lit{pot\_mt}, laid out as a 2-dimensional symmetric matrix of
dimension \Lit{system.max\_id} with rows and columns indexed by the
site identifiers as given in the system specification file.  In fact
it is stored in a one-dimensional array of length
(\Lit{system.max\_id})$^2$ and the index calculation is performed
explicitly when it is referenced.  Structure type \Lit{pot\_mt}
contains an array \Lit{p} for the actual parameter values.  This is
a fixed-length array with \Lit{NPOTP} members, where the constant
\Lit{NPOTP} is defined in the header file \Fname{defs.h}.  If a new
potential with more than 7 parameters is to be added to \moldy\ it
will be necessary to increase its value.  

The above primary storage of the potential parameters is convenient
for reading in and storing and rereading restart files.  However it
can not be indexed efficiently to retrieve the potential parameter
values in the critical innermost loops.  The data is therefore copied
into an expanded 3-dimensional array
\Lit{potp[max\_id][NPOTP][nsites]} in the force evaluation function
\Lit{forces()} before being used.  The masses and charges of the
various sites are stored in another array of structs
\Lit{site\_info[]}, simply indexed by the site identifier. As with the
potential parameters this is not convenient for access within the
inner force loop, so the data are expanded in \Lit{do\_step()} to fill
an array \Lit{chg[nsites]} to allow direct indexing by the loop
counter.

The two final data structures of importance are those containing
accumulated data for computing the usual averages and the radial
distribution functions.  Both databases are considered private to
their respective source modules \Fname{values.c} and \Fname{rdf.c}
and are only accessed using the function interfaces provided in those
modules.

The averages database provides a general and extensible scheme for
storing partial sums and computing rolling- and time- averages of
instantaneous values such as temperature, kinetic energy \etc\ It
consists of two parts, a linear array \Lit{av[]} of structs of type
\Lit{av\_mt} (defined in \Fname{values.c}) and an array of classified
types of data which contains pointers to \Lit{av[]}, the numbers of
components, and to format strings and units conversion factors for
output formatting and printing.  This is the compile-time struct array
\Lit{av\_info[]}, again defined in \Fname{values.c}. To compute
averages of a different quantity a new entry should be added to the
array \Lit{av\_info}, and another corresponding enum type to \Lit{enum
  av\_n} in \Fname{defs.h}.  The storage, retrieval and averages
computation functions will then recognize the new type and may be
called from within \Lit{values()} and \Lit{averages()}.

The array \Lit{av} itself is set up using the ``struct hack'' to
allocate space for the rolling average data.  The structure type
\Lit{av\_mt} contains as its final entry an array with one element
\Lit{roll[1]}.  When storage for \Lit{av} is allocated, the
amount requested is calculated \emph{as if} the member array was
declared \Lit{roll[n]} with $n$ equal to the rolling-average
interval.  The array member \Lit{roll[]} may then be used as if it
had $n$ members.  This does mean that the array \Lit{av} can not be
simply indexed using pointer arithmetic or array subscripting since
the compiler's notion of the size of a pointer of type
\Lit{av\_mt~*} is wrong.  It is instead accessed solely via the
pointers contained in array \Lit{av\_info}.  The general functions
\Lit{add\_average()} \etc\ in \Fname{values.c} provide the means to
store and retrieve values and compute averages.  The function
\Lit{av\_ptr()} is provided to make the size and base address of
the averages database available to the restart file reading and
writing functions in \Fname{restart.c}.

Radial distribution functions are calculated between all pairs of site
types (defined by the site identifier given in the system
specification file).  Storage for the accumulating binned pair
distances is provided by a 3D pseudo-array \Lit{rdf[idi][idj][bin]}
with two indices for the site identifiers of the pair and one for the
bin.  This does not have the geometry of a true 3D array but is set up
by function \Lit{init\_rdf()} to economise on memory by making
\Lit{rdf[idi][idj][bin]} an alias for \Lit{rdf[idj][idi][bin]}.
Both the pointers and the actual data area are of course dynamically
allocated.  The latter is in a single block of memory whose address is
stored in \Lit{rdf\_base} so that it may be easily stored in and
retrieved from a restart file.  The function \Lit{rdf\_ptr()} is
provided to make the size and base address of the RDF database
available to the restart file reading and writing functions in
\Fname{restart.c}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Files and Functions}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Source Files}
The source files consist of 8 ``\Fname{.h}'' header files and 23
``\Fname{.c}'' code files which contain functions grouped in a modular
fashion.  A detailed description of the purpose and interface to each
function is given in the source code in the form of comments, which
should be regarded as the primary documentation for the function.  An
annotated list of files follows.

\begin{Fndescription}
\item[structs.h] Definitions of structure types used throughout the
  program.
\item[defs.h] Main \moldy\ header file to be included in all
  ``\Fname{.c}'' files.  It contains machine and operating-system
  configuration macros., physical constants, unit definitions and
  global (non-structure) type definitions.
\item[string.h, time.h, stddef.h, stdlib.h] These files are
  replacements for the ANSI C library header files of the same name,
  included here for portability to pre-ANSI environments.
\item[messages.h] Error messages file containing messages in the form
  of preprocessor macros. This may allow for non-English language
  customization. 
\item[xdr.h] Includes the system headers for the usual External Data
  Representation (XDR) functions and prototypes of additional
  functions for XDR reading and writing of \moldy--specific structure
  types.
\item[accel.c] Contains \Lit{do\_step()}, which implements the
  major part of the main MD timestep procedure plus functions for
  velocity rescaling and thermostatting.
\item[algorith.c] Contains functions to implement algorithms and
  computations related to the dynamical equations of motion. This
  includes the computation of molecular centre-of-mass forces,
  torques, the Newton-Euler equations and the constant--stress and
  --temperature functions.  These functions all have an
  interface which makes no reference to the \Lit{system} or
  \Lit{species[]} structs.
\item[alloc.c] Contains functions for memory management; allocation,
  (\Lit{talloc()}) freeing (\Lit{tfree()}) and setting up of
  pointer-based multi-dimensional arrays (\Lit{arralloc()}).
\item[ansi.c] Replacements for certain functions required in any ANSI
  C standard library but missing from pre-ANSI environments.
\item[auxil.c] Machine- and OS-dependent support functions. Contains
  \emph{(a)} Fast vector arithmetic functions, including interface to
  various vector libraries as well as pure ``C'' versions. \emph{(b)}
  OS-dependent time and file manipulation functions.
\item[beeman.c] Functions implementing the separate stages of the
  modified Beeman algorithm, including basic steps and the updating of
  all the necessary dynamical variables.
\item[convert.c] Functions for converting the potential parameters and
  control file parameters from input units to program units and vice
  versa. 
\item[dump.c] Functions for managing periodic trajectory \etc\ dumps.
\item[ewald.c] Evaluates the reciprocal-space part of the Ewald sum
  for the long-ranged Coulombic forces.
\item[force.c] Implements the calculation of the short-ranged forces
  and the real-space part of the Ewald sum using the Link Cell
  algorithm. This excludes the actual evaluation of the potential
  which is contained in \Lit{kernel()} in \Fname{kernel.c}.
\item[input.c] Functions for reading the control and system
  specification files and allocating the structures to hold the data
  read in from them. 
\item[eigens.c] Matrix diagonalizer from the netlib archive.
\item[kernel.c] Contains \Lit{kernel()} which actually evaluates
  the potential given a vector of pair distances.
\item[main.c] Function \Lit{main()} is the main program which
  controls the set up and contains the main MD timestep loop that 
  calls \Lit{do\_step()} to do most of the work of a timestep.
\item[matrix.c] Functions for manipulating $3 \times 3$ matrices and
  applying to $3 \times n$ arrays of co-ordinates \etc
\item[output.c] Main output functions responsible for regular output
  sent to main output file.  Also contains error-handling function
  \Lit{message()} which may terminate simulation.
\item[parallel.c] Interface between \moldy\ and various parallel
  message-passing libraries.  Also contains functions to copy \moldy's
  data structures from the input/output node to other nodes using the
  parallel interface.
\item[quaterns.c] Functions for manipulating arrays of quaternions.
\item[rdf.c] Contains \Lit{init\_rdf()} which sets up RDF database,
  \Lit{rdf\_accum()} which periodically bins pair distances and
  \Lit{rdf\_out()} which calculates and prints all the radial
  distribution functions.
\item[restart.c] Functions for reading and writing the restart and
  backup files.
\item[startup.c] Primary initialization function \Lit{start\_up()}
  plus subsidiary functions \Lit{allocate\_dynamics()} to create
  dynamic variable arrays and \Lit{initialise\_sysdef} to compute
  molecular and whole-system properties.  Also contains functions to
  create initial configuration for system.
\item[values.c] Function \Lit{init\_averages()} allocates and sets
  up pointers to averages database.  Other functions store and
  retrieve instantaneous values of thermodynamic quantities and
  compute the averages thereof.
\item[xdr.c] Functions to read and write \moldy's own struct types
  using the External Data Representation (XDR) library.
\end{Fndescription}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Flow of Control}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Input and Initialization}
\label{sec:startup}

\begin{figure}[tb]
\noindent
\begin{minipage}[b]{260bp}
\input{fig_startup-a.ftx}
\end{minipage}
\begin{minipage}[b]{2.55in}
\raggedright
\textbf{Functions called by start\_up()}\\
\footnotesize
\setlength{\leftmargini}{1em}
\begin{Litdescription}
\item[default\_control()] Initialize struct \Lit{control} with
  default parameter values.
\item[read\_control()] Read parameters from control file and store in struct
  \Lit{control}.
\item[convert\_control()] Convert physical values in \Lit{control}
  between input and program units.
\item[read\_sysdef()] Read the system specification file. Allocate
  storage for arrays \Lit{species}, \Lit{site\_info} and
  \Lit{potpar} and copy in values from file.
\item[initialise\_sysdef()] Finish set up of \Lit{system} and
  \Lit{species} structs.
\item[allocate\_dynamics()] Allocate memory for the dynamic variable
  arrays and set up pointers in \Lit{system} and \Lit{species}
\item[skew\_start()] Set up skew-cyclic initial state.
\item[lattice\_start()] Read crystal structure and set up
  co-ordinates, quaternions and cell vectors.
\item[init\_cutoffs()] Determine optimum parameters for Ewald sum.
\item[re\_re\_header()] Read the \Lit{restart\_header} and \Lit{control}
  structs from the restart file.                                        
\item[re\_re\_sysdef()] Read the system specification (structs/arrays
  \Lit{system}, \Lit{species}, \Lit{site\_info} and
  \Lit{potpar}) from the restart file.
\item[read\_restart()] Read dynamic variables and the RDF and averages
  databases from the restart file.
\item[check\_sysdef()] Check new system specification is consistent
  with old.
\item[thermalise()] Set up Maxwell-Boltzmann velocity distribution
\item[init\_rdf()] Prepare to bin RDFs.  Allocate memory and pointers
\item[init\_averages()] Allocate space for and initialize the averages
  database.
\item[convert\_averages()] Update averages database if roll\_interval
  changed or if old-style restart file.
\item[conv\_potentials()] Convert potential params between ``input''
  and ``program'' units.
\end{Litdescription}
\end{minipage}
\renewcommand{\thefigure}{\arabic{chapter}.\arabic{figure}(a)}
\caption[Block diagram of initialization function \Lit{start\_up()}]{%
  Block diagram of the initialization function \Lit{start\_up()} and a
  list of the functions called. Continued in Figure~\ref{fig:startup-b}.}
\label{fig:startup-a}
\end{figure}

\addtocounter{figure}{-1}
\begin{figure}[tb]
\centering
\input{fig_startup-b.ftx}
\renewcommand{\thefigure}{\arabic{chapter}.\arabic{figure}(b)}
\caption[Block diagram of initialization function \Lit{start\_up()}]{%
  Block diagram of the initialization function
  \Lit{start\_up()} and a list of the functions called.  Continued
  from Figure~\ref{fig:startup-a}.  The paths beginning at \textbf{A},
  \textbf{B} and \textbf{C} are for a new run, a restart from a save
  file, and a restart from a backup file respectively.}
\label{fig:startup-b}
\end{figure}


The initialization and input file reading stage of \moldy\ is rather
more complicated than is usual in a molecular-dynamics simulation
program because
\begin{itemize}
\item of the use of dynamic data structures.  The size of the arrays
  required can only be determined after the input files have been
  partially read in, but they must be allocated before the read is
  complete. Thus reading of input files and array allocation must be
  interspersed.
\item of the general nature of the systems \moldy\ is able to simulate.
  Many structures that might otherwise be hard-coded must here be read
  from the input files and set up dynamically.
\item \moldy\ has three different modes of start-up; an initial run,
  a restart and a backup restart.  The use of the stored values of the
  control parameters as defaults on a restart run is an added
  complication. 
\item the ability to specify the input units the potential parameters
  are expressed in requires the appropriate conversion to be performed
  at start-up.
\end{itemize}

Initialization is controlled by function \Lit{start\_up()} which is
called directly from \Lit{main()}. It calls subsidiary functions to
read the control and system specification, restart or backup files.
It controls the allocation of dynamic memory for the system
description and potential and dynamic variable arrays, and the RDF and
averages databases. It oversees the computation of quantities derived
from the input parameters and system specification and generally
transforms the input data from a form useful for human preparation to
one useful for machine computation. Figures~\ref{fig:startup-a}
and~\ref{fig:startup-b} show a block diagram of \Lit{start\_up()} and
a brief description of the functions it calls.

Parameters are read from the control file by \Lit{read\_control()}
which assigns their values to the corresponding member of struct
\Lit{control}.  The default values were previously set by
\Lit{default\_control()}.  In the case of a restart the saved
parameters in the restart file are restored to \Lit{control} by
function \Lit{re\_re\_header()}, overwriting all of the current
values.  In this way the saved values become the defaults for a second
call of \Lit{read\_control()} which rereads the control file and
assigns any new values.  The repeated read is
necessary because the \emph{name} of the restart file is supplied by
the control file.  Note that those parameters representing physical
quantities must be converted to and fro between input and program
units for consistency since they are stored in program units in the
restart file.

The three alternative routes within \Lit{start\_up()} for reading the
system specification and initializing the dynamic variables \etc\ are
shown in Figure~\ref{fig:startup-b}.  The case of a new run is
reasonably straightforward.  Memory for the ``system specification''
arrays \Lit{species[]}, \Lit{potpar[]} and \Lit{site\_info[]} is
allocated as the system specification is read in by
\Lit{read\_sysdef()}.  The raw atomic site co-ordinates are then
shifted to the molecular centre-of-mass frame and rotated to the
principal frame of the inertia tensor by \Lit{initialise\_sysdef()},
which also computes a number of other molecular quantities and
completes the set up of the system specification. Next the
dynamic-variable arrays are allocated and initialized and finally the
RDF and averages databases are installed.

If the run is a restart then those control parameters whose value is
interpreted relative to the current timestep (see
section~\ref{sec:control}) must have its value added to theirs.  This
is only done if the parameter was explicitly specified in the new
control file, otherwise its saved value is untouched.  Function
\Lit{re\_re\_sysdef()} reads the system specification variables and
arrays \Lit{system}, \Lit{species[]}, \Lit{potpar[]} and
\Lit{site\_info[]} from the restart file.  These were stored in their
final form after being set up by the previous run so a call to
\Lit{initialise\_sysdef()} is unnecessary.  Alternatively a new system
specification file may be used in which case a similar sequence to
that for a new run is followed.  Memory for the dynamic variable
arrays and the RDF and averages databases must be allocated before
their saved values are restored by \Lit{read\_restart()}.

The simplest startup mode is that from a backup file.  Once it has
been determined that a backup file exists, setup proceeds much as in
the restart case except that the parameters and system specification
are restored unchanged.  Thus the run continues exactly from the
point the backup file was written. A restart file is still opened, but
only to obtain the name of a backup file to search for.

The final act of \Lit{start\_up()} is to call \Lit{banner\_page()}
to print out a nicely formatted page of information to record the
simulation details in the output file.  Control is then transferred
back to the main program where everything is now ready for the
molecular dynamics to begin.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Main Timestep Loop}

The initial entry point into \moldy\ is into function \Lit{main()},
which calls \Lit{start\_up()} (section~\ref{sec:startup}) and then
proceeds into the main loop over molecular-dynamics timesteps
(Figure~\ref{fig:main}).  This loop calls \Lit{do\_step()} which
computes the forces and advances the co-ordinates, velocities and
their angular counterparts by one timestep.  Most of the periodic
tasks not directly associated with progressing the simulation, such as
the accumulation of running averages, velocity rescaling and writing
the output files are called directly from \Lit{main()}.
The exceptions are the binning of site-pair distances for computing
the radial distribution functions which is integrated into the site
forces evaluation, and the writing of trajectory data to the dump file
which is called from \Lit{do\_step()} since the force arrays are
local to that function.

\begin{figure}[tb]
\input{fig_main.ftx}
\caption[The main timestep loop]{The main timestep loop in file
\Fname{main.c} showing the outermost control structures.  Periodic
analysis, trajectory dump or output tasks are all shown here including
the accumulation of the radial distribution function data which is
integrated into the link cell force calculation.}
\label{fig:main}
\end{figure}

\begin{figure}[tbp]
\centering
\input{fig_dostep-a.ftx}
\renewcommand{\thefigure}{\arabic{chapter}.\arabic{figure}(a)}
\caption[Flow  diagram of function \Lit{do\_step()} which performs
a single timestep.]{Flow diagram of function \Lit{do\_step()} which
  performs a single timestep.  (\emph{continued in
    Figure~\protect\ref{fig:dostep-b}})}
\label{fig:dostep}
\label{fig:dostep-a}
\end{figure}

\addtocounter{figure}{-1}
\begin{figure}[tbp]
\centering
\input{fig_dostep-b.ftx}
\renewcommand{\thefigure}{\arabic{chapter}.\arabic{figure}(b)}
\caption[Flow  diagram of function \Lit{do\_step()} which performs
a single timestep.]{Flow diagram of function \Lit{do\_step()} which
  performs a single timestep.  (\emph{continued from
    Figure~\protect\ref{fig:dostep-a}})}
\label{fig:dostep-b}
\end{figure}

The timestep loop continues until either the requested number of steps
have been completed, a \Lit{SIGTERM} or \Lit{SIGXCPU} signal is
received or one more step would exceed the CPU time limit set in
\Lit{control.cpu\_limit}.  Only the normal termination case is shown
in Figure~\ref{fig:main}.  In the case of an early termination
\Lit{write\_restart()} is called to write out a backup file so the
simulation may be restarted later.  The signal handling functions
\Lit{shutdown()} for \Lit{SIGTERM} and \Lit{SIGXCPU} and
\Lit{siglock()} for other signals are installed in \Lit{main()}
following the call to \Lit{start\_up()}.  Function \Lit{shutdown()}
simply sets a flag which is checked at the end of every iteration of
the timestep loop.  This allows for an orderly shutdown if the CPU
limit is exceeded or if the run must be interrupted for some other
reason. For conditions which require immediate program exit, function
\Lit{siglock()} is called to delete the lock files before exiting.

The tasks of calculating the forces, implementing the equations of
motion and updating the dynamic variables each timestep are managed by
function \Lit{do\_step()}.  The conceptually simple calculation of
forces and stepping of co-ordinates is made lengthy and less
transparent by the need to handle the rigid-molecule equations of
motion and the constant-pressure and -temperature extended system
equations.  The procedure is set out in Figures~\ref{fig:dostep-a}
and~\ref{fig:dostep-b}.  The main stages of the calculation are
\begin{enumerate}
\renewcommand{\theenumi}{\emph{\alph{enumi}}}
\item update all of the centre-of-mass co-ordinates, quaternions and
  extended-system variables according to steps \emph{i} and
  \emph{ii} of equations~\ref{eqn:beeman}. This is done by function
  \Lit{step\_1()} which also applies the quaternion normalization
  and constraints of equations~\ref{eqn:qnorm} and~\ref{eqn:qconst}.
\item call \Lit{force\_calc()} and \Lit{ewald()} to
  evaluate the potential energy and the forces on all atomic sites.
  The site co-ordinates must themselves be computed from the centre-of
  mass co-ordinates and the quaternions by function
  \Lit{make\_sites()}. 
\item calculate the molecular centre-of-mass forces and torques using
  equations~\ref{eqn:comf} and~\ref{eqn:comt}  which are implemented
  in functions \Lit{mol\_force()} and \Lit{mol\_torque()}. At
  this point the accelerations from the previous timestep are
  ``shuffled down'' from the \Lit{acc}, \Lit{qddot} \etc\ arrays
  in \Lit{system} and \Lit{species[]} to \Lit{acco},
  \Lit{qddoto} to make way for the new accelerations computed in
  this timestep. 
\item calculate the internal stress (equation~\ref{eqn:prstress}) and
  the ``accelerations'' of the MD cell matrix from the
  Parrinello-Rahman equations of motion. Function \Lit{rahman()}
  implements equation~\ref{eqn:rahman}.
\item calculate the new centre-of-mass and extended-system
  variable accelerations including the velocity-dep\-end\-ent parts
  which arise in a constant-pressure or -temperature calculation.
  Iterate steps \emph{iii}--\emph{v} of equations~\ref{eqn:beeman}
  until the velocities have converged. \label{loop:vel}
\item calculate the new angular and rotational thermostat
  accelerations. The Euler equations (\ref{eqn:euler}) and
  equation~\ref{eqn:qddot} are used by function \Lit{euler()} to
  evaluate the second time-derivatives of the molecular quaternions.
  Iterate until the corresponding angular velocities have
  converged. \label{loop:quat} 
\item call \Lit{step\_2()} to apply the final step \emph{iv} of
  equations~\ref{eqn:beeman}.
\item write requested co-ordinates \etc\ to the dump file.
\end{enumerate}

The loops of steps~\ref{loop:vel} and~\ref{loop:quat} iterate until
the molecular centre-of-mass velocities and quaternion time
derivatives have adequately converged (in practice about 3 or 4
iterations).  No additional iteration is applied to converge the
extended-system dynamic variables, since in any practical system these
should be very slowly-varying compared to molecular motion and any
error introduced will be very small.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The Site-Forces Calculation}

\begin{figure}[tb]
\noindent
\input{fig_link-cell.ftx}
\caption{The Link-Cell short-range force calculation}
\label{fig:link-cell}
\end{figure}

The evaluation of the forces on atomic sites comprises almost all of
the run-time of any reasonably sized simulation --- over 95\% for
systems of only a few hundred atoms.  Efficiency of execution is
therefore a primary consideration in this part of the code.  It is
frequently the case that a straightforward implementation of an
algorithm is not optimally fast, which regrettably means that
the optimized code is not as transparent to read as for other, less
critical parts of the program.

The link cell algorithm for the short-ranged part of the forces
(section~\ref{sec:link-cell}) is one which scales very well to large
systems.  In its original form~\cite{quentrec:75} the MD cell is
divided into a number of ``subcells'' and a linked-list
structure~\cite{knuth:73a} lists the molecules or atoms belonging to
each subcell.  The inner loops of the force calculation must therefore
use an \emph{indirect} indexing operation to obtain the co-ordinates
on every iteration: the index of a molecule on each iteration depends
on the index of the previous iteration.  This kind of loop is
inherently un-vectorizable which grossly limits the efficiency on
vector computers.  

\begin{figure}[tb]
\noindent
\input{fig_ewald.ftx}
\caption{Evaluation of the reciprocal-space parts of the ewald sum}
\label{fig:ewald}
\end{figure}

To overcome this limitation a further step is needed, as suggested by
Heyes and Smith~\cite{heyes:87}.  Inside the loop over subcells, the
linked list is pre-scanned and used to construct an array containing
the indices of the molecules in the list.  This is known as the
\emph{neighbour list} since it points to the molecules in the region
of the subcell under consideration. The co-ordinates are then
assembled into a contiguous array using a \emph{gather} operation.  The
inner force loop then becomes a straightforward DO loop over this
temporary array which \emph{is} vectorizable.  In addition to the
co-ordinates, a corresponding gather operation using the same neighbour
list operates on the electric charge and potential parameter arrays.
The corresponding temporary arrays are also accessed in the inner loop
over neighbour sites with a single array subscript.  Finally the
computed forces are added to the main site force arrays using a
\emph{scatter} operation, inverse to the gather.

Although this algorithm was designed for vector machines, it is also
highly efficient on modern RISC processors which universally employ a
cache-based memory architecture.  Since adjacent iterations of the
inner loop access adjacent locations in memory, loading a cache line
will bring the operands of the next few iterations into cache.
Otherwise a (very slow) cache load would be necessary on every loop
iteration. 

The link cell functions are all in \Fname{force.c}
(Figure~\ref{fig:link-cell}).  The outer-level function is
\Lit{force\_calc()}.  Function \Lit{neighbour\_list()}
constructs a list of subcells within the cutoff radius of a reference
cell.  By adding an offset and applying periodic boundary conditions
this list yields the neighbour cells of \emph{any} subcell.  This
should not be confused with the neighbour \emph{sites} list above.  In
fact the list contains only a hemisphere of cells since Newton's third
law is exploited to halve the computational cost.  A more rigorous
list may be computed instead by \Lit{strict\_neighbour\_list()}
which is selected in strict cutoff mode (see
section~\ref{sec:strict-cutoff}).  Next an array of potential
parameters called \Lit{potp} is constructed.  This has an innermost
dimension of the number of sites, which maps one-to-one onto the
co-ordinates array. It will be used as the argument of the gather
operation using the site neighbour list.  Function
\Lit{fill\_cells()} constructs the linked list of molecules in each
subcell.

The loops over cells are all contained in \Lit{force\_inner()}.
Within the loop over subcells the neighbour list of \emph{sites} for
this cell is constructed from the list of neighbour \emph{cells} by
\Lit{site\_neighbour\_list()}.  This list is then used as the index
array to gather the co-ordinates, charges, potential parameters and
any periodic boundary vectors.  The innermost loops compute the site
pair distances, the potential and the forces on the neighbour list
sites.  The actual potential and scalar-force evaluation is delegated
to function \Lit{kernel()} for ease of comprehension and modification.
This takes as its arguments an array of squared pair distances and
corresponding arrays of potential parameters and site charges and
returns the potential energy and an array containing the scalar part
of the force, $\phi'(r_{ij})/r_{ij}$. The structure of \Lit{kernel()}
is designed to evaluate all the different kinds of potential functions
(see section~\ref{sec:potentials}) as efficiently as possible.  It
contains separate versions of a vector loop for each distinct
potential type, both with and without electrostatic charges.  For the
charged case, the complementary error function is approximated to an
accuracy of approximately 1 part in $10^{-6}$ by the formula given in
Abramowitz and Stegun\cite[section 7.1.26]{abramowitz:70}.

Pair distances for the calculation of radial distribution functions
are evaluated by \Lit{rdf\_inner()} whose structure
resembles a simplified \Lit{force\_inner()}. It does not call
\Lit{kernel()} or compute forces but instead calls
\Lit{rdf\_accum()} which bins the computed pair distances. The
separate function allows the use of a larger cutoff than for the force
and potential evaluation.

The reciprocal-space part of the Ewald sum is evaluated in function
\Lit{ewald()}, shown in Figure~\ref{fig:ewald}.  This is a fairly
straightforward implementation of the \emph{k}-space terms of
equations~\ref{eqn:ewald}, \ref{eqn:ewald-force}
and~\ref{eqn:ewald-stress}, and differs from common implementations
only in the respect that it must correctly handle
parallelepiped-shaped MD cells and therefore a triclinic grid of
\emph{k}-vectors.  A list of vectors satisfying $\bm{k} > \bm{0}$ and
$|\bm{k}| < k_c$ is pre-computed to simplify the control condition of
the main \emph{k}-vector loop.

Again, computational efficiency dictates much of the structure of
\Lit{ewald()}.  The values of $\cos(\bm{k \cdot r}_i)$ and $\sin(\bm{k
  \cdot r}_i)$ must be computed for every site~$i$ and every vector
$\bm{k} = h \bm{a}^* + k \bm{b}^* + l \bm{c}^*$ with $|\bm{k}| < k_c$.
Since the cosine and sine functions are relatively expensive to
evaluate, the values of $\cos(h \bm{a}^*\bm{ \cdot r}_i)$, $\cos(k
\bm{b}^*\bm{ \cdot r}_i)$ \etc\ are precomputed for each site~$i$ and
$h = 0, 1, \ldots h_{\textnormal{max}}$, $k = 0, 1, \ldots
k_{\textnormal{max}}$ and stored in arrays of dimension
\Lit{[hmax][nsites]} \etc\ Then within the loop over \emph{k}-vectors
the trigonometric addition formulae are used to construct $q_i
\cos(\bm{k \cdot r}_i)$ and $q_i \sin(\bm{k \cdot r}_i)$ using only
arithmetic operations.  That task is delegated to function
\Lit{qsincos()} since certain compilers can optimize it better that
way.  The self-energy and charged-system terms of
equations~\ref{eqn:ewald} and~\ref{eqn:ewald-stress} are also
evaluated in \Lit{ewald()}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Parallelization}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
It has been predicted since the early 1980s that parallel computers
would offer the very highest performance for scientific computing.
That vision has been somewhat slow in coming about, in part due to the
difficulty of writing programs to explicitly exploit unique and
idiosyncratic architectures and the lack of portability or
re-usability of the resulting code.  It was often necessary to write
programs in machine-specific languages~\cite{pawley:82,bowler:87}, use
proprietary and obscure library calls~\cite{clementi:85} and be
designed around a specific communications topology.  Nevertheless
molecular-dynamics simulation was one of the earliest applications of
parallel computers and many simulations have been undertaken despite
the difficulties~\cite{pawley:82,clementi:85,rapaport:88}.

The emergence and widespread adoption of the single-program
multiple-data (SPMD) programming model and the standardization of
parallel communications libraries in the 1990s has much improved the
situation.  In this model a parallel program is treated as a set of
copies of a single program executing asynchronously and independently
on different processors and which communicate using library calls.
The program is written in a standard language and arranged to divide
the calculation among the processors in some way so that each handles
a subset of the operations. The model is completed by the addition of
a library of communications routines which allow the separate parts of
the calculation to be assembled to give the full, desired result. A
significant advance was the availability of parallel libraries such as
TCGMSG~\cite{tcgmsg:94}, PVM~\cite{pvm:94}, BSP~\cite{bsp:93} and the new
standard MPI~\cite{mpi:94}.  Together these developments allow a program
to be both parallel and sufficiently independent of architectural
details to be portable to a wide range of parallel environments.
These may include shared-memory and distributed-memory
multiprocessors, and even networks of workstations.  

Of course formal portability is no guarantee of good performance on
hardware with widely differing processor and communications
performance. That is a function of the granularity of the problem with
respect to communications latency and volume of data with respect to
communications bandwidth. Both of these depend on the nature of the
problem and the parallelization strategy.

\subsection{Parallel Strategy}
\label{sec:parstrat}
\moldy\ uses the ``replicated data'' approach to parallel molecular
dynamics~\cite{clementi:85,smith:91} whereby each processor maintains
a complete set of dynamical variable arrays for all particles.  The
short-ranged and reciprocal-space force calculations are divided among
the processors and a global sum operation is used to add the separate
contributions to the forces and propagate a copy of the complete force
array to every processor.  This ``parallel'' part of the calculation
dominates the execution time and shows a close to linear speed-up. It
takes over 95\% of the CPU time even for quite small systems of a few
hundred particles.  The remainder of the calculation, in particular
the integration of the equations of motion is not parallelized but is
performed redundantly on every processor simultaneously.\footnote{It
  is essential that the particle co-ordinates are identical on every
  processor and remain so throughout the simulation run.  Since the
  equations of motion are chaotic the tiniest numerical difference in
  the forces between processors will cause the trajectories to
  diverge.  It is not difficult to arrange that a global sum returns
  results identical to the last decimal place on all processors and
  this is guaranteed by the BSP, and cray SHMEM implementations and
  strongly recommended by the MPI standard.  \moldy\ relies on this
  behaviour to ensure that no divergence occurs.  If this were not the
  case it would be necessary to add a step to synchronize the
  co-ordinates periodically.  This may also be an issue for running on
  networks of workstations - it is assumed that the numerical
  properties of all the processors are identical.  The equality of the
  separate copies of the co-ordinates is checked periodically and the
  simulation exits if divergence is detected.} This ``serial'' part of
the code will therefore limit the parallel speedup on large numbers of
processors by Amdahl's law. However this part of the computational
work only grows as $N$ compared with $N^\frac{3}{2}$ for the forces
calculation (see section~\ref{sec:ewald-auto}).  Consequently the
``serial'' part becomes an increasingly insignificant fraction of the
computation as the system size increases.  Since one might reasonably
expect that in practice $N$ is scaled with the number of processors
the serial part does not seriously limit the parallel performance.

The advantages of the replicated data strategy are firstly simplicity
of programming.  Most of the code is identical to the serial program
which greatly eases maintenance.  Secondly load-balancing is much more
straightforward than with domain decomposition methods.  This will be
discussed below.  Thirdly the communications granularity is coarse,
consisting of one global summation per timestep.  This makes it very
suitable for loosely-coupled processors such as a workstation cluster
where the communications \emph{latency} is high.  Finally it is very
efficient for small and medium-sized systems.

The big disadvantage is that the scaling to very large numbers of
processors is poor, which will eventually limit the size of system
which can be simulated.  This is because both the amount of memory
used per processor and the total amount of data to be communicated per
processor increase linearly with $N$, the number of particles in the
system.  However in comparison with other supercomputing applications,
molecular dynamics simulation uses relatively little memory and most
supercomputers can easily accommodate simulations of many thousands of
particles.  Though scaling to multi-million particle systems
would be desirable, most practical simulations of solids or liquids
can be accomplished using systems of a few tens of thousands of
particles or fewer.

\subsection{Implementation}

Two of the design goals are that the serial and parallel versions of
\moldy\ can be built from the same code, and that the code is easily
portable to a number of communications libraries.  The C preprocessor
macro \Lit{SPMD} is used to conditionally include the parallel
code. All calls to the parallel library interface are protected by
conditional-compilation and if \Lit{SPMD} is undefined at compile
time then the serial version is built.  These calls are limited to a
very few modules --- \Fname{main.c} for the parallel set-up,
\Lit{do\_step()} in \Fname{accel.c} for the global summation of the
forces, virial and potential energy and \Lit{message()} in
\Fname{output.c} for error handling.  Furthermore the communications
library is not called directly, but through interface functions
defined in file \Fname{parallel.c} (these are listed in
section~\ref{sec:parport}).  This means that only \Fname{parallel.c} need
ever be modified if a port to a different communications library is
needed, as the rest of the code sees a common interface.  As supplied
\Fname{parallel.c} contains implementations for the MPI library, the
TCGMSG library, the Oxford BSP library and the Cray SHMEM library for
the T3D/T3E series machines (see section~\ref{sec:spmdpar}).  One of
these is selected by conditional compilation of \Fname{parallel.c} with
one of the preprocessor symbols \Lit{MPI}, \Lit{TCGMSG},
\Lit{BSP} or \Lit{SHMEM} defined.

\subsection{Input/Output and Startup}
\label{sec:pario}

Since each processor runs an identical copy of the program executable,
steps must be taken to ensure that input and output are handled by a
single processor.  Otherwise a parallel run would print P copies of
every line if running on P processors.  Indeed there are some parallel
systems on which only one processor is allowed to perform input or
output. It follows that all parts of the code which perform I/O must
be aware of which processor this instance is running on.  This is done
using a global integer variable, \Lit{ithread} which contains
the index (or ``rank'') of the processor.  Another variable
\Lit{nthreads} contains the value of P.  These are set up in
function \Lit{par\_begin()} called from \Lit{main()} and passed
by external linkage to every module which needs them.  Processor 0
performs all input/output, which is arranged by testing
\Lit{ithread} prior to any I/O call, \eg\\
\parbox{\textwidth}{%
\begin{quote}
  \Litf
      if( ithread == 0 \&\& control.istep \% control.print\_interval == 0)\\
\hspace*{1cm}          output();
\end{quote}}\\
which is the code in \Lit{main()} used to print the regular output.
These variables are also present in the serial code, where they are
harmlessly redundant. In that case \Lit{ithread} is always set to 0
and \Lit{nthreads} to 1.

\Fname{Parallel.c} also contains the function \Lit{replicate()} to
pass the system specification and dynamical variables from processor 0
to all of the others.  This is called from \Lit{main()} after
\Lit{start\_up()} has returned.  It allocates memory for the system
specification and dynamical variables on all other processors using
the same functions as \Lit{start\_up()} itself and calls
\Lit{copy\_sysdef()} and \Lit{copy\_dynamics()} to broadcast the
data from processor 0 to all of the others.  The function
\Lit{par\_broadcast()} defined earlier in \Fname{parallel.c}
calls the underlying communications library to broadcast the
data globally.  On exit from \Lit{replicate()} \emph{every}
processor now contains a complete set of data and is ready to begin
the run.

Error or warning conditions are handled by function \Lit{message()}
in \Fname{output.c} if called with the \Lit{FATAL} or \Lit{WARNING}
flags set in its argument list.  In the serial case this prints out a
failure message and calls \Lit{exit()} to terminate the run.  In a
parallel run, an error condition may occur on just one processor or on
all simultaneously depending on precisely what caused the problem.
Furthermore, if just one processor is involved, it may not be the I/O
processor (rank 0).  The approach of printing the message only from
processor 0 is inadequate since there would be no indication that
something has gone wrong.  But neither is it appropriate to print on
all, since that would result in a multiplicity of messages in some
cases.  The approach taken is that \Lit{message()} always prints
the error irrespective of which processor is executing it, but that
calls to \Lit{message()} are made conditional on
\Lit{ithread~==~0} for those conditions known to occur on all
processors simultaneously. If the condition signalled was
\Lit{FATAL} then \Lit{message()} finally calls \Lit{par\_abort()}
which terminates the run on all processors.

\subsection{Distributed Forces Calculation}

The two parts of the forces calculation which must be parallelized are
the short-ranged forces calculation and the reciprocal-space part of
the Ewald sum.  The outermost loop of the link cell forces calculation
in function \Lit{force\_inner()} runs over all subcells within the
simulation cell (see Figure~\ref{fig:link-cell}).  In the serial case, 
it has the form\\
\parbox{\textwidth}{%
\begin{quote}
  \Litf
  for( icell = 0; icell < nx*ny*nz; icell++)\\
  \{\\
  \hspace*{1cm}\textnormal{[\emph{Evaluate forces on particles in cell}
  \Lit{icell}]}\\ 
    \}.
\end{quote}}\\
The iterations of this loop are distributed over processors by
rewriting it as\\
\parbox{\textwidth}{%
\begin{quote}
  \Litf
  for( icell = ithread; icell < nx*ny*nz; icell += nthreads)\\
  \{\\
  \hspace*{1cm}\textnormal{[\emph{Evaluate forces on particles in cell}
  \Lit{icell}]}\\ 
    \}.
\end{quote}}\\
where the integer variables \Lit{ithread} and \Lit{nthreads} contain
the rank of the processor and the total number of processors
respectively. Since \Lit{ithread} has a different value on each
processor, the separate copies of the force arrays contain only the
contributions from the set of subcells assigned to that processor.
After completion of the forces calculation the individual arrays are
summed in function \Lit{do\_step()}.  Similar partial contributions to
the potential energy and the stress are also globally summed.
Provided that the number of subcells is rather greater than the number
of processors and the number of particles per subcell is fairly
constant, this algorithm automatically ensures that the computation is
divided evenly between the processors.

The reciprocal-space sum may be parallelized either by distributing
the loop over \emph{k}-vectors over
processors~\cite{clementi:85,smith:92} or by partitioning the
particles between processors. Smith~\cite{smith:92} called the former
strategy the ``reduced k-vector list'' (RKL) method and the latter the
``reduced ion list'' (RIL) method.  \moldy\ contains implementations
of both methods.  In the RKL method, it is necessary to pre-compute a
list of \emph{k}-vectors within the cutoff sphere (see
Figure~\ref{fig:ewald}) which is stored in the array \Lit{hkl[]}.
(Each element of \Lit{hkl[]} is a struct containing the values of $h$,
$k$, $l$ and the vector components of $\bm{k}$.) The loop over
\emph{k}-vectors then takes the form of a single loop over this list,
which is easily sliced over processors exactly as the loop over
subcells above.\\
\parbox{\textwidth}{%
\begin{quote}
  \Litf
   for(phkl = hkl+ithread; phkl < hkl+nhkl; phkl += nthreads)\\
   \{\\
\hspace*{1cm}\textnormal{[\emph{Compute the contribution of
   \emph{k}-vector in} \Lit{phkl}]}\\
   \}.
\end{quote}}\\
At the end of this loop the force arrays contain the contributions to
the force on each site from the particular set of \emph{k}-vectors
handled by that processor.  The total forces are obtained by globally
summing these arrays over processors.  In fact since the same arrays are
used to store both the short-ranged and long-ranged contributions to
the force then only one global sum is needed for the forces.  Since
the contribution at each \emph{k}-point is a sum of fixed length and
takes exactly the same time to evaluate as any other, this algorithm
is always optimally load-balanced.

There is also an implementation of the alternative, RIL
parallelization strategy in file \Fname{ewald-RIL.c}, which is a direct
replacement for \Fname{ewald.c}.  In this case each processor handles a
subset of the particles and all \emph{k}-vectors.  This involves an
extra global sum within the loop over \emph{k}-vectors to evaluate
the total structure-factor for each $\bm{k}$.  

\subsection{Radial Distribution Functions}

The accumulation of distances for the radial distribution function
calculation is potentially costly since it is a site-pair property. It
is therefore handled using the parallel link cell method exactly as
for the site forces calculation by functions \Lit{rdf\_inner()} and
\Lit{rdf\_accum()}.  However the contributions from different
processors do \emph{not} need to be summed every time
\Lit{rdf\_inner()} is called, but may be left to accumulate
separately.  The data is globally summed by function
\Lit{par\_isum()} only when \Lit{rdf\_out()} is called to
calculate and print the RDFs or just before a restart file is written.

\appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Example System Specifications}  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:examples}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Argon}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{verbatim}
# LJ Argon - about as simple as you can get
# Parameters from Allen and Tildesley Table 1.1
Argon 108
1          0           0          0    39.948 0 Ar
end
Lennard-Jones
1 1 3.984 3.41
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{TIPS2 Water}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This is the four-site water model of Jorgensen\cite{jorgensen:82}.  
Only the oxygen site interacts via the Lennard-Jones
potential, and the charge site, M, is displaced 0.15{\AA}\ from the Oxygen.
\begin{verbatim}
# Modified TIPS2 water
Water 64
1          0            0          0 16    0 O
2  0.7569503            0 -0.5858822 1 0.535 H
2 -0.7569503            0 -0.5858822
3          0            0      -0.15 0 -1.07 M
end
lennard-jones
1 1 0.51799  3.2407
end
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Aqueous MgCl$_2$ Solution}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This is a three-component system consisting of MCY
water\cite{matsuoka:75}, magnesium and chloride ions.  The Mg$^{2+}$
potential was fitted to the SCF calculations of Dietz and
Heinzinger\cite{dietz:82} and the Cl$^-$ to the calculations of
Kistenmacher, Popkie and Clementi\cite{kistenmacher:73b}.  Note that
the potential parameters are expressed in kcal mol$^{-1}$, and the
control file must set the parameter \Lit{time-unit=4.8888213e-14}.
\begin{verbatim}
# MCY Water/ Mg2+ / Cl - solution
Water 200
1          0            0          0 16    0 O
2  0.7569503            0 -0.5858822 1     0.717484 H
2 -0.7569503            0 -0.5858822
3          0            0    -0.2677 0 -1.434968 M
Magnesium 4
4          0            0          0 24.31 2 Mg2+
Chloride  8
5          0            0          0 35.45 -1 Cl-
end
MCY
1 1 1088213.2   5.152712        0               0
1 2 1455.427    2.961895        273.5954        2.233264
2 2 666.3373    2.760844        0               0
1 4 47750.0     3.836           546.3           1.253 # New values of Mg potl
2 4 111.0       1.06            0               1.0   
1 5 198855.0    3.910           0               0
2 5 1857.0      2.408           77.94           1.369
4 5 28325.5     2.65            0               0
end
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Quartz}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{verbatim}
# Quartz parameters from Van Beest, Kramer and Van Santen
# Physical Review Letters 64,(16) p1955 (1990)
# Units are eV, A, el chg. so time-unit=1.0181e-14
Oxygen 384
1       0       0       0       16      -1.2    O
Silicon 192
2       0       0       0       28.0855 2.4     Si
end
buckingham
1 1     175.0000        1388.7730       2.76000
1 2     133.5381        18003.7572      4.87318
2 2     0.0             0.0             0.0
end
4.903 4.903 5.393 90 90 120 4 4 4
Oxygen   0.415000     0.272000     0.120000
Oxygen   0.857000     0.5850000    0.453300
Oxygen   0.728000     0.143000     0.453300
Oxygen   0.143000     0.728000     0.880000
Oxygen   0.272000     0.415000     0.546700
Oxygen   0.5850000    0.857000     0.213300
Silicon  0.465000     0            0
Silicon  0.535000     0.535000     0.333300
Silicon  0            0.465000     0.666700
end
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Utility Programs} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Twelve utility programs are included in the \moldy\ package, mostly for
manipulation and analysis of dump data (see section~\ref{sec:dumping}).
They are easily compiled on unix systems using the makefile: the
command is ``\Lit{make}~\emph{progname}'' for each program or
``\Lit{make utilities}'' to make the lot.  They are written with
unix systems in mind using unix-style option arguments, but ought to
compile and run under VMS if defined as foreign commands.

Several of them require you to specify lists of (integer) numbers, for
example selected molecules, time slices \etc, which share a common
syntax for such options. The numbers 1, 5, 17 to 20 inclusive and
34,44,54\ldots94 are selected by the command-line argument
\mbox{\Lit{-t 1,5,17-20,34-100:10}}.  Selectors are separated by
commas and each one may be a range separated by a hyphen with an
optional increment following a colon.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dumpconv}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:dumpconv}
\emph{Dumpconv} is a tool for moving binary dump files between
computers of different architectures.  It has mostly been superseded
by the portable XDR format dump files introduced in version~2.1 (see
section~\ref{sec:xdr}) but is retained in case of machines for which
no XDR implementation is available.  The command
\begin{center}
\Lit{dumpconv} \textit{binary-dump-file text-dump-file} 
\end{center}
creates a straightforward ASCII text file with a representation of the
dump information in the binary file including the header.  The command
\begin{center}
\Lit{dumpconv -d} \textit{text-dump-file binary-dump-file} 
\end{center}
converts it back.  Seven significant decimals are used which ought to
retain almost all of the precision of the single precision binary
floating-point numbers.  You can also convert an old ``native'' format
dump into XDR format using the \Lit{-x} option, \emph{viz}
\begin{center}
\Lit{dumpconv -x} \textit{native-dump-file xdr-dump-file}. 
\end{center}
The \Lit{-x} and \Lit{-d} options may be combined if the input is a
text format dump.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dumpext}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Dumps are designed so that \moldy\ can take care of all the
bookkeeping and perform data security checks, and to divide a lot of data
into manageable portions.  It is therefore not in a convenient form
for reading by other programs, especially FORTRAN ones.
\emph{Dumpext} is a program which processes dump files, extracts a
subset of the information and outputs it in a form more suitable for
reading by other programs.  It is invoked with the command:
\begin{center}
\Lit{dumpext -R} \textit{nmols} \Lit{-Q} \textit{nquats} 
\Lit{-c} \textit{components}
\Lit{[-t} \textit{time-slices}\Lit{]} \\
\Lit{[-m} \textit{molecules}\Lit{]}
\Lit{[-v]} 
\Lit{[-o} \textit{output-file}\Lit{]}
\Lit{[-b]} 
\textit{dump-file1 dump-file2} \ldots
\end{center}
The meanings of its arguments are
\begin{Argdescription}
\item[-R] the total number of molecules.  This argument is compulsory.
\item[-Q] the number of polyatomic molecules.  This argument is compulsory.
\item[-c] which piece (''component'') of the information in dump
record to extract.  
\begin{enumerate}
\itemsep=0pt
\parskip=0pt
\item C of M positions
\item quaternions
\item unit cell matrix
\item potential energy
\item C of M velocities
\item quaternion derivatives
\item unit cell velocities
\item C of M accelerations
\item quaternion accelerations
\item unit cell accelerations
\item C of M forces
\item torques
\item stress tensor
\end{enumerate}
This argument is compulsory.
\item[-t] which time slices (or dump records) to extract.  This is a
selector format list and is the index in the whole dump sequence, not
just a single file.  Time slices or dump records are sequentially
numbered in the dump files from 1.  Defaults to all time slices.
\item[-m] extract information for selected molecules.  This is a
selector list specifying the molecule index.  Defaults to all
molecules.
\item[-v] give more verbose information while processing dump files.
\item[-o] name of optional output file.  Defaults to standard output.
\item[-b] selects binary output in single-precision floating point
numbers. Defaults to ASCII formatted numbers.
\end{Argdescription}
If any of the compulsory arguments are omitted, you will be prompted
to supply a value.  In particular you must \emph{always} supply the
number of molecules and polyatomic molecules.  (This information is
not recorded in the dump header and is needed to determine the number
of co-ordinates and quaternions in each dump record.)  You must
specify which pieces of information to extract using the \Lit{-c}
option. Typing \Lit{-c 0} extracts all components. Option \Lit{-c -1} 
outputs header info from the dump file/s in list format.  

The dump files must, of course, be part of the same dump sequence;
this is carefully checked.  They may be supplied as arguments in any
order; \emph{dumpext} automatically determines the sequence from
the information in the headers.  This is not as pointless as it sounds,
since the list may be generated using unix shell wild-cards which arrange
them in alphabetical rather than numeric order.

The output is arranged in columns, one line per time slice.  So if,
for example you wish to extract positions and quaternions there will
be 7 columns corresponding to $x,y,z,q_0,q_1,q_2,q_3$. Multiple
components are printed in the integer order of the component,
\emph{not} the order specified with \Lit{-c}. If binary output is
asked for with the \Lit{-b} option the order is the same. The numbers
are written sequentially as single-precision floating-point numbers
(in machine native format) without record delimiters.  The records may
be easily read in C with an \Lit{fread()} call with the appropriate
number of bytes or from FORTRAN77 using direct-access unformatted
read\footnote{The usual FORTRAN sequential unformatted read is not
  suitable as this expects record size information to be present.
  \emph{Dumpext} can not write this as its format is entirely
  determined by the whim of the compiler writer.  FORTRAN unformatted
  sequential files are not guaranteed to be portable even between
  different compilers on the same machine.} of the appropriate length
records\footnote{Be aware that the FORTRAN77 standard does not
  guarantee what units the record length is specified in.  Predictably
  some manufacturers' compilers use bytes and others words.  Consult
  the documentation!} \Lit{OPEN(\ldots,ACCESS=DIRECT,LRECL=nnn)}.  In
the above example there are $3 \times 4 + 4 \times 4 = 28$ bytes in
each record.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mdavpos}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Mdavpos} is a utility for calculating the average positions of particles
from time slices recorded during a \moldy\ run. The utility is similar to
\emph{Mdshak}, with command line options

\begin{center}
\Lit{mdavpos}
\Lit{-s} \textit{system-specification} \Lit{|}
\Lit{-r} \textit{restart-file}
\Lit{[-t} \textit{dump-range}\Lit{]} \\
\Lit{[-f} \textit{output-type}\Lit{]} 
\Lit{[-a]}
\Lit{[-l]}
\Lit{[-i]}
\Lit{[-v]} 
\Lit{[-o} \textit{output-file}\Lit{]}
\textit{dump-file1 dump-file2} \ldots
\end{center}

where the arguments have the following meanings

\begin{Argdescription}
\item[-s] read a system specification file.
\item[-r] read a restart file. Only one of \Lit{-s} or \Lit{-r} may be given.
\item[-t] range of records in the dump file, specified as a selector format list, to
average positions over. Defaults to all time slices.
\item[-f] give the output in the specified format (see table~\ref{tab:output}).
\item[-a] calculate the average positions using the Cartesian (absolute)
coordinates rather than the fractional coordinates. The default is to
use fractional coordinates.
\item[-l] orthonormalize the average MD cell so that all cell
angles are 90 degrees.
\item[-i] shift averaged positions so that all particles lie within the
MD cell.
\item[-v] give more verbose information while processing dump files.
\item[-o] name of optional output file. Defaults to standard output.
\end{Argdescription}

The dump files can be given in prototype form (as in the control file), or as individual files names.

\begin{table}[h]
\caption{Structure File Output Types}
\label{tab:output}
\begin{tabular}{ll}
\textbf{Type} & \textbf{Description} \\\hline
\Fname{shak}  &   SCHAKAL format (default).\\
\Fname{pdb}   &   Brookhaven Protein Data Bank (PDB) format.\\
\Fname{xyz}   &   XYZ format suitable for \emph{Xmol} or \emph{RasMol}.\\
\Fname{dcd}   &   DCD format suitable for animation by \emph{VMD}.\\
\Fname{vmd}   &   same as \Fname{dcd}.\\
\Fname{cssr}  &   Cambridge Structure Search and Retrieval (CSSR) format.\\
\Fname{arc}   &   Accelrys' Insight II ARC (also CAR, MDF, COR) archive file format.\\
\Fname{xtl}   &   Accelrys' Insight II XTL format.\\
\Fname{bin}   &   raw binary format.\\ \hline
\end{tabular}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mdbond and Bdist}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Mdbond} is a utility for calculating the distances between particles,
 as well as angles between triplets of particles,
 within minimum and maximum values specified using options
\Lit{-b} and \Lit{-a} (for bonds and angles, respectively). If the \Lit{-p}
option is used, 3D periodic boundary conditions are applied so that
distances and angles are calculated for ALL pairs/triplets within the cutoffs,
including those involving mirror atoms. It is therefore possible to use cutoffs
greater than the simulation box lengths.
        
Bond lengths are output in columnar format in increasing order with
the molecule numbers and particle names for each pair of particles given in the
first two columns. The angle data are output after the bond data, also
in columnar format. Each row contains the molecule numbers and particle names
for triplets \emph{i-j-k} , followed by the angle formed about
molecule \emph{i} and the distances \emph{i-j} and \emph{i-k}.

The command line options are:

\begin{center}
\Lit{mdbond}
\Lit{-s} \textit{system-specification} \Lit{|}
\Lit{-r} \textit{restart-file}
\Lit{[-d} \textit{dump-file1 dump-file2} \ldots\Lit{]}
\Lit{[-t} \textit{dump-range}\Lit{]} \\
\Lit{[-b} \textit{bond-limits}\Lit{]} 
\Lit{[-a} \textit{angle-limits}\Lit{]} 
\Lit{[-g} \textit{species-range}\Lit{]} 
\Lit{[-p]} 
\Lit{[-x]}
\Lit{[-j]}
\Lit{[-v]} 
\Lit{[-o} \textit{output-file}\Lit{]}
\end{center}

where the arguments have the following meanings:
\begin{Argdescription}
\item[-s] read a system specification file.
\item[-r] read a restart file. Only one of \Lit{-s} or \Lit{-r} may be given.
\item[-d] read configurational data from dump files given either as a prototype name
containing a \Lit{printf()} format string - see section~\ref{sec:dumping} - or as individual file names.
\item[-t] range of records in the dump file to average positions over (specified in selector
  format). Defaults to all time slices (when configurational data is read from dump file/s.)
\item[-b] bond limits in tenths of angstroms entered in form
  ``minimum-maximum''. Limits may be entered as integers only, so
  smallest difference is 0.1{\AA}. Defaults to 0.2 to 2{\AA}.
\item[-a] angle limits in degrees entered in form ``minimum-maximum''.
  Limits may be entered as integers only, so smallest difference is
  1{\textdegree}. Defaults to 0 to 180{\textdegree}.
\item[-g] range of species to be included, given in selector format,
  where \Lit{1} represents the \emph{first} species. Defaults to all species.
\item[-p] switch on 3D periodic boundary conditions.
\item[-x] ignore right and straight angles.
\item[-j] calculate bonds and angles between molecular sites rather than centres of mass.
\item[-v] give more verbose information while processing dump files.
\item[-o] name of optional output file. Defaults to standard output.
\end{Argdescription}


By default, \emph{mdbond} calculates the distances and angles between molecules' centres of mass.
 For polyatomic species, the particle name in the output is the first two letters
 of the species name, while for monatomic species it is the corresponding atomic symbol. 
Intermolecular distances and angles for all molecular sites
 can be calculated by specifying option \Lit{-j}.
 In this case, the particle name is the atomic symbol
of the corresponding species site. Option \Lit{-j} has no effect for monatomic species.

Species positions can be input using system specification, restart or dump
files. If the latter case is chosen, the bond and angle data for each time
slice are written consecutively to the same output file, with each set of
data separated by a title indicating the number of the respective time
slice.

\emph{Bdist} converts the data output from \emph{mdbond} into a format
suitable for
plotting bond and angle distribution curves. The utility scans through the
output file counting the number of bond lengths/angles within the
specified intervals for different pairs/triplets of species types. The
data is output in two columns, first for bonds and then for angles, with
the mid-point of the bond/angle interval given in the first column and the
number of bonds/angles within that interval in the second column. The
utility is invoked on the command line by:

\begin{center}
\Lit{bdist}
\Lit{[-i} \textit{input-file}\Lit{]}
\Lit{[-b} \textit{bond-range}\Lit{]}
\Lit{[-a} \textit{angle-range}\Lit{]}
\Lit{[-p]}
\Lit{[-o} \textit{output-file}\Lit{]}
\end{center}

where the options are:
\begin{Argdescription}
\item[-i] name of the input file.
\item[-b] bond interval limits in tenths of angstroms entered in form
  ``minimum-maximum:increment''. Limits may be entered as integers
  only, so smallest increment is 0.1{\AA}. Defaults to 0.2 to 2{\AA} with
  a 0.5{\AA} increment.
\item[-a] angle interval limits in degrees entered in form
  ``minimum-maximum:increment''. Limits may be entered as integers only,
  so smallest increment is 1{\textdegree}. Defaults to 0 to
  180{\textdegree}\ with a 1{\textdegree}\ increment.
\item[-p] give output as list of type and number
of neighbouring (bonded) species for each molecule.
\item[-o] name of optional output file. Defaults to standard output.
\end{Argdescription}

Option \Lit{-p} provides an alternative output format where each molecule and its neighbours
are listed in the order \textit{mol-no molecule-name neighbour-species-type1: no-of-neighbours
 neighbour-species-type2: no-of-neighbours...}, with one line per molecule. Angle data is ignored.
\textbf{N.B.} If the file to be analyzed contains
multiple data sets (\eg\ from reading dump files), the data for each time slice
will be separated by lines of the form ``- Time Slice \# -'', where \# corresponds to the
number of that particular time slice.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mdshak}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\emph{Mdshak} was originally written as an interface between \moldy\ 
configurations and a molecular graphics program called
SCHAKAL\cite{schakal:88}.  The current version can write the output in
a variety of formats (specified using option \Lit{-f}), suitable
for input to freely available viewers such as
\emph{VMD}\footnote{Available from
  \url{http://www.ks.uiuc.edu/Research/vmd/}.}, \emph{Xmol} and
\emph{RasMol}.  There is also a file viewer called
``crystal'' written by the author for use with AVS, the general
purpose visualization program, and available free from the
International AVS Centre.\footnote{\url{http://www.iavsc.org/}.}

\emph{Mdshak} writes a file containing the co-ordinates of a
single or of multiple time slices during a \moldy\ run.  It can read
configurations from (\emph{a}) a system specification file plus
lattice start, (\emph{b}) a system specification file plus dump file
(\emph{c}) a restart file or (\emph{d}) a restart file plus dump file.
It can be driven either interactively or using command-line arguments.
If the executable file is named \Fname{mdshak} then the default output
is in SCHAKAL file format. If it is renamed to \Fname{mdxyz},
\Fname{mdpdb}, \Fname{mdcssr}, \Fname{mddcd} (or \Fname{mdvmd}),
\Fname{mdarc} or \Fname{mdxtl} then the default output format
is of the corresponding type.

To assist in making animations of a simulation, the trajectory from
many timesteps can be written to a file in the  CHARMM and Xplor DCD
format.  In conjunction with a PDB file
this may be used as input to the \emph{VMD} visualization program.  Tools for
manipulating DCD files and converting to other formats are also
available from \url{http://www.ks.uiuc.edu/Development/MDTools/}.

In interactive mode you are prompted for the source of the system
specification (sys-spec or restart file) and the configurational
information (restart or dump file).  But you must either redirect the
output (using \Lit{>} on unix) or specify an output file with \Lit{-o}
or the output will go to the screen!

Alternatively, the command line options are
\begin{center}
\Lit{mdshak}
\Lit{[-s} \textit{system-specification} \Lit{|}
\Lit{-r} \textit{restart-file}\Lit{]}
\Lit{[-d} \textit{dump-file1 dump-file2} \ldots\Lit{]}
\Lit{[-t} \textit{dump-range}\Lit{]} \\
\Lit{[-f} \textit{output-type}\Lit{]}
\Lit{[-y]}
\Lit{[-i} \textit{extra-text}\Lit{]}
\Lit{[-v]} 
\Lit{[-o} \textit{output-file}\Lit{]}
\end{center}
where the meanings of the options are
\begin{Argdescription}
\item[-s] read a system specification file
\item[-r] read a restart file.  Only one of \Lit{-s} or \Lit{-r} may
be given.
\item[-d] read configurational data from dump files given either as a prototype name
containing a \Lit{printf()} format string - see section~\ref{sec:dumping} - or as individual file names.
\item[-t] range of records in dump file, specified in selector
format. Defaults to all records (when configurational data read from dump file/s).
\item[-f] Write the output file in the format specified (see table~\ref{tab:output}).
\item[-y] Join up trajectory fragments to eliminate molecules ``leaping''
  from one side of the MD cell to the other.
\item[-i]   this inserts its argument into the output file and is used
to add extra SCHAKAL commands, such as BOX.
\item[-v] give more verbose information while processing dump files.
\item[-o] name of output file. Defaults to standard output.
\end{Argdescription}

\emph{Mdshak} may be useful for more than just visualization purposes
as it extracts atomic co-ordinates from the system specification,
positions and quaternions.  It is written in a modular fashion
to make it easy to add a new output routine (in file \Fname{molout.c}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mdvaf}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\emph{Mdvaf} is a utility for calculating the Velocity Autocorrelation
Function (VACF) from \moldy\ dump files of at least level 2 (see
Section\ref{sec:dumping}). It can also, optionally, calculate the Velocity
Total Correlation Function (VTF) from the same data source.

For a species of $N$ particles, the VACF, $Z(t)$, is defined as:
\begin{equation}
  Z(t) = \frac{1}{N N_t} \sum_{t_0=0}^{N_t} \sum_{n=1}^N v_n(t_0) \cdot v_n(t_0 + t)
\end{equation}
and the VTF as
\begin{equation}
  VTF(t)= \frac{1}{N_t} \sum_{t_0=0}^{N_t} \left ( \sum_{n=1}^N q_n v_n(t_0)
  \cdot  \sum_{n=1}^N  q_n v_n(t_0 + t) \right )
\end{equation}
where $q$ is the total charge of the species, and $v(t)$ the
velocity at time $t$.

The self-diffusion coefficient of a species, $D$, can be
obtained from the integral of its VACF
\begin{equation}
  D = \frac{1}{3} \int_0^\infty Z(t) dt .
\end{equation}

Similarly, the frequency-dependent ionic conductivity, $\sigma(\omega)$, can
be calculated directly from the VTF via:
\begin{equation}
  \sigma(\omega) = \frac{1}{3 V k_B T}    \int_0^\infty VTF(t) e^{-i \omega t} dt
\end{equation}

where $V$ is the volume of the simulation box, $k_{B}$ is Boltzmann's
constant and $T$ is temperature.

The command line options are:

\begin{center}
\Lit{mdvaf}
\Lit{[-t} \textit{dump-range}\Lit{]} \\
\Lit{[-l} \textit{vaf-range}\Lit{]}
\Lit{[-g} \textit{species-range}\Lit{]}
\Lit{[-a]}
\Lit{[-q]}
\Lit{[-v]} 
\Lit{[-o} \textit{output-file}\Lit{]}
\textit{dump-file1 dump-file2} \ldots
\end{center}

where the arguments have the following meanings:
\begin{Argdescription}
\item[-t] range of records in dump file, specified in selector format. Defaults to all time slices.
\item[-l] time intervals to calculate the VACF or VTF values for, specified
in selector format. Default is 0 to half the number of dump
records selected, with an increment of 1.
\item[-g] range of species to be included, given in selector format
where \Lit{1} represents the \emph{first} species. Defaults to all species.
\item[-a] calculate the autocorrelation function for \emph{angular} velocities rather than C of M velocities.
\item[-q] calculate the VTF instead of the VACF if VACF is default, and vice versa.
\item[-v] give more verbose information while processing dump files.
\item[-o] name of optional output file. Defaults to standard output.
\end{Argdescription}

The system info and centre of mass velocities are read from dump files (of \Lit{dump-level}
$>= 2$) given either as a prototype name containing a \Lit{printf()} format
string - see section~\ref{sec:dumping} - or individual dump files.

If the executable file is named \Fname{mdvaf} then the default calculation
is the VACF. If it is renamed to \Fname{mdvtf}, then the default is the
VTF. For the VACF, the output is in the form of five columns
of data headed by the name of the species in question. From left to right the columns correspond to
time, x component, y component, z component, and total VACF. For the VTF, the output consists of
two columns (time and the VTF) headed by the name of the particular species.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Moldyext}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
It is usual to plot the instantaneous values of energy, temperature
\etc\ during the course of a simulation, for example to monitor the
approach to equilibrium.  \emph{Moldyext} processes the periodic
output produced by \moldy\ (see section~\ref{sec:output}) and extracts
this information from each timestep recorded.  It is presented in
tabular form for input into plotting programs.  The command is
\begin{center}
\Lit{moldyext -f} \textit{fields output-file1 output-file2} \ldots
\end{center}
where \emph{fields} is a list in the selector format above.  The
numbering runs from left to right, ignoring newlines and blank columns
so that the translational KE's in Figure~\ref{fig:output} are fields 1
and 14 and the $\sigma_{zz}$ component of the stress tensor is 30.

\emph{Moldyext} can currently only extract information from the
``instantaneous'' section of the output, not the rolling averages or
standard deviations.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Msd}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\emph{Msd} is a utility for calculating the mean square displacements
of selected species from the dump files written during the course of a
Moldy run. A plot of msd against time enables the diffusion
coefficient of that species to be calculated from the gradient using
the Einstein relation
\begin{equation}
   <|\bm{r}(t)-\bm{r}(0)|^2> = 6 D t
\end{equation}
(see Allen and Tildesley\cite[p60]{allen:87}).

For a species of $N$ particles, the mean square displacement is
calculated as
\begin{equation}  
        <|\bm{r}(t)-\bm{r}(0)|^2> = \frac{1}{N N_t}
        \sum_{n=1}^{N} \sum_{t_0}^{N_t}
        |\bm{r}_n(t+t_0) - \bm{r}_n(t_0)|^2
\end{equation}

where $\bm{r}_n(t)$ is the position of particle $n$ at
time $t$.  In interactive mode you are prompted for the source of the
system specification (sys-spec or restart file) and the dump file for
reading the configurational information. You will also be prompted to
supply the dump range limits and msd time interval limits before the
calculation can commence. Be careful to either redirect the output
(using \Lit{>} on unix) or specify an output file with \Lit{-o},
otherwise the output will go to the screen!  More options can be
specified in command line mode:

\begin{center}
\Lit{msd}
\Lit{[-t} \textit{dump-range}\Lit{]} \\
\Lit{[-m} \textit{msd-time-range}\Lit{]}
\Lit{[-i} \textit{initial-time-increment}\Lit{]}
\Lit{[-g} \textit{species-range}\Lit{]}
\Lit{[-w} \textit{trajectory-output-format}\Lit{]} \\
\Lit{[-x|-X]} \Lit{[-y|-Y]} \Lit{[-z|-Z]}
\Lit{[-v]} 
\Lit{[-o} \textit{output-file} \Lit{]}
\textit{dump-file1 dump-file2} \ldots
\end{center}

where the meanings of the options are
\begin{Argdescription}
\item[-t] range of records in dump file, specified in selector format. Defaults to all time slices.
\item[-m] time intervals to calculate the msd values for, specified in
  selector format. Default is zero to half the number of time slices specified with \Lit{-t}.
\item[-i] the increment the initial time, $t_0$, is increased by during
calculation of msd for a given time interval. Defaults to 1.
\item[-g] range of species to be included, given in selector
  format where \Lit{1} represents the \emph{first} species. Defaults
  to all species. 
\item[-u] option to by-pass msd calculation and output the connected particle
trajectories in the format selected by \Lit{-w}. 
\item[-w] by-passes msd calculation and outputs the connected particle trajectories.
Type \Lit{gnu} for format readable by GNUPlot (default) or \Lit{gen} for the generic (simple matrix) format 
(see below). 
\item[-x, -y, -z, -X, -Y, -Z] indicate that limits (in {\AA}) are to be
  specified in the given cartesian direction. If the direction is in
  lowercase, only particles whose initial positions lie \emph{within}
  these limits are included in the msd calculation or trajectory
  output. If the direction is in uppercase, the program will only
  include particles lying \emph{outside} these limits. Limits can be
  imposed in one, two or all three directions in any possible
  combination. However, if both options for a single direction (\eg\
  \Lit{-x} and \Lit{-X}) are used, priority will be given to the
  latter option entered on the command line. The user is prompted for
  the limits at run time. The default is to include all particles.
\item[-v] give more verbose information while processing dump files.
\item[-o] name of optional output file. Defaults to standard output.
\end{Argdescription}

The dump files can be given in prototype form (as in the control file), or as individual files names.

The system info and centre of mass coordinates are read from dump files (of \Lit{dump-level}
$>= 1$) given either as a prototype name containing a \Lit{printf()} format
string - see section~\ref{sec:dumping} - or individual dump files.

The output format for msd calculations consists of four columns for each species
corresponding to the $x, y, z$ components and total msd, with
increasing time intervals down the columns.

The time intervals specified by \Lit{-m} (and initial time increment
\Lit{-i}) are taken relative to the dump records selected with \Lit{-t}
rather than the complete dump records stored in the dump files. For
example, if dump records 1,3,5,\ldots{}19 are extracted using \Lit{-t}, then
time intervals of \Lit{-m} 1-5 correspond to ``real'' intervals of
2,4,\ldots{}10 relative to the original dump file data. It should also be
pointed out that the msds for each time interval are only averaged
over as many initial time slices as the \emph{longest} time interval.
Therefore it is usual to specify the largest value of \Lit{-m} to be
half that of the total number of dump records in order to optimise the
msd time interval and number of calculations over which each msd is
averaged.

Selecting option \Lit{-w} \Lit{gnu} circumvents calculation of the msds and
instead sends the connected trajectory coordinates to the output. The
default format for trajectory data is ``\# \textit{species-name}'' followed by a
row of $x y z$ for a single particle for each increasing time interval.
Trajectory data for each particle are separated by two blank lines.
This is the format favoured by GNUPlot. Option \Lit{-w} \Lit{gen} selects
the generic matrix format in which a single row contains consecutive $x
y z$ coordinates for all particles, with time increasing down the
columns.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Plotrdf}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Plotrdf is a \emph{perl} script which reads \moldy\ output files and
extracts RDF information, skipping page breaks.  It produces output
suitable for reading into most graphics programs, but most notably
\emph{gnuplot} and \emph{xmgrace}%
\footnote{\emph{Gnuplot} can be downloaded from
  \url{http://www.gnuplot.org} and
\emph{Xmgrace} may be obtained from
\url{http://plasma-gate.weizmann.ac.il/Grace/}.}.
It can also write a command script
for either of these two programs if requested.  Obviously you must
have \emph{perl} installed on your computer to use it.

\begin{center}
  \Lit{plotrdf}
 \Lit{[-a]} 
 \Lit{[-gp|-xg]}
 \Lit{[-ps|-eps]}
 \Lit{[-np]}
 \Lit{[-m} \textit{REGEXP}\Lit{]} 
 \textit{moldy-output-file} ...
\end{center}

\begin{Argdescription}  
      \item[-a]         Take average of multiple RDF blocks.
      \item[-gp]        Write a script and invoke GNUPLOT to plot data.
      \item[-xg]        Write a script and invoke GRACE to plot data.
      \item[-ps]        Invoke GNUPLOT or GRACE to plot data and write as a PostScript file.
      \item[-eps]       Invoke GNUPLOT or GRACE to plot data and write as an encapsulated PostScript (EPS) file.
      \item[-np]        Do not plot data, write a GNUPLOT or GRACE script.
      \item[-m]  output/plot only columns which match the (\emph{perl}) regular expression REGEXP. (no '//' needed)    
\end{Argdescription}

The output format is in columns with different components laid out
across the page "r rdf1 rdf2 rdf3 ...".  Multiple RDF blocks in one or
multiple files are processed and output sequentially except if the \Lit{-a}
flag is given, whereupon they are averaged.

If no options or only \Lit{-a} or \Lit{-m} are given, columnar data is
written to standard output.  If either of the plot program commands
\Lit{-pg} or \Lit{-xg} is given, the selected plotting program is
invoked to display the plot. The columnar RDF data  is left in a file
named according to the input file with \Lit{.data} appended.
If either of the \Lit{-ps} or \Lit{-eps} options is given the selected
plot program is used to create a PostScript (or encapsulated
PostScript) file containing the plot.  The \Lit{-np} option modifies
all of the above actions by stopping the invocation of the plot
program and writing the script to standard output instead.

Columns may be selected by matching with a PERL regular expression
(without the usual delimiters) given as the argument to the \Lit{-m}
option.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Ransub}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:ransub}
It is sometimes necessary to simulate systems in which one or
more components have been randomly substituted onto sites
normally occupied by another species. For large numbers of substitutions,
doing this by hand can be tedious, so the utility \emph{ransub} has been
provided to speed up the construction of system specification files in which
``solute'' or ``dopant'' molecules are randomly distributed.
        
The command line options are:
\begin{center}
\Lit{ransub}
\Lit{[-s} \textit{system-specification} \Lit{|}
\Lit{-r} \textit{restart-file}\Lit{]}
\Lit{[-m} \textit{solvent-species}\Lit{]} 
\Lit{[-n} \textit{no. of substitutions}\Lit{]} 
\Lit{[-u} \textit{solute-species}\Lit{]}
\Lit{[-w} \textit{mass}\Lit{]} 
\Lit{[-q} \textit{charge}\Lit{]} \\
\Lit{[-z} \textit{symbol}\Lit{]}
\Lit{[-v} \textit{energy-unit-code}\Lit{]} 
\Lit{[-a} \textit{dopant-structure-file}\Lit{]}
\Lit{[-e} \textit{species-data-file}\Lit{]} 
\Lit{[-y} \textit{potential-parameter-file}\Lit{]} 
\Lit{[-f} \textit{Euler-angle-phi}\Lit{]}
\Lit{[-t} \textit{Euler-angle-theta}\Lit{]} 
\Lit{[-p} \textit{Euler-angle-psi}\Lit{]} 
\Lit{[-x]}
\Lit{[-h]}
\Lit{[-j]}
\Lit{[-c]}
\Lit{[-o} \textit{output-file}\Lit{]}
\end{center}

where the arguments have the following meanings:
\begin{Argdescription}
\item[-s] read a system specification file.
\item[-r] read a restart file. Only one of \Lit{-s} or \Lit{-r} may be given.
\item[-m] the name of the species to be replaced, \ie\ the ``solvent''
  species.
\item[-n] the number of molecules to be substituted.
\item[-u] the name of the substituting or ``solute'' species.
\item[-w] mass of the (monatomic) solute species. Defaults to same mass as the
  first atom of the solvent species.
\item[-q] charge of the (monatomic) solute species. Defaults to same charge as the
  first atom of the solvent species.
\item[-z] name/symbol of the (monatomic) solute species. Defaults to same name as the
  first atom of the solvent species.
\item[-v] energy units desired: 0 = kJ\,mol$^{-1}$, 1 = kcal\,mol$^{-1}$, 2 = eV, 3 = e$^2${\AA}. Only used when reading from restart file.
\item[-a] file containing structural information for polyatomic solute species. Can be in CSSR, PDB, XYZ, XTL 
  or SCHAKAL format.
\item[-e] read the species data (mass, charge, symbol) corresponding to the
solute species name from the file specified.
(Defaults to \Fname{elements.dat}). Overridden  by options \Lit{-w}, \Lit{-q}, \Lit{-z}.
\item[-y] read pair interaction parameters between the dopant and other components
from the file specified. This is a text file of format:
\begin{displaymath}
\begin{array}{llllllll}
\multicolumn{4}{l}{\textit{potential-type}} \\
\textit{symbol}_1 & \textit{charge}_1 & \textit{symbol}_2 & \textit{charge}_2
 & p^{1}_{ij} & p^{2}_{ij} & \ldots & p^{r}_{ij}  \\
\textit{symbol}_3 & \textit{charge}_3 & \textit{symbol}_4 & \textit{charge}_4
 & p^{1}_{kl} & p^{2}_{kl} & \ldots & p^{r}_{kl}  \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
\textit{symbol}_5 & \textit{charge}_5 & \textit{symbol}_6 & \textit{charge}_6
 & p^{1}_{mn} & p^{2}_{mn} & \ldots & p^{r}_{mn}  \\
\Lit{end} \\
\end{array}
\end{displaymath}
where the number of parameters, their values, order and units are the
same as in a system specification file (see section~\ref{sec:sys-spec}).
\item[-f] Euler angle \phi for polyatomic ''solute'' molecules (in degrees).
\item[-t] Euler angle \theta for polyatomic ''solute'' molecules (in degrees).
\item[-p] Euler angle \psi for polyatomic ''solute'' molecules (in degrees).
\item[-x] activate strict matching of species components, \ie, match both site name and charge.
  Default is to match to site name only.
\item[-h] position first site of solute molecule on first site of solvent molecule it is replacing.
  Default is to position molecules using centres of mass.
\item[-c] do not include control parameter info in output file.
\item[-j] generate new quaternions (orientations) for all solute molecules (if polyatomic). Default is to use same quaternions (if available) as molecules being replaced or no rotation if solvent is monatomic.
\item[-o] name of optional output file.
\end{Argdescription}

Polyatomic species can be added using the \Lit{-a} option, which requires a structural data file
of Cambridge CSSR, Brookhaven PDB, Insight XTL, Schakal or generic XYZ format to be specified. If the new polyatomic
species is replacing an existing polyatomic species, by default the same quaternions (orientation) will be used.
 If the species being replaced is monatomic, the dopant molecules will be oriented the same as given in the input structure file unless one or more of
 options \Lit{-f}, \Lit{-t}, \Lit{-p} or \Lit{-j} are specified. Options \Lit{-f}, \Lit{-t} and \Lit{-p} are used to input Euler angles \phi, \theta and \psi, respectively, for aligning all polyatomic solute molecules in the same direction (see equations~\ref{eqn:qeuler}).
 Angles should be between -360 and 360{\textdegree}.
If one or more of \Lit{-f}, \Lit{-t} and \Lit{-p} are specified on the command
line, the remaining unspecified angles are set to 0.

The \Lit{-j} option randomly generates
new quaternions for the solute molecules regardless of whether the species it replaces is
monatomic or polyatomic. This option overrides options \Lit{-f}, \Lit{-t} and \Lit{-p}.

By default, the centre of mass of a dopant molecule is positioned on the centre of mass of the solvent molecule it
is replacing. Specifying the \Lit{-h} option instead matches the position of the first site of the dopant molecule with
the first site of the solvent molecule.
\textbf{N.B.} It
is possible to add a systematic shift (using \Lit{-h}) or positional disorder (using \Lit{-h} and \Lit{-j}) to dopant positions 
by specifying a structure file that contains only a single atom. This atom's
coordinates (in {\AA}) should correspond to the desired shift vector (relative to the first site 
of the species being
replaced).

The properties of monatomic solute species can be entered explicitly on the command
line using options \Lit{-w}, \Lit{-q}, \Lit{-z}, or by reading them
from a species data file. In the case of polyatomic solutes, these options are ignored and the species components
matched with pre-existing components in the original structure or from the species data file (if found). The \Lit{-x} option
forces components to be matched by both name and charge (but not weight), otherwise 
the sites will be matched by name only, \ie the dopant atoms will be given the same properties as the first
identically named site in the original system specification/restart file or species data file, irrespective 
of the charges read in from the dopant structure file. Polyatomic solute species will be given the name of the structure file (without extension) unless specified with \Lit{-u}.

 The default species data file,
\Fname{elements.dat}, is read automatically, and contains data for the
first 103 elements in order of increasing atomic number. The format is
{\textit{species-name}$_{i}$ %
                  \textit{symbol}$_{i}$ \textit{mass}$_{i}$} \textit{charge}$_{i}$
where $mass_{i}$ is in amu, and $charge_{i}$ is the ``commonly occurring'' valence.
Since most elements can have a variety of valences, this
should be edited manually to match the species of interest. This file,
or a file of the same format, can be
modified to contain data for other species (atoms, isotopes or molecules)
as desired. \textbf{N.B.} The maximum number of species that can be
read from a species data file is, by default, 150. This limit can be
increased or decreased by the user by changing the parameter NELEM in
\Fname{specdata.h} and recompiling \emph{ransub}.

If no data is available for a monatomic solute species, it
will be given the same symbol, charge and mass as the first component
of the species it is replacing. In the case of polyatomic dopants,
masses of unrecognized sites will be assigned a value of zero. \textbf{N.B.}
If none of the sites in a polyatomic molecule can be identified, the substitution will
be aborted because the molecule's centre of mass cannot be determined.

If the system data comes from a sys-spec file, the potential
parameters will be written to the output file in the same units as the input file.
If the system data comes from a restart file, by default energy units of kJ.mol$^{-1}$
will be used when writing the potential parameters to the output. Alternative units can be
selected with the \Lit{-v} option.
\textbf{N.B.} The outputted potential parameters may vary slightly from the original
input parameters depending on the exact value of the time-unit used
in the control file to specify energy units other than kJ\,mol$^{-1}$. See
section~\ref{sec:sys-spec}. 
The parameters for the species being introduced
can be read in from a potential parameter file (using option \Lit{-y}),
otherwise the parameters between the solute components and
other atoms wll be assumed to be zero. It is up to the user to ensure that
the potential parameter file uses the same units as the sys-spec and/or restart
files.

The directory in which \emph{ransub} searches for the species data
file and potential parameter file (if specified) is by default the current
directory. The default paths for these
files can be changed to suit the user's local environment by editing the
parameters ELEPATH and POTPATH in \Fname{specdata.h} before compiling
\emph{ransub}.

It is possible to introduce
randomly distributed vacancies or empty sites by prefixing the solute name with ``\#''.

The \moldy\ distribution comes with three widely-used Buckingham potential
parameter sets (\Fname{bush.pot}, \Fname{catlow.pot} and
\Fname{grimes.pot}) taken from the literature. These may act as guides
to the potential parameter file format.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Syswrite}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\emph{Syswrite} is a utility for creating \moldy\ system specification
and initial configuration files from either Cambridge CSSR, Brookhaven
PDB, Schakal, Insight XTL or XYZ structural data files. This utility
is useful for automating the creation of \moldy\ input files from the output
of standard molecular graphics packages.
 If the structural data file contains a periodic system (\ie\, includes lattice parameter and space group information), 
\emph{syswrite} assumes the \emph{lattice start} method is to be used, and appends
the initial configuration info to the system specification file.
If no lattice information is supplied 
(for example when reading from an XYZ file or CSSR files written in non-periodic mode),
all atoms are assumed to belong to the same species, and a system specification file
suitable for using with the \emph{skew start} method is created. In this case the number
of molecules of the species can be specified using option \Lit{-n}. The default is 1.

In the case of periodic systems, \emph{syswrite} treats all species
as monatomic; polyatomic species can be introduced subsequent to
creating a system specification file (containing each molecule's centre of mass)
using the \emph{ransub} utility.

The physical properties of each atom/species not already contained in the
structure files are read in automatically from the text file
\Fname{elements.dat}. An alternative
file name can be specified using option \Lit{-e}. If a potential
parameter file name is given on the command line using option
\Lit{-y}, the appropriate pair interactions read from this file are
included in the system specification file (output).

The command line options are:
\begin{center}
\Lit{syswrite}
\Lit{[-i} \textit{input-file} \Lit{]}
\Lit{[-e} \textit{species-data-file}\Lit{]} 
\Lit{[-y} \textit{potential-parameter-file}\Lit{]} 
\Lit{[-n} \textit{number-of-molecules}\Lit{]}
\Lit{[-l} \textit{species-label}\Lit{]}
\Lit{[-o} \textit{output-file}\Lit{]}
\end{center}

where the arguments have the following meanings:
\begin{Argdescription}
\item[-i] read the structural data from given file. The file can be in
 Brookhaven PDB, Cambridge CSSR, Insight XTL or Schakal format.
\item[-e] read the species data (name, mass, charge, symbol) from the file
specified. (Defaults to \Fname{elements.dat}).
\item[-y] read interaction parameters for pairs of species
from the file specified. This is a text file of format:
\begin{displaymath}
\begin{array}{llllllll}
\multicolumn{4}{l}{\textit{potential-type}} \\
\textit{symbol}_1 & \textit{charge}_1 & \textit{symbol}_2 & \textit{charge}_2
 & p^{1}_{ij} & p^{2}_{ij} & \ldots & p^{r}_{ij}  \\
\textit{symbol}_3 & \textit{charge}_3 & \textit{symbol}_4 & \textit{charge}_4
 & p^{1}_{kl} & p^{2}_{kl} & \ldots & p^{r}_{kl}  \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots \\
\textit{symbol}_5 & \textit{charge}_5 & \textit{symbol}_6 & \textit{charge}_6
 & p^{1}_{mn} & p^{2}_{mn} & \ldots & p^{r}_{mn}  \\
\Lit{end} \\
\end{array}
\end{displaymath}
where the number of parameters, their values, order and units are the same
as in a system specification file (see section~\ref{sec:sys-spec}).
\item[-n] number of molecules of species. Only used for non-periodic systems, otherwise ignored.
\item[-l] name or label of species for non-periodic system. Default is to use name of input file (without extension).
\item[-o] name of output file. Defaults to standard output.
\end{Argdescription}

In interactive mode, the user is prompted for the name of the structure
file to read from. This must end in either ``\Fname{.pdb}'', ``\Fname{.cssr}'',
``\Fname{.shak}'', ``\Fname{.xtl}'' or ``\Fname{.xyz}'' (upper- or lowercase), so that \emph{syswrite} can
recognise the file format and successfully read in the data.

The default directory in which \emph{syswrite} searches for both the
species data file and potential parameter file (if specified) is the
current directory. The default pathnames for these
files can be changed to suit the user by re-defining the
parameters ELEPATH and POTPATH in \Fname{specdata.h} (and
recompiling \emph{syswrite}). Further details about the species data
and potential parameters file can be found in appendix~\ref{sec:ransub}.

Since both symbol and charge are specified in the potential parameter file,
\emph{syswrite} is able to handle (monatomic) species of the same element but different charge.
In this case, \emph{syswrite} modifies the species' names by appending consecutive
numbers to distinguish them, \eg\ Ce$^{+3}$ and Ce$^{+4}$ would be labelled
\Lit{cerium} and \Lit{cerium1}, respectively, if appearing in this order in the same
structure file. If no potential parameter file is specified, all
parameters are given default values of 0 and the potential type is given
as \textit{Potential parameters}.

The \moldy\ distribution comes with three widely-used Buckingham potential
parameter sets (\Fname{bush.pot}, \Fname{catlow.pot} and
\Fname{grimes.pot}) taken from the literature. These may act as a guide
to the potential parameter file format.

\bibliography{abbrevjn,simulation,mypubs}
\bibliographystyle{amsplain}

\end{document}
% LocalWords:  Fndescription Litdescription erf erfc subfig superfig Refson MCY
% LocalWords:  Parrinello Rahman Lennard Buckingham Stardent Alliant cray XMP
% LocalWords:  MFlop SGI SP Tildesley Pawley Powles Sonnenschein Rodger Nos co
% LocalWords:  Fincham Beeman's Perram Tildesley's subcells subcell Heyes CSSR
% LocalWords:  Rahman's RDF dat const Matsuoka Clementi Yoshimine MDBACKUP KE
% LocalWords:  Microsystems RDFs Leuuw Coulombic Leeuw unix DUSE TCGMSG BSP MPI
% LocalWords:  SPMD SHMEM defs struct structs auxil beeman ewald eigens rdf xdr
% LocalWords:  quaterns sysdef init potpar thermalise conv Abramowitz Stegun kJ
% LocalWords:  PVM accel ithread nthreads istep icell icell Moldyext KE's AVS
% LocalWords:  Dumpanal Dumpconv dumpconv SCHAKAL Quentrec nsteps rtmass mol ps
% LocalWords:  amu MPa nbins ndumps Debye MDDUMP stdlib stddef LIBS mt
% LocalWords:  aalloc alloc arralloc talloc tfree nspecies nsites nmols NPOTP
% LocalWords:  algorith ansi pre Pappalardo mdavpos bdist Murashov mdbond
% LocalWords:  ransub mdshak Fernandez Wentzcovitch wentzcovitch characterizing
% LocalWords:  syswrite eledata ELEPATH POTPATH Mxdorto Busing Ida Gilbert
% LocalWords:  Sanchez Marcos HIW
% LocalWords:  visualization Cerius CHARMM Plotrdf gnuplot Bekker
