#! /usr/bin/perl
#
# Plotrdf.  This script reads "Moldy" output files and extracts RDF information
# skipping page breaks.
#
# Usage: plotrdf [-a] [-m REGEXP] -g moldy-output-file ...
#
# Output format is in columns with different components laid out
# across the page "r rdf1 rdf2 rdf3 ..."
#
# If the -g flag is given the dara is output to a file and GNUPLOT commands to
# plot it are sent to the standard output instead.
#
# Multiple RDF blocks in one or multiple files are processed and output
# sequentially except if +-a" flag is given, whereupon they are averaged.
#
# Columns may be selected by matching with a PERL regular expression
# (sans //) given as the argument to the "-m" option.
#

sub rdfout  {
    my ($rdflist, $binw, $plotfd, $scale) = @_;
    my ($nrdf, $r);
    $r = 0.5*$binw;
    
    printf $plotfd ("#%7s","r");
    foreach $hdr ( keys %$rdflist ) {
	printf $plotfd (" %8s",$hdr);
	$hdrx = $hdr;
    }
    $nrdf=$#{$$rdflist{(keys %$rdflist)[0]}}+1;
    
    printf $plotfd ("\n");
    for( $j=0; $j < $nrdf ; $j++) {
	printf $plotfd ("%8.3f", $r);
	foreach $hdr ( keys %$rdflist ) {
	    printf $plotfd (" %8.3f",$scale*$$rdflist{$hdr}[$j]);
	}
	printf $plotfd ("\n");
	$r += $binw;
    }
}

sub usage {
   printf STDERR "Usage: plotrdf [-a] [-m REGEXP] [-g] moldy-output-file ...\n";
   printf STDERR "    -a         Take average of multiple RDF blocks\n";
   printf STDERR "    -g         Write a GNUPLOT script to plot data\n";
   printf STDERR "    -m REGEXP  output/plot only columns which match REGEXP\n";
}

sub gpout {
    my($hdrlist, $plotfile) = @_;
    my($i);
    
    print   "set data style lines\n";
    print   "set title \"",$title,"\"\n";
    print   "set xlabel \"r(A)\"\n";
    print   "set ylabel \"g(r)\"\n";
    print   "set yrange  [0:5]\n";
    print   "plot \"$plotfile\" using 1:2 title \"$$hdrlist[0]\"";
    foreach $i (2..@$hdrlist ) {
	print   ", \"$plotfile\" using 1:",$i+1," title \"$$hdrlist[$i-1]\"" ;
    }
    print   "\npause -1\n";
}

$gpflag = 0;
$aflag = 0;
$plotfd=*STDOUT;
$match = ".";
while ($#ARGV >= 0 && $ARGV[0] =~ /^-\w+/ ) {
    $flag=shift @ARGV;
    if ($flag eq "-g" ) {
	$gpflag++ ;
	$flag = "";
    }
    if( $flag eq "-a") {
	$aflag++;
	$flag = "";
    }
    if( $flag eq "-m") {
	$match = shift @ARGV;
	$flag = "";
    }
    if( $flag ne "" ) {
	usage;
	exit 1;
    }
}
$title=$ARGV[0];
if ($gpflag ) {
    $plotfile = $title.".data";
    open PLOTFILE, ">$plotfile" || die "Failed to open plot file $plotfile for writing\n";
    $plotfd=*PLOTFILE;
}

$be = 0;
$hdr = "";
$nrdfblocks=0;
$firstblock = 1;
$iline=0;
while ( <> ) {
    #
    # Reading phase
    #
    if ( /^_+$/ ... /^_+$/ ) {
	#
	# Store rdfs and column heads at end of "A-B RDF" block or and of RDFs
	#
	if ( (/^\s([^\s]+-[^\s]+) RDF$/ || /^_+$/) && $hdr ne "") {
	    if($hdr=~$match) {
		if( $aflag ) {
		    $nrdf=$#{$rdflist{$hdr}};
		    if( $firstblock == 0 && ( $#rdf != $nrdf || !exists $rdflist{$hdr})) {
			printf STDERR "Error: Multiple RDF data blocks do not match\n", $#rdf, $nrdf;
			exit 2;
		    }	
		    foreach $i (0..$#rdf) {
			$rdflist{$hdr}[$i] += $rdf[$i];
		    }
		} else {
		    $rdflist{$hdr} = [@rdf];
		}
	    }
	    @rdf = ();
	    $hdr = "";
	}
	# 
	# Record column header and binwidth
	#
	$hdr=$1 if (/^\s([^\s]+-[^\s]+) RDF$/);
	if  (/^\sRadial Distribution Functions\sBin width=([0-9.]+)$/)
	  {
	      $binw=$1 ;
	      $nrdfblocks++;
	  }
	#
	# Record data block
	#
	if ( /^[0-9.e ]+/ ) {
	    chop;
	    @line = split;
	    @rdf = (@rdf, @line);
	}
	#
	# RDF block is delimited by lined of underscores
	#
	if ( /^_+$/) {
	    if ($be == 0) {
		@rdf=();
		$be++;
	    } else {
		#
		# End of RDF block.  Print out results
		#
		$be = 0;
		$firstblock = 0;
		if( ! $aflag ) {
		    rdfout(\%rdflist, $binw, $plotfd, 1.0);
		    gpout([keys %rdflist], $plotfile) if ($gpflag);
		}
		
	    }
	}
    }
}
if( $aflag ) {
    rdfout(\%rdflist, $binw, $plotfd, 1.0/$nrdfblocks);
    gpout([keys %rdflist], $plotfile) if ($gpflag);
}
	
